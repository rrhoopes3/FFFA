<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FFFA - Feline Free For All Auto-Battler</title>
  <style>
    body { margin: 0; padding: 20px; background: #111; color: #fff; font-family: Arial, sans-serif; display: flex; flex-direction: column; gap: 20px; }
    #ui { display: flex; gap: 20px; align-items: center; font-size: 18px; font-weight: bold; justify-content: center; }
    button { background: #444; color: #fff; border: 2px solid #666; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; }
    button:hover { background: #555; border-color: #888; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button:disabled:hover { background: #444; }
    #shop { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
    .unit { background: linear-gradient(145deg, #333, #555); border: 2px solid #777; border-radius: 10px; padding: 15px; width: 130px; height: 150px; text-align: center; cursor: grab; user-select: none; transition: transform 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.5); }
    .unit:hover { transform: scale(1.05); }
    .unit:active { cursor: grabbing; }
    .unit-icon { font-size: 48px; margin: 10px 0; }
    .unit-name { font-size: 14px; margin: 5px 0; }
    .unit-cost { font-size: 16px; font-weight: bold; color: #ffd700; }
    .unit-faction { font-size: 12px; color: #aaa; }
    #game-container { display: flex; gap: 20px; justify-content: center; align-items: flex-start; }
    #synergies-panel { width: 200px; background: rgba(0,0,0,0.6); border: 2px solid #444; border-radius: 10px; padding: 15px; }
    #synergies-panel h3 { margin: 0 0 10px 0; font-size: 16px; text-align: center; color: #ffd700; }
    .synergy-item { display: flex; align-items: center; gap: 8px; padding: 8px; margin: 5px 0; border-radius: 5px; background: rgba(255,255,255,0.05); }
    .synergy-item.active { background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); }
    .synergy-item.inactive { opacity: 0.5; }
    .synergy-icon { font-size: 20px; }
    .synergy-info { flex: 1; }
    .synergy-name { font-size: 12px; font-weight: bold; }
    .synergy-count { font-size: 11px; color: #aaa; }
    .synergy-bonus { font-size: 10px; color: #4f4; margin-top: 2px; }
    .threshold { display: inline-block; padding: 1px 4px; margin: 1px; border-radius: 3px; font-size: 10px; }
    .threshold.active { background: #ffd700; color: #000; }
    .threshold.inactive { background: #333; color: #666; }
    #board { border: 3px solid #444; border-radius: 10px; background: #000; display: block; box-shadow: 0 8px 16px rgba(0,0,0,0.8); pointer-events: all; }
    #combatLog { position: fixed; top: 10px; right: 10px; width: 300px; height: 200px; background: rgba(0,0,0,0.8); padding: 10px; overflow-y: auto; font-size: 12px; display: none; border: 1px solid #666; border-radius: 5px; }

    /* Unit Tooltip */
    #unit-tooltip {
      position: fixed;
      display: none;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 2px solid #4a4a6a;
      border-radius: 12px;
      padding: 0;
      min-width: 260px;
      max-width: 300px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.8), 0 0 20px rgba(100,100,255,0.2);
      z-index: 1000;
      pointer-events: none;
      font-size: 13px;
    }
    .tooltip-header {
      background: linear-gradient(90deg, #2a2a4a, #3a3a5a);
      padding: 12px 15px;
      border-radius: 10px 10px 0 0;
      border-bottom: 1px solid #4a4a6a;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .tooltip-icon {
      font-size: 36px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    .tooltip-title {
      flex: 1;
    }
    .tooltip-name {
      font-size: 16px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 3px;
    }
    .tooltip-faction {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      display: inline-block;
    }
    .tooltip-cost {
      background: linear-gradient(135deg, #ffd700, #ffaa00);
      color: #000;
      font-weight: bold;
      font-size: 18px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(255,215,0,0.4);
    }
    .tooltip-body {
      padding: 12px 15px;
    }
    .tooltip-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }
    .tooltip-stat {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255,255,255,0.05);
      padding: 6px 10px;
      border-radius: 6px;
    }
    .stat-icon {
      font-size: 14px;
    }
    .stat-label {
      color: #888;
      font-size: 10px;
      text-transform: uppercase;
    }
    .stat-value {
      color: #fff;
      font-weight: bold;
      margin-left: auto;
    }
    .tooltip-ability {
      background: linear-gradient(135deg, rgba(100,50,150,0.3), rgba(50,50,100,0.3));
      border: 1px solid rgba(150,100,200,0.3);
      border-radius: 8px;
      padding: 10px;
    }
    .ability-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .ability-name {
      color: #c8a2ff;
      font-weight: bold;
      font-size: 13px;
    }
    .ability-trigger {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 8px;
      text-transform: uppercase;
      font-weight: bold;
    }
    .trigger-passive { background: #2d5a2d; color: #6fcf6f; }
    .trigger-on-attack { background: #5a2d2d; color: #cf6f6f; }
    .trigger-on-cast { background: #2d2d5a; color: #6f6fcf; }
    .ability-desc {
      color: #aaa;
      font-size: 11px;
      line-height: 1.4;
    }

    /* Bench System */
    #bench-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      padding: 15px;
      background: linear-gradient(180deg, #1a1a2e 0%, #0d0d1a 100%);
      border: 2px solid #333;
      border-radius: 10px;
      margin: 0 auto;
      max-width: 900px;
    }
    #bench-label {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #666;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .bench-slot {
      width: 70px;
      height: 70px;
      background: rgba(255,255,255,0.05);
      border: 2px dashed #444;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .bench-slot:hover {
      background: rgba(255,255,255,0.1);
      border-color: #666;
    }
    .bench-slot.occupied {
      border-style: solid;
      cursor: grab;
    }
    .bench-slot.drag-over {
      background: rgba(50,255,100,0.2);
      border-color: #4f4;
    }
    .bench-unit {
      font-size: 36px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .bench-unit-stars {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #ffd700;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }
    .bench-unit-cost {
      position: absolute;
      top: 2px;
      right: 4px;
      font-size: 10px;
      color: #ffd700;
      font-weight: bold;
    }

    /* Star display on board */
    .star-indicator {
      color: #ffd700;
      text-shadow: 0 0 4px rgba(255,215,0,0.8);
    }
    .star-2 { color: #4af; text-shadow: 0 0 6px rgba(68,170,255,0.8); }
    .star-3 { color: #f4a; text-shadow: 0 0 8px rgba(255,68,170,0.8); }

    /* Sell zone */
    #sell-zone {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 40px;
      background: rgba(255,50,50,0.2);
      border: 2px dashed #f44;
      border-radius: 10px;
      color: #f88;
      font-weight: bold;
      font-size: 14px;
      display: none;
      z-index: 100;
    }
    #sell-zone.active {
      display: block;
    }
    #sell-zone.drag-over {
      background: rgba(255,50,50,0.4);
      border-color: #f88;
      color: #fff;
    }

    /* Multiplayer Scoreboard */
    #scoreboard {
      position: fixed;
      right: 10px;
      top: 60px;
      width: 220px;
      background: rgba(0,0,0,0.85);
      border: 2px solid #444;
      border-radius: 10px;
      padding: 10px;
      display: none;
      z-index: 500;
    }
    #scoreboard.active {
      display: block;
    }
    #scoreboard h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #ffd700;
      text-align: center;
      border-bottom: 1px solid #444;
      padding-bottom: 8px;
    }
    .scoreboard-player {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      margin: 4px 0;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      transition: all 0.2s;
    }
    .scoreboard-player.eliminated {
      opacity: 0.4;
      text-decoration: line-through;
    }
    .scoreboard-player.current {
      background: rgba(255,215,0,0.2);
      border: 1px solid rgba(255,215,0,0.4);
    }
    .scoreboard-player.fighting {
      background: rgba(255,100,100,0.2);
      border: 1px solid rgba(255,100,100,0.4);
    }
    .player-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .player-name {
      flex: 1;
      font-size: 12px;
      font-weight: bold;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .player-health {
      font-size: 11px;
      color: #f66;
      min-width: 30px;
      text-align: right;
    }
    .player-health.healthy {
      color: #6f6;
    }
    .player-gold {
      font-size: 11px;
      color: #ffd700;
      min-width: 25px;
      text-align: right;
    }
    .player-streak {
      font-size: 10px;
      min-width: 20px;
      text-align: center;
    }
    .player-streak.win {
      color: #6f6;
    }
    .player-streak.loss {
      color: #f66;
    }

    /* Matchup Display */
    #matchup-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid #ffd700;
      border-radius: 15px;
      padding: 30px 50px;
      text-align: center;
      z-index: 1000;
      display: none;
    }
    #matchup-display.active {
      display: block;
    }
    .matchup-vs {
      font-size: 48px;
      color: #ffd700;
      margin: 20px 0;
    }
    .matchup-player {
      display: inline-block;
      padding: 15px 25px;
      margin: 0 20px;
      border-radius: 10px;
      font-size: 20px;
      font-weight: bold;
    }
    .matchup-result {
      margin-top: 20px;
      font-size: 24px;
      font-weight: bold;
    }
    .matchup-result.win {
      color: #4f4;
    }
    .matchup-result.loss {
      color: #f44;
    }
    .matchup-damage {
      font-size: 16px;
      color: #f88;
      margin-top: 10px;
    }

    /* Mode Selection */
    #mode-select {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      z-index: 2000;
    }
    #mode-select h1 {
      color: #ffd700;
      margin-bottom: 10px;
      font-size: 32px;
    }
    #mode-select h2 {
      color: #aaa;
      font-size: 16px;
      font-weight: normal;
      margin-bottom: 30px;
    }
    .mode-button {
      display: block;
      width: 100%;
      padding: 20px 40px;
      margin: 15px 0;
      font-size: 18px;
      font-weight: bold;
      border: 2px solid #666;
      border-radius: 10px;
      background: linear-gradient(145deg, #333, #444);
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-button:hover {
      background: linear-gradient(145deg, #444, #555);
      border-color: #ffd700;
      transform: scale(1.02);
    }
    .mode-button small {
      display: block;
      font-size: 12px;
      font-weight: normal;
      color: #aaa;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <span>Round: <span id="round">1</span></span>
    <span>Gold: <span id="gold">50</span></span>
    <span>Health: <span id="health">100</span></span>
    <span>Level: <span id="level">1</span></span>
    <span>Units: <span id="unitcap">0/3</span></span>
    <button id="fight">FIGHT!</button>
    <button id="reroll">REROLL (2g)</button>
    <button id="levelup">LEVEL UP (4g)</button>
  </div>
  <div id="shop"></div>
  <div id="game-container">
    <div id="synergies-panel">
      <h3>üê± Feline Factions</h3>
      <div id="synergies-list"></div>
    </div>
    <canvas id="board" width="1200" height="900"></canvas>
  </div>
  <div id="bench-container">
    <div class="bench-slot" data-slot="0"></div>
    <div class="bench-slot" data-slot="1"></div>
    <div class="bench-slot" data-slot="2"></div>
    <div class="bench-slot" data-slot="3"></div>
    <div class="bench-slot" data-slot="4"></div>
    <div class="bench-slot" data-slot="5"></div>
    <div class="bench-slot" data-slot="6"></div>
    <div class="bench-slot" data-slot="7"></div>
    <div class="bench-slot" data-slot="8"></div>
  </div>
  <div id="sell-zone">üóëÔ∏è SELL UNIT</div>
  <div id="combatLog"></div>
  <div id="unit-tooltip"></div>

  <!-- Multiplayer UI -->
  <div id="scoreboard">
    <h3>üèÜ PLAYERS</h3>
    <div id="scoreboard-list"></div>
  </div>

  <div id="matchup-display">
    <div class="matchup-player" id="matchup-player-a">Player A</div>
    <div class="matchup-vs">‚öîÔ∏è</div>
    <div class="matchup-player" id="matchup-player-b">Player B</div>
    <div class="matchup-result" id="matchup-result"></div>
    <div class="matchup-damage" id="matchup-damage"></div>
  </div>

  <div id="mode-select">
    <h1>üê± FFFA</h1>
    <h2>Auto-Battler</h2>
    <button class="mode-button" id="btn-single">
      üéÆ Single Player
      <small>Classic mode - fight random enemies</small>
    </button>
    <button class="mode-button" id="btn-multiplayer">
      üë• 8-Player Battle
      <small>Fight 7 bot opponents in round-robin</small>
    </button>
  </div>

  <script>
    const unitsData = {
      // ===== Alley Cats - Scrappy street survivors =====
      'alley_tabby_thug': { name: 'Tabby Thug', faction: 'Alley', coat: 'Spotted', cost: 1, color: '#A0AEC1', icon: 'üêà‚Äç‚¨õ', stats: {hp: 550, attack: 45, speed: 0.9, range: 1}, ability: {name: 'Dumpster Dive', trigger: 'passive', effect: {gold_on_kill: 1}} },
      'alley_ginger_rogue': { name: 'Ginger Rogue', faction: 'Alley', coat: 'Spotted', cost: 1, color: '#A0AEC1', icon: 'üê±', stats: {hp: 500, attack: 50, speed: 1.0, range: 1}, ability: {name: 'Alley Ambush', trigger: 'on-attack', effect: {crit_chance: 20, crit_mult: 1.5}} },
      'alley_tuxedo_con': { name: 'Tuxedo Con', faction: 'Alley', coat: 'Spotted', cost: 2, color: '#A0AEC1', icon: 'üòº', stats: {hp: 600, attack: 55, speed: 1.1, range: 1}, ability: {name: 'Pickpocket', trigger: 'on-attack', effect: {gold_steal: 2, once_per_target: true}} },
      'alley_street_yowler': { name: 'Street Yowler', faction: 'Alley', coat: 'Vocal', cost: 2, color: '#A0AEC1', icon: 'üòæ', stats: {hp: 550, attack: 50, speed: 1.0, range: 2}, ability: {name: 'Territorial Screech', trigger: 'on-cast', effect: {aoe_slow: {radius: 2, percent: 25}}} },
      'alley_dumpster_king': { name: 'Dumpster King', faction: 'Alley', coat: 'Spotted', cost: 3, color: '#A0AEC1', icon: 'üëë', stats: {hp: 800, attack: 65, speed: 0.9, range: 1}, ability: {name: 'Trash Tornado', trigger: 'on-cast', effect: {aoe_damage_mult: 1.5, gold_drop_chance: 30, gold_drop: 3}} },
      'alley_feral_boss': { name: 'Feral Boss', faction: 'Alley', coat: 'Spotted', cost: 5, color: '#A0AEC1', icon: 'ü¶¥', stats: {hp: 1200, attack: 95, speed: 1.0, range: 1}, ability: {name: 'Nine Lives', trigger: 'passive', effect: {revive_pct: 50, revive_attack_boost: 30}} },

      // ===== Persian Royals - Aristocratic fluffballs =====
      'persian_princess': { name: 'Persian Princess', faction: 'Persian', coat: 'Fluffy', cost: 2, color: '#F3E5F5', icon: 'üòª', stats: {hp: 650, attack: 50, speed: 0.8, range: 1}, ability: {name: 'Hairball Choke', trigger: 'on-attack', effect: {attack_speed_slow: 20, duration: 3}} },
      'persian_pampered': { name: 'Pampered Prince', faction: 'Persian', coat: 'Fluffy', cost: 1, color: '#F3E5F5', icon: 'üéÄ', stats: {hp: 600, attack: 40, speed: 0.7, range: 1}, ability: {name: 'Luxurious Fur', trigger: 'passive', effect: {armor: 20}} },
      'persian_groomer': { name: 'Royal Groomer', faction: 'Persian', coat: 'Fluffy', cost: 2, color: '#F3E5F5', icon: '‚ú®', stats: {hp: 700, attack: 45, speed: 0.8, range: 2}, ability: {name: 'Healing Licks', trigger: 'on-cast', effect: {ally_heal: 15, duration: 4}} },
      'persian_snob': { name: 'Aristocat Snob', faction: 'Persian', coat: 'Fluffy', cost: 3, color: '#F3E5F5', icon: 'üç∑', stats: {hp: 850, attack: 55, speed: 0.7, range: 1}, ability: {name: 'Disdainful Glare', trigger: 'on-attack', effect: {damage_reduction_enemy: 20, duration: 3}} },
      'persian_himalayan': { name: 'Himalayan Heir', faction: 'Persian', coat: 'Fluffy', cost: 4, color: '#F3E5F5', icon: 'üë∏', stats: {hp: 1000, attack: 60, speed: 0.8, range: 2}, ability: {name: 'Royal Decree', trigger: 'on-cast', effect: {ally_shield: 150, ally_armor: 20, duration: 5}} },
      'persian_emperor': { name: 'Persian Emperor', faction: 'Persian', coat: 'Fluffy', cost: 5, color: '#F3E5F5', icon: 'üè∞', stats: {hp: 1300, attack: 70, speed: 0.7, range: 1}, ability: {name: 'Throne of Fluff', trigger: 'passive', effect: {ally_hp_amp: 20, ally_armor: 30}} },

      // ===== Siamese Yowlers - Vocal and precise =====
      'siamese_screamer': { name: 'Siamese Screamer', faction: 'Siamese', coat: 'Vocal', cost: 1, color: '#60A5FA', icon: 'üê±', stats: {hp: 500, attack: 55, speed: 1.1, range: 2}, ability: {name: 'Yowl Blast', trigger: 'on-cast', effect: {aoe_silence: 2, radius: 2}} },
      'siamese_chatterbox': { name: 'Chatterbox', faction: 'Siamese', coat: 'Vocal', cost: 1, color: '#60A5FA', icon: 'üí¨', stats: {hp: 480, attack: 50, speed: 1.2, range: 2}, ability: {name: 'Annoying Meow', trigger: 'on-attack', effect: {mana_burn: 15}} },
      'siamese_soprano': { name: 'Soprano Singer', faction: 'Siamese', coat: 'Vocal', cost: 2, color: '#60A5FA', icon: 'üé§', stats: {hp: 550, attack: 60, speed: 1.1, range: 3}, ability: {name: 'High Note', trigger: 'on-cast', effect: {damage_mult: 1.8, stun: 1}} },
      'siamese_gossip': { name: 'Gossip Queen', faction: 'Siamese', coat: 'Vocal', cost: 3, color: '#60A5FA', icon: 'üëÑ', stats: {hp: 650, attack: 65, speed: 1.0, range: 2}, ability: {name: 'Spread Rumors', trigger: 'on-attack', effect: {ally_attack_amp: 15, duration: 4}} },
      'siamese_opera': { name: 'Opera Diva', faction: 'Siamese', coat: 'Vocal', cost: 4, color: '#60A5FA', icon: 'üé≠', stats: {hp: 750, attack: 80, speed: 1.1, range: 3}, ability: {name: 'Aria of Doom', trigger: 'on-cast', effect: {aoe_damage_mult: 2.0, aoe_silence: 3}} },
      'siamese_conductor': { name: 'Choir Conductor', faction: 'Siamese', coat: 'Vocal', cost: 5, color: '#60A5FA', icon: 'üéº', stats: {hp: 900, attack: 90, speed: 1.0, range: 4}, ability: {name: 'Symphony of Chaos', trigger: 'on-cast', effect: {ally_speed_amp: 40, aoe_stun: {radius: 3, duration: 2}}} },

      // ===== Maine Coon Giants - Big beefy tanks =====
      'mainecoon_titan': { name: 'Maine Coon Titan', faction: 'MaineCoon', coat: 'Fluffy', cost: 3, color: '#92400E', icon: 'ü¶Å', stats: {hp: 900, attack: 60, speed: 0.8, range: 1}, ability: {name: 'Paw Crush', trigger: 'on-attack', effect: {aoe_stun: 1, radius: 1}} },
      'mainecoon_cub': { name: 'Gentle Giant Cub', faction: 'MaineCoon', coat: 'Fluffy', cost: 1, color: '#92400E', icon: 'üêª', stats: {hp: 700, attack: 40, speed: 0.8, range: 1}, ability: {name: 'Big Bones', trigger: 'passive', effect: {hp_amp: 15}} },
      'mainecoon_guardian': { name: 'Floofy Guardian', faction: 'MaineCoon', coat: 'Fluffy', cost: 2, color: '#92400E', icon: 'üõ°Ô∏è', stats: {hp: 800, attack: 50, speed: 0.7, range: 1}, ability: {name: 'Fur Shield', trigger: 'passive', effect: {armor: 30, ally_armor: 10}} },
      'mainecoon_brawler': { name: 'Forest Brawler', faction: 'MaineCoon', coat: 'Fluffy', cost: 3, color: '#92400E', icon: 'üí™', stats: {hp: 950, attack: 70, speed: 0.9, range: 1}, ability: {name: 'Mighty Swipe', trigger: 'on-cast', effect: {damage_mult: 2.0, knockback: true}} },
      'mainecoon_elder': { name: 'Clan Elder', faction: 'MaineCoon', coat: 'Fluffy', cost: 4, color: '#92400E', icon: 'üßô', stats: {hp: 1100, attack: 65, speed: 0.7, range: 2}, ability: {name: 'Ancient Wisdom', trigger: 'passive', effect: {ally_hp_amp: 15, ally_damage_reduction: 15}} },
      'mainecoon_alpha': { name: 'Alpha Floof', faction: 'MaineCoon', coat: 'Fluffy', cost: 5, color: '#92400E', icon: 'üëë', stats: {hp: 1400, attack: 85, speed: 0.8, range: 1}, ability: {name: 'Earthquake Stomp', trigger: 'on-cast', effect: {aoe_damage_mult: 2.5, aoe_stun: {radius: 2, duration: 2}}} },

      // ===== Bengal Predators - Wild hunters =====
      'bengal_stalker': { name: 'Bengal Stalker', faction: 'Bengal', coat: 'Spotted', cost: 2, color: '#F59E0B', icon: 'üêÜ', stats: {hp: 600, attack: 65, speed: 1.2, range: 2}, ability: {name: 'Pounce Ambush', trigger: 'on-attack', effect: {first_hit_damage_mult: 1.5}} },
      'bengal_kitten': { name: 'Wild Kitten', faction: 'Bengal', coat: 'Spotted', cost: 1, color: '#F59E0B', icon: 'üêæ', stats: {hp: 500, attack: 55, speed: 1.3, range: 1}, ability: {name: 'Playful Strike', trigger: 'on-attack', effect: {crit_chance: 25}} },
      'bengal_hunter': { name: 'Jungle Hunter', faction: 'Bengal', coat: 'Spotted', cost: 2, color: '#F59E0B', icon: 'üéØ', stats: {hp: 550, attack: 70, speed: 1.2, range: 3}, ability: {name: 'Prey Mark', trigger: 'on-attack', effect: {vuln_debuff: 20, duration: 4}} },
      'bengal_assassin': { name: 'Shadow Assassin', faction: 'Bengal', coat: 'Spotted', cost: 3, color: '#F59E0B', icon: 'üó°Ô∏è', stats: {hp: 650, attack: 85, speed: 1.4, range: 1}, ability: {name: 'Backstab', trigger: 'on-cast', effect: {blink_backline: true, damage_mult: 2.5}} },
      'bengal_pack_leader': { name: 'Pack Leader', faction: 'Bengal', coat: 'Spotted', cost: 4, color: '#F59E0B', icon: 'üêÖ', stats: {hp: 850, attack: 90, speed: 1.2, range: 2}, ability: {name: 'Coordinated Hunt', trigger: 'on-cast', effect: {ally_crit: 25, ally_attack_speed: 20, duration: 5}} },
      'bengal_apex': { name: 'Apex Predator', faction: 'Bengal', coat: 'Spotted', cost: 5, color: '#F59E0B', icon: '‚ò†Ô∏è', stats: {hp: 1000, attack: 110, speed: 1.3, range: 1}, ability: {name: 'Killing Blow', trigger: 'on-attack', effect: {execute_threshold: 25, crit_chance: 40}} },

      // ===== Sphynx Weirdos - Hairless and strange =====
      'sphynx_menace': { name: 'Sphynx Menace', faction: 'Sphynx', coat: 'Hairless', cost: 3, color: '#F3A5B6', icon: 'üëΩ', stats: {hp: 550, attack: 70, speed: 1.1, range: 1}, ability: {name: 'Skin Infection', trigger: 'on-attack', effect: {poison: {damage: 30, duration: 4}}} },
      'sphynx_creeper': { name: 'Creepy Creeper', faction: 'Sphynx', coat: 'Hairless', cost: 1, color: '#F3A5B6', icon: 'ü´•', stats: {hp: 450, attack: 50, speed: 1.2, range: 1}, ability: {name: 'Unsettling Gaze', trigger: 'on-attack', effect: {attack_speed_slow: 15, duration: 2}} },
      'sphynx_warmer': { name: 'Heat Seeker', faction: 'Sphynx', coat: 'Hairless', cost: 2, color: '#F3A5B6', icon: 'üî•', stats: {hp: 500, attack: 60, speed: 1.3, range: 1}, ability: {name: 'Warmth Drain', trigger: 'on-attack', effect: {self_heal_on_damage: 20}} },
      'sphynx_cultist': { name: 'Weird Cultist', faction: 'Sphynx', coat: 'Hairless', cost: 3, color: '#F3A5B6', icon: 'üîÆ', stats: {hp: 600, attack: 75, speed: 1.1, range: 2}, ability: {name: 'Curse of Baldness', trigger: 'on-cast', effect: {armor_shred: 40, damage_mult: 1.5}} },
      'sphynx_oracle': { name: 'Naked Oracle', faction: 'Sphynx', coat: 'Hairless', cost: 4, color: '#F3A5B6', icon: 'üåô', stats: {hp: 700, attack: 80, speed: 1.2, range: 3}, ability: {name: 'Eldritch Vision', trigger: 'on-cast', effect: {aoe_silence: 3, aoe_slow: {radius: 2, percent: 40}}} },
      'sphynx_overlord': { name: 'Hairless Overlord', faction: 'Sphynx', coat: 'Hairless', cost: 5, color: '#F3A5B6', icon: 'üíÄ', stats: {hp: 900, attack: 100, speed: 1.1, range: 2}, ability: {name: 'Plague Touch', trigger: 'on-attack', effect: {poison: {damage: 50, duration: 5}, spread_poison: true}} },

      // ===== Scottish Folds - Quirky gamblers =====
      'scottish_gambler': { name: 'Scottish Gambler', faction: 'ScottishFold', coat: 'Fluffy', cost: 2, color: '#D1D5DB', icon: 'üôÄ', stats: {hp: 650, attack: 55, speed: 1.0, range: 1}, ability: {name: 'Fold Crit', trigger: 'passive', effect: {crit_chance: 30, self_damage_chance: 10}} },
      'scottish_lucky': { name: 'Lucky Paws', faction: 'ScottishFold', coat: 'Fluffy', cost: 1, color: '#D1D5DB', icon: 'üçÄ', stats: {hp: 550, attack: 45, speed: 1.0, range: 1}, ability: {name: 'Lucky Charm', trigger: 'passive', effect: {gold_drop_chance: 20, gold_drop: 2}} },
      'scottish_dealer': { name: 'Card Dealer', faction: 'ScottishFold', coat: 'Fluffy', cost: 2, color: '#D1D5DB', icon: 'üÉè', stats: {hp: 600, attack: 50, speed: 1.1, range: 2}, ability: {name: 'Wild Card', trigger: 'on-cast', effect: {random_buff: true, random_debuff_enemy: true}} },
      'scottish_bettor': { name: 'High Roller', faction: 'ScottishFold', coat: 'Fluffy', cost: 3, color: '#D1D5DB', icon: 'üé∞', stats: {hp: 700, attack: 60, speed: 1.0, range: 1}, ability: {name: 'All In', trigger: 'on-cast', effect: {damage_mult: 3.0, self_damage: 20}} },
      'scottish_fortune': { name: 'Fortune Teller', faction: 'ScottishFold', coat: 'Fluffy', cost: 4, color: '#D1D5DB', icon: 'üîÆ', stats: {hp: 800, attack: 70, speed: 0.9, range: 3}, ability: {name: 'Twist of Fate', trigger: 'on-cast', effect: {crit_chance: 50, ally_crit: 20, duration: 5}} },
      'scottish_jackpot': { name: 'Jackpot King', faction: 'ScottishFold', coat: 'Fluffy', cost: 5, color: '#D1D5DB', icon: 'üí∞', stats: {hp: 1000, attack: 80, speed: 1.0, range: 2}, ability: {name: 'Jackpot!', trigger: 'on-kill', effect: {gold_drop: 10, ally_heal: 20, aoe_damage_mult: 2.0}} },

      // ===== Ragdoll Flops - Deceptively lazy =====
      'ragdoll_faker': { name: 'Ragdoll Faker', faction: 'Ragdoll', coat: 'Fluffy', cost: 1, color: '#93C5FD', icon: 'üò¥', stats: {hp: 600, attack: 40, speed: 0.9, range: 1}, ability: {name: 'Play Dead', trigger: 'on-low-hp', effect: {fake_death: true, revive_pct: 40, attack_boost: 50}} },
      'ragdoll_lazy': { name: 'Lazy Loafer', faction: 'Ragdoll', coat: 'Fluffy', cost: 1, color: '#93C5FD', icon: 'üí§', stats: {hp: 650, attack: 35, speed: 0.7, range: 1}, ability: {name: 'Nap Time', trigger: 'passive', effect: {hp_regen_pct: 3}} },
      'ragdoll_flopper': { name: 'Master Flopper', faction: 'Ragdoll', coat: 'Fluffy', cost: 2, color: '#93C5FD', icon: 'ü´†', stats: {hp: 700, attack: 45, speed: 0.8, range: 1}, ability: {name: 'Go Limp', trigger: 'on-attack', effect: {dodge_chance: 30}} },
      'ragdoll_dreamer': { name: 'Daydreamer', faction: 'Ragdoll', coat: 'Fluffy', cost: 3, color: '#93C5FD', icon: 'üí≠', stats: {hp: 800, attack: 50, speed: 0.8, range: 2}, ability: {name: 'Dream Shield', trigger: 'on-cast', effect: {ally_shield: 200, invuln: 1}} },
      'ragdoll_therapist': { name: 'Cuddle Therapist', faction: 'Ragdoll', coat: 'Fluffy', cost: 4, color: '#93C5FD', icon: 'ü§ó', stats: {hp: 900, attack: 55, speed: 0.8, range: 2}, ability: {name: 'Group Hug', trigger: 'on-cast', effect: {ally_heal: 25, ally_cleanse: true}} },
      'ragdoll_zen': { name: 'Zen Master', faction: 'Ragdoll', coat: 'Fluffy', cost: 5, color: '#93C5FD', icon: '‚òØÔ∏è', stats: {hp: 1100, attack: 60, speed: 0.9, range: 3}, ability: {name: 'Inner Peace', trigger: 'passive', effect: {ally_hp_regen: 2, ally_damage_reduction: 20, revive_ally_chance: 30}} }
    };
    const allUnitIds = Object.keys(unitsData);

    // Group units by cost tier for weighted shop rolls
    const unitsByTier = { 1: [], 2: [], 3: [], 4: [], 5: [] };
    Object.entries(unitsData).forEach(([id, unit]) => {
      const tier = unit.cost || 1;
      if (unitsByTier[tier]) unitsByTier[tier].push(id);
    });

    // Shop odds by player level (% chance for each tier)
    // Format: [1-cost, 2-cost, 3-cost, 4-cost, 5-cost]
    const shopOdds = {
      1: [100, 0, 0, 0, 0],
      2: [75, 25, 0, 0, 0],
      3: [55, 30, 15, 0, 0],
      4: [45, 33, 20, 2, 0],
      5: [35, 35, 25, 5, 0],
      6: [25, 35, 30, 10, 0],
      7: [20, 30, 33, 15, 2],
      8: [15, 25, 35, 20, 5]
    };

    // Roll a random unit based on player level
    function rollShopUnit() {
      const odds = shopOdds[playerLevel] || shopOdds[1];
      const roll = Math.random() * 100;
      let cumulative = 0;

      for (let tier = 1; tier <= 5; tier++) {
        cumulative += odds[tier - 1];
        if (roll < cumulative) {
          const tierUnits = unitsByTier[tier];
          if (tierUnits.length > 0) {
            return tierUnits[Math.floor(Math.random() * tierUnits.length)];
          }
        }
      }
      // Fallback to tier 1
      return unitsByTier[1][Math.floor(Math.random() * unitsByTier[1].length)];
    }

    // Roll shop unit for a specific level (used by multiplayer Player class)
    function rollShopUnitForLevel(level) {
      const odds = shopOdds[level] || shopOdds[1];
      const roll = Math.random() * 100;
      let cumulative = 0;

      for (let tier = 1; tier <= 5; tier++) {
        cumulative += odds[tier - 1];
        if (roll < cumulative) {
          const tierUnits = unitsByTier[tier];
          if (tierUnits.length > 0) {
            return tierUnits[Math.floor(Math.random() * tierUnits.length)];
          }
        }
      }
      // Fallback to tier 1
      return unitsByTier[1][Math.floor(Math.random() * unitsByTier[1].length)];
    }

    // ========== TOOLTIP SYSTEM ==========
    const tooltip = document.getElementById('unit-tooltip');
    let tooltipVisible = false;

    function getAbilityDescription(ability) {
      if (!ability || !ability.effect) return ability?.name || 'No ability';

      const e = ability.effect;
      const parts = [];

      // Gold effects
      if (e.gold_per_round) parts.push(`+${e.gold_per_round} gold per round`);
      if (e.gold_per_attack) parts.push(`+${e.gold_per_attack} gold per attack`);
      if (e.gold_steal) parts.push(`Steal ${e.gold_steal} gold${e.once_per_target ? ' (once per target)' : ''}`);
      if (e.gold_drop_chance) parts.push(`${e.gold_drop_chance}% chance for +${e.gold_drop} gold`);

      // Damage effects
      if (e.damage_mult) parts.push(`${Math.round((e.damage_mult - 1) * 100)}% bonus damage`);
      if (e.aoe_damage_mult) parts.push(`${Math.round(e.aoe_damage_mult * 100)}% AoE damage`);
      if (e.crit_chance) parts.push(`+${e.crit_chance}% crit chance`);
      if (e.crit_mult) parts.push(`${e.crit_mult}x crit damage`);
      if (e.execute_threshold) parts.push(`Execute enemies below ${e.execute_threshold}% HP`);

      // Healing
      if (e.self_heal) parts.push(`Heal ${e.self_heal}% of max HP`);
      if (e.self_heal_on_damage) parts.push(`${e.self_heal_on_damage}% lifesteal`);

      // CC effects
      if (e.stun) parts.push(`Stun for ${e.stun}s`);
      if (e.aoe_stun) parts.push(`AoE stun for ${e.aoe_stun.duration || e.aoe_stun}s`);
      if (e.silence) parts.push(`Silence for ${e.silence}s`);
      if (e.root) parts.push(`Root for ${e.root.duration}s`);
      if (e.attack_speed_slow) parts.push(`Slow attack speed ${e.attack_speed_slow}%`);
      if (e.aoe_slow) parts.push(`AoE slow ${e.aoe_slow.percent || e.aoe_slow}%`);

      // DoT effects
      if (e.poison) parts.push(`Poison: ${e.poison.damage} dmg/s for ${e.poison.duration}s`);
      if (e.bleed) parts.push(`Bleed: ${e.bleed.damage} dmg over ${e.bleed.duration}s`);

      // Defensive
      if (e.armor) parts.push(`+${e.armor} armor`);
      if (e.damage_reduction) parts.push(`${e.damage_reduction}% damage reduction`);
      if (e.ally_shield) parts.push(`Shield allies for ${e.ally_shield}`);

      // Buffs
      if (e.ally_attack_speed) parts.push(`+${e.ally_attack_speed}% ally attack speed`);
      if (e.ally_damage_amp) parts.push(`+${e.ally_damage_amp}% ally damage`);
      if (e.ally_armor) parts.push(`+${e.ally_armor} armor to allies`);
      if (e.ally_crit) parts.push(`+${e.ally_crit}% crit to allies`);

      return parts.length > 0 ? parts.join('. ') + '.' : 'Special effect';
    }

    function showTooltip(unitId, x, y) {
      const unit = unitsData[unitId];
      if (!unit) return;

      const synergy = factionSynergies[unit.faction];
      const factionColor = synergy?.color || '#888';
      const factionName = synergy?.name || unit.faction;
      const factionIcon = synergy?.icon || 'üåê';

      const triggerClass = unit.ability?.trigger === 'passive' ? 'trigger-passive' :
                          unit.ability?.trigger === 'on-attack' ? 'trigger-on-attack' : 'trigger-on-cast';

      tooltip.innerHTML = `
        <div class="tooltip-header">
          <span class="tooltip-icon">${unit.icon}</span>
          <div class="tooltip-title">
            <div class="tooltip-name">${unit.name}</div>
            <span class="tooltip-faction" style="background: ${factionColor}33; color: ${factionColor}; border: 1px solid ${factionColor}55;">
              ${factionIcon} ${factionName}
            </span>
          </div>
          <div class="tooltip-cost">${unit.cost}</div>
        </div>
        <div class="tooltip-body">
          <div class="tooltip-stats">
            <div class="tooltip-stat">
              <span class="stat-icon">‚ù§Ô∏è</span>
              <span class="stat-label">HP</span>
              <span class="stat-value">${unit.stats.hp}</span>
            </div>
            <div class="tooltip-stat">
              <span class="stat-icon">‚öîÔ∏è</span>
              <span class="stat-label">ATK</span>
              <span class="stat-value">${unit.stats.attack}</span>
            </div>
            <div class="tooltip-stat">
              <span class="stat-icon">‚ö°</span>
              <span class="stat-label">SPD</span>
              <span class="stat-value">${unit.stats.speed.toFixed(1)}</span>
            </div>
            <div class="tooltip-stat">
              <span class="stat-icon">üéØ</span>
              <span class="stat-label">RNG</span>
              <span class="stat-value">${unit.stats.range}</span>
            </div>
          </div>
          ${unit.ability ? `
          <div class="tooltip-ability">
            <div class="ability-header">
              <span class="ability-name">‚ú® ${unit.ability.name}</span>
              <span class="ability-trigger ${triggerClass}">${unit.ability.trigger}</span>
            </div>
            <div class="ability-desc">${getAbilityDescription(unit.ability)}</div>
          </div>
          ` : ''}
        </div>
      `;

      // Position tooltip
      const tooltipRect = tooltip.getBoundingClientRect();
      const padding = 15;

      // Default: show to the right of cursor
      let left = x + padding;
      let top = y - 20;

      // Adjust if would go off screen
      if (left + 280 > window.innerWidth) {
        left = x - 280 - padding;
      }
      if (top + 250 > window.innerHeight) {
        top = window.innerHeight - 260;
      }
      if (top < 10) top = 10;

      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      tooltip.style.display = 'block';
      tooltipVisible = true;
    }

    function hideTooltip() {
      tooltip.style.display = 'none';
      tooltipVisible = false;
    }

    // Track hovered unit on board
    let hoveredBoardUnit = null;

    // Animation utility functions
    function addAttackPulse(x, y, color, radius = 30) {
      visualEffects.push({
        type: 'attackPulse',
        x: x,
        y: y,
        color: color,
        radius: radius,
        startTime: Date.now(),
        duration: 400
      });
    }

    function addDeathEffect(x, y, color, radius = 40) {
      visualEffects.push({
        type: 'deathEffect',
        x: x,
        y: y,
        color: color,
        radius: radius,
        startTime: Date.now(),
        duration: 600
      });
    }

    function addAbilityEffect(x, y, color, radius = 50) {
      visualEffects.push({
        type: 'abilityEffect',
        x: x,
        y: y,
        color: color,
        radius: radius,
        startTime: Date.now(),
        duration: 800
      });
    }

    // Enhanced combat effects
    function addCombatHitEffect(attacker, target, damage, isCrit = false) {
      const attackerHex = boardHexes.find(h => getHexKey(h) === attacker.hexKey);
      const targetHex = boardHexes.find(h => getHexKey(h) === target.hexKey);

      if (attackerHex && targetHex) {
        const attackerPos = hexToPixel(attackerHex);
        const targetPos = hexToPixel(targetHex);

        // Add attack pulse effect
        addAttackPulse(attackerPos.x, attackerPos.y, attacker.color, 40);

        // Add attack particles
        addAttackParticles(attackerPos.x, attackerPos.y, attacker.color);

        // Add attack line effect
        visualEffects.push({
          type: 'attackLine',
          x: attackerPos.x,
          y: attackerPos.y,
          x2: targetPos.x,
          y2: targetPos.y,
          color: attacker.color,
          startTime: Date.now(),
          duration: 300
        });

        // Add damage number
        addDamageNumber(target.hexKey, damage, isCrit);

        // Add hit effect at target location
        visualEffects.push({
          type: 'hitEffect',
          x: targetPos.x,
          y: targetPos.y,
          color: attacker.color,
          startTime: Date.now(),
          duration: 400
        });
      }
    }

    function addHitEffect(x, y, color) {
      visualEffects.push({
        type: 'hitEffect',
        x: x,
        y: y,
        color: color,
        startTime: Date.now(),
        duration: 400
      });
    }

    // ========== FACTION SYNERGY SYSTEM ==========
    const factionSynergies = {
      Alley: {
        name: "Alley Cats",
        icon: "üêà‚Äç‚¨õ",
        color: "#A0AEC1",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "+2 gold per round", gold_per_round: 2 },
          4: { description: "+4 gold per round, +15% attack", gold_per_round: 4, attack_amp: 15 },
          6: { description: "+6 gold per round, +25% attack, +10% interest", gold_per_round: 6, attack_amp: 25, interest_bonus: 10 }
        }
      },
      Persian: {
        name: "Persian",
        icon: "üê±",
        color: "#F0E6D3",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "+25 armor, +10% damage reflect", armor: 25, damage_reflect: 10 },
          4: { description: "+45 armor, +20% reflect, 10% slow enemies", armor: 45, damage_reflect: 20, slow_enemies: 10 },
          6: { description: "+70 armor, +30% reflect, 20% slow, +200 HP", armor: 70, damage_reflect: 30, slow_enemies: 20, hp_flat: 200 }
        }
      },
      Siamese: {
        name: "Siamese",
        icon: "üò∫",
        color: "#D4B896",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "+20% attack speed, screech stuns 0.5s", attack_speed: 20, stun_on_cast: 0.5 },
          4: { description: "+35% attack speed, screech stuns 1s, -15% enemy armor", attack_speed: 35, stun_on_cast: 1, armor_shred: 15 },
          6: { description: "+50% attack speed, screech stuns 1.5s, -25% armor, +20 mana/hit", attack_speed: 50, stun_on_cast: 1.5, armor_shred: 25, mana_on_hit: 20 }
        }
      },
      MaineCoon: {
        name: "Maine Coon",
        icon: "ü¶Å",
        color: "#8B7355",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "+30% HP, +10% lifesteal", hp_amp: 30, lifesteal: 10 },
          4: { description: "+50% HP, +20% lifesteal, AOE attacks", hp_amp: 50, lifesteal: 20, aoe_attacks: true },
          6: { description: "+75% HP, +30% lifesteal, AOE, roar fears enemies 1s", hp_amp: 75, lifesteal: 30, aoe_attacks: true, fear_on_ability: 1 }
        }
      },
      Bengal: {
        name: "Bengal",
        icon: "üêÜ",
        color: "#D4A574",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "+20% crit chance, +25% crit damage", crit_chance: 20, crit_damage: 25 },
          4: { description: "+30% crit, +50% crit dmg, leap to backline", crit_chance: 30, crit_damage: 50, assassin_leap: true },
          6: { description: "+40% crit, +80% crit dmg, leap, execute <20% HP", crit_chance: 40, crit_damage: 80, assassin_leap: true, execute_threshold: 20 }
        }
      },
      Sphynx: {
        name: "Sphynx",
        icon: "üëΩ",
        color: "#E8D5C4",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "Attacks apply disease: 20 dmg/sec", poison_on_hit: 20 },
          4: { description: "Disease 35 dmg/sec, spreads to nearby enemies", poison_on_hit: 35, disease_spread: true },
          6: { description: "Disease 50 dmg/sec, spreads, -20% enemy healing", poison_on_hit: 50, disease_spread: true, grievous_wounds: 20 }
        }
      },
      ScottishFold: {
        name: "Scottish Fold",
        icon: "üé≤",
        color: "#C4B5A0",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "25% chance: double damage OR heal 15%", gamble_damage: 25, gamble_heal: 15 },
          4: { description: "35% chance: double damage OR heal 25%, +15% attack", gamble_damage: 35, gamble_heal: 25, attack_amp: 15 },
          6: { description: "50% chance: triple damage OR full heal, +30% attack", gamble_damage: 50, gamble_heal: 100, triple_gamble: true, attack_amp: 30 }
        }
      },
      Ragdoll: {
        name: "Ragdoll",
        icon: "üé≠",
        color: "#F5E6D3",
        thresholds: [2, 4, 6],
        bonuses: {
          2: { description: "+20% dodge, revive once at 20% HP", dodge: 20, revive_pct: 20 },
          4: { description: "+35% dodge, revive at 35% HP, go limp (invuln 1s) at 50%", dodge: 35, revive_pct: 35, limp_invuln: 1 },
          6: { description: "+50% dodge, revive at 50% HP, limp 2s, deceive (clone on death)", dodge: 50, revive_pct: 50, limp_invuln: 2, clone_on_death: true }
        }
      }
    };

    // Calculate active synergies based on player board
    function calculateSynergies() {
      const factionCounts = {};
      const activeSynergies = {};

      // Count units per faction (handle new {id, stars} format)
      Object.values(playerBoard).forEach(unitData => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const unit = unitsData[unitId];
        if (unit) {
          const faction = unit.faction;
          factionCounts[faction] = (factionCounts[faction] || 0) + 1;
        }
      });

      // Determine active bonuses
      Object.entries(factionSynergies).forEach(([faction, synergy]) => {
        const count = factionCounts[faction] || 0;
        let activeThreshold = 0;
        let activeBonus = null;

        for (const threshold of synergy.thresholds) {
          if (count >= threshold) {
            activeThreshold = threshold;
            activeBonus = synergy.bonuses[threshold];
          }
        }

        activeSynergies[faction] = {
          count,
          activeThreshold,
          activeBonus,
          synergy
        };
      });

      return { factionCounts, activeSynergies };
    }

    // Render synergies panel
    function renderSynergies() {
      const { activeSynergies } = calculateSynergies();
      const list = document.getElementById('synergies-list');
      list.innerHTML = '';

      // Sort: active synergies first, then by count
      const sorted = Object.entries(activeSynergies)
        .sort((a, b) => {
          if (a[1].activeBonus && !b[1].activeBonus) return -1;
          if (!a[1].activeBonus && b[1].activeBonus) return 1;
          return b[1].count - a[1].count;
        });

      sorted.forEach(([faction, data]) => {
        if (data.count === 0) return; // Don't show factions with no units

        const div = document.createElement('div');
        div.className = `synergy-item ${data.activeBonus ? 'active' : 'inactive'}`;

        // Build threshold indicators
        const thresholds = data.synergy.thresholds.map(t =>
          `<span class="threshold ${data.count >= t ? 'active' : 'inactive'}">${t}</span>`
        ).join('');

        div.innerHTML = `
          <span class="synergy-icon">${data.synergy.icon}</span>
          <div class="synergy-info">
            <div class="synergy-name" style="color: ${data.synergy.color}">${data.synergy.name}</div>
            <div class="synergy-count">${thresholds} (${data.count})</div>
            ${data.activeBonus ? `<div class="synergy-bonus">${data.activeBonus.description}</div>` : ''}
          </div>
        `;
        list.appendChild(div);
      });

      // If no synergies active, show hint
      if (list.children.length === 0) {
        list.innerHTML = '<div style="text-align: center; color: #666; font-size: 12px; padding: 20px;">Place units to activate synergies!</div>';
      }
    }

    // ========== 8-PLAYER MULTIPLAYER SYSTEM ==========
    const PLAYER_COLORS = [
      '#4CAF50', // Green - Human player
      '#F44336', // Red
      '#2196F3', // Blue
      '#FF9800', // Orange
      '#9C27B0', // Purple
      '#00BCD4', // Cyan
      '#FFEB3B', // Yellow
      '#E91E63'  // Pink
    ];

    const PLAYER_NAMES = [
      'You', 'Whiskers', 'Mittens', 'Shadow',
      'Luna', 'Felix', 'Cleo', 'Tiger'
    ];

    // Player class - encapsulates all player state
    class Player {
      constructor(id, name, isBot = false) {
        this.id = id;
        this.name = name;
        this.color = PLAYER_COLORS[id];
        this.isBot = isBot;
        this.gold = 50;
        this.health = 100;
        this.level = 1;
        this.board = {};        // hexKey -> {id, stars}
        this.bench = Array(9).fill(null);
        this.shop = [];
        this.synergies = {};    // Cached synergy bonuses
        this.isAlive = true;
        this.wins = 0;
        this.losses = 0;
        this.streak = 0;        // Positive = win streak, negative = loss streak
        this.placement = 0;     // Final placement (1-8)
      }

      getUnitCap() {
        return this.level + 2;
      }

      getBoardUnitCount() {
        return Object.keys(this.board).length;
      }

      canAfford(cost) {
        return this.gold >= cost;
      }

      spendGold(amount) {
        this.gold = Math.max(0, this.gold - amount);
      }

      earnGold(amount) {
        this.gold += amount;
      }

      takeDamage(amount) {
        this.health = Math.max(0, this.health - amount);
        if (this.health <= 0) {
          this.isAlive = false;
        }
      }

      // Roll a shop based on player level
      rollShop() {
        this.shop = Array(5).fill().map(() => rollShopUnitForLevel(this.level));
      }

      // Calculate synergies from board
      calculateSynergies() {
        const factionCounts = {};
        const coatCounts = {};

        Object.values(this.board).forEach(unitData => {
          const unitId = typeof unitData === 'object' ? unitData.id : unitData;
          const unit = unitsData[unitId];
          if (unit) {
            factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
            if (unit.coat) {
              coatCounts[unit.coat] = (coatCounts[unit.coat] || 0) + 1;
            }
          }
        });

        this.synergies = { factions: factionCounts, coats: coatCounts };
        return this.synergies;
      }
    }

    // Game state manager for 8-player mode
    const GameState = {
      mode: 'single',           // 'single' or 'multiplayer'
      round: 1,
      phase: 'shop',            // 'shop', 'combat', 'settlement'
      players: [],              // Array of Player objects
      humanPlayerIndex: 0,      // Index of human player
      matchups: [],             // Current round matchups: [{playerA: idx, playerB: idx, winner: null}]
      currentMatchupIndex: 0,   // Which matchup is being displayed
      eliminationOrder: [],     // Track order of elimination for placements
      roundRobinSchedule: [],   // Pre-generated schedule

      // Initialize 8-player game
      init(humanCount = 1) {
        this.mode = 'multiplayer';
        this.round = 1;
        this.phase = 'shop';
        this.players = [];
        this.humanPlayerIndex = 0;
        this.eliminationOrder = [];

        // Create players (first one is human, rest are bots)
        for (let i = 0; i < 8; i++) {
          const isBot = i >= humanCount;
          const player = new Player(i, PLAYER_NAMES[i], isBot);
          player.rollShop();
          this.players.push(player);
        }

        // Generate round-robin schedule
        this.generateRoundRobinSchedule();

        return this.players[this.humanPlayerIndex];
      },

      // Generate round-robin schedule for 8 players
      // Each round: 4 matches, each player fights once
      // Full cycle: 7 rounds for everyone to fight everyone
      generateRoundRobinSchedule() {
        this.roundRobinSchedule = [];
        const n = 8;

        // Circle method for round-robin tournament
        // Fix player 0, rotate others
        for (let round = 0; round < n - 1; round++) {
          const matches = [];
          const rotation = [0];

          // Build rotation array
          for (let i = 1; i < n; i++) {
            const pos = (i - 1 + round) % (n - 1) + 1;
            rotation.push(pos);
          }

          // Pair up: first with last, second with second-last, etc.
          for (let i = 0; i < n / 2; i++) {
            matches.push({
              playerA: rotation[i],
              playerB: rotation[n - 1 - i]
            });
          }

          this.roundRobinSchedule.push(matches);
        }
      },

      // Get matchups for current round (handles dead players)
      getMatchupsForRound() {
        const scheduleIndex = (this.round - 1) % 7;
        const baseMatchups = this.roundRobinSchedule[scheduleIndex];

        // Filter to only alive players and create ghost army matchups
        const alivePlayers = this.players.filter(p => p.isAlive).map(p => p.id);

        if (alivePlayers.length <= 1) {
          return []; // Game over
        }

        const matchups = [];
        const paired = new Set();

        // Try to use scheduled matchups first
        for (const match of baseMatchups) {
          const aAlive = this.players[match.playerA].isAlive;
          const bAlive = this.players[match.playerB].isAlive;

          if (aAlive && bAlive && !paired.has(match.playerA) && !paired.has(match.playerB)) {
            matchups.push({
              playerA: match.playerA,
              playerB: match.playerB,
              winner: null,
              combatLog: [],
              damage: 0
            });
            paired.add(match.playerA);
            paired.add(match.playerB);
          }
        }

        // Handle unpaired alive players (fight ghost of random opponent)
        const unpaired = alivePlayers.filter(id => !paired.has(id));
        for (const playerId of unpaired) {
          // Fight ghost army of random alive opponent
          const opponents = alivePlayers.filter(id => id !== playerId);
          if (opponents.length > 0) {
            const ghostOpponent = opponents[Math.floor(Math.random() * opponents.length)];
            matchups.push({
              playerA: playerId,
              playerB: ghostOpponent,
              isGhostMatch: true,  // Mark that playerB won't take damage
              winner: null,
              combatLog: [],
              damage: 0
            });
          }
        }

        this.matchups = matchups;
        return matchups;
      },

      // Get human player
      getHumanPlayer() {
        return this.players[this.humanPlayerIndex];
      },

      // Get alive players count
      getAliveCount() {
        return this.players.filter(p => p.isAlive).length;
      },

      // Check if game is over
      isGameOver() {
        return this.getAliveCount() <= 1;
      },

      // Get winner
      getWinner() {
        const alive = this.players.filter(p => p.isAlive);
        return alive.length === 1 ? alive[0] : null;
      },

      // Process eliminations after combat
      processEliminations() {
        this.players.forEach(player => {
          if (!player.isAlive && player.placement === 0) {
            player.placement = 8 - this.eliminationOrder.length;
            this.eliminationOrder.push(player.id);
          }
        });
      },

      // Advance to next round
      nextRound() {
        this.round++;
        this.phase = 'shop';
        this.currentMatchupIndex = 0;

        // Refresh shops for all alive players
        this.players.forEach(player => {
          if (player.isAlive) {
            player.rollShop();
          }
        });
      }
    };

    // ========== BOT AI SYSTEM (Medium Difficulty) ==========
    const BotAI = {
      // Run bot turn: buy units, level up, place on board
      takeTurn(player) {
        if (!player.isBot || !player.isAlive) return;

        // 1. Decide whether to level up or save
        this.decideLevelUp(player);

        // 2. Buy units from shop
        this.buyUnits(player);

        // 3. Position units on board
        this.positionUnits(player);

        // 4. Maybe reroll if gold is high and looking for upgrades
        this.decideReroll(player);
      },

      // Level up decision: level if gold > 50 and can benefit
      decideLevelUp(player) {
        const levelUpCost = player.level < 9 ? 4 : 999;
        // Level up if: plenty of gold AND bench has units waiting
        const benchCount = player.bench.filter(u => u !== null).length;
        const boardCount = player.getBoardUnitCount();

        if (player.gold >= levelUpCost + 10 && boardCount >= player.getUnitCap() && player.level < 9) {
          player.spendGold(levelUpCost);
          player.level++;
        }
      },

      // Buy units that complete synergies or can upgrade
      buyUnits(player) {
        const shop = player.shop;
        if (!shop || shop.length === 0) return;

        // Count units we have for upgrade potential
        const unitCounts = this.countUnits(player);

        // Get current faction counts
        const factionCounts = {};
        Object.values(player.board).forEach(u => {
          const unit = unitsData[typeof u === 'object' ? u.id : u];
          if (unit) factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
        });
        player.bench.forEach(u => {
          if (u) {
            const unit = unitsData[u.id];
            if (unit) factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
          }
        });

        // Score and buy units
        for (let i = 0; i < shop.length; i++) {
          const unitId = shop[i];
          if (!unitId) continue;

          const unit = unitsData[unitId];
          if (!unit || !player.canAfford(unit.cost)) continue;

          // Find empty bench slot
          const emptySlot = player.bench.findIndex(s => s === null);
          if (emptySlot === -1) break; // Bench full

          // Calculate buy priority
          let priority = 0;

          // High priority: can upgrade (have 2 copies already)
          const count = unitCounts[unitId] || 0;
          if (count >= 2) priority += 50;
          else if (count >= 1) priority += 20;

          // Medium priority: completes synergy threshold
          const factionCount = factionCounts[unit.faction] || 0;
          if (factionCount === 1 || factionCount === 3 || factionCount === 5) {
            priority += 30; // One away from threshold
          }

          // Lower priority for expensive units early
          if (GameState.round <= 5 && unit.cost >= 4) {
            priority -= 20;
          }

          // Buy if priority is decent or we have lots of gold
          if (priority >= 20 || (player.gold >= 30 && unit.cost <= 2)) {
            player.spendGold(unit.cost);
            player.bench[emptySlot] = { id: unitId, stars: 1 };
            shop[i] = null; // Remove from shop

            // Check for merge
            this.checkAndMerge(player, unitId, 1);

            // Update counts
            unitCounts[unitId] = (unitCounts[unitId] || 0) + 1;
            factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
          }
        }
      },

      // Count all units (board + bench) by ID and star level
      countUnits(player) {
        const counts = {};

        Object.values(player.board).forEach(u => {
          const id = typeof u === 'object' ? u.id : u;
          const stars = typeof u === 'object' ? u.stars : 1;
          const key = `${id}_${stars}`;
          counts[id] = (counts[id] || 0) + 1;
          counts[key] = (counts[key] || 0) + 1;
        });

        player.bench.forEach(u => {
          if (u) {
            const key = `${u.id}_${u.stars}`;
            counts[u.id] = (counts[u.id] || 0) + 1;
            counts[key] = (counts[key] || 0) + 1;
          }
        });

        return counts;
      },

      // Check and perform merges for bot
      checkAndMerge(player, unitId, starLevel) {
        if (starLevel >= 3) return;

        let matches = [];

        // Check board
        Object.entries(player.board).forEach(([key, unit]) => {
          if (unit.id === unitId && unit.stars === starLevel) {
            matches.push({ location: 'board', key });
          }
        });

        // Check bench
        player.bench.forEach((unit, index) => {
          if (unit && unit.id === unitId && unit.stars === starLevel) {
            matches.push({ location: 'bench', index });
          }
        });

        if (matches.length >= 3) {
          // Perform merge
          const newStars = starLevel + 1;
          let firstBoardKey = null;
          let firstBenchIndex = null;

          matches.slice(0, 3).forEach(match => {
            if (match.location === 'board') {
              if (!firstBoardKey) firstBoardKey = match.key;
              else delete player.board[match.key];
            } else {
              if (firstBenchIndex === null && !firstBoardKey) firstBenchIndex = match.index;
              else player.bench[match.index] = null;
            }
          });

          if (firstBoardKey) {
            player.board[firstBoardKey] = { id: unitId, stars: newStars };
          } else if (firstBenchIndex !== null) {
            player.bench[firstBenchIndex] = { id: unitId, stars: newStars };
          }

          // Recursively check for next level merge
          this.checkAndMerge(player, unitId, newStars);
        }
      },

      // Position units: tanks front (row 4), damage back (rows 5-7)
      positionUnits(player) {
        // Get all units from bench that can be placed
        const boardCount = player.getBoardUnitCount();
        const unitCap = player.getUnitCap();

        if (boardCount >= unitCap) return;

        // Get available hexes in player zone (rows 4-7)
        const frontRow = [4];
        const backRows = [5, 6, 7];

        const occupiedHexes = new Set(Object.keys(player.board));

        // Categorize bench units by role
        const benchUnits = player.bench
          .map((u, idx) => u ? { ...u, benchIndex: idx } : null)
          .filter(u => u !== null);

        // Sort: tanks (Maine Coon, high HP) first, then damage dealers
        benchUnits.sort((a, b) => {
          const unitA = unitsData[a.id];
          const unitB = unitsData[b.id];
          const tankFactions = ['MaineCoon', 'Persian', 'Ragdoll'];

          const aIsTank = tankFactions.includes(unitA?.faction) || (unitA?.stats?.hp > 700);
          const bIsTank = tankFactions.includes(unitB?.faction) || (unitB?.stats?.hp > 700);

          if (aIsTank && !bIsTank) return -1;
          if (!aIsTank && bIsTank) return 1;
          return (unitB?.cost || 0) - (unitA?.cost || 0); // Higher cost first
        });

        // Place units
        let placed = 0;
        for (const benchUnit of benchUnits) {
          if (boardCount + placed >= unitCap) break;

          const unit = unitsData[benchUnit.id];
          const tankFactions = ['MaineCoon', 'Persian', 'Ragdoll'];
          const isTank = tankFactions.includes(unit?.faction) || (unit?.stats?.hp > 700);

          // Find hex
          let targetHex = null;
          const rows = isTank ? frontRow : backRows;

          for (const row of [...rows, ...frontRow, ...backRows]) {
            for (let col = 0; col < 7; col++) {
              const key = `${col},${row}`;
              if (!occupiedHexes.has(key)) {
                targetHex = key;
                break;
              }
            }
            if (targetHex) break;
          }

          if (targetHex) {
            player.board[targetHex] = { id: benchUnit.id, stars: benchUnit.stars };
            player.bench[benchUnit.benchIndex] = null;
            occupiedHexes.add(targetHex);
            placed++;
          }
        }
      },

      // Reroll decision
      decideReroll(player) {
        // Reroll if: high gold, looking for upgrades, still have bench space
        if (player.gold < 10) return;

        const unitCounts = this.countUnits(player);
        const hasUpgradePotential = Object.values(unitCounts).some(c => c === 2);
        const benchHasSpace = player.bench.some(s => s === null);

        if (hasUpgradePotential && benchHasSpace && player.gold >= 20) {
          player.spendGold(2);
          player.rollShop();
          // Try buying again after reroll
          this.buyUnits(player);
        }
      }
    };

    // ========== MULTIPLAYER COMBAT SYSTEM ==========
    const MultiplayerCombat = {
      // Current combat state
      activeBattles: [],       // Array of battle simulations
      displayedBattleIndex: 0, // Which battle is shown to human player
      combatPhaseComplete: false,

      // Calculate synergy bonuses for a player's board
      getSynergyBonusesForPlayer(player) {
        const factionCounts = {};
        Object.values(player.board).forEach(unitData => {
          const unitId = typeof unitData === 'object' ? unitData.id : unitData;
          const unit = unitsData[unitId];
          if (unit) {
            factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
          }
        });

        const bonuses = {};
        Object.entries(factionCounts).forEach(([faction, count]) => {
          const synergy = factionSynergies[faction];
          if (!synergy) return;

          let activeBonus = null;
          for (let i = synergy.thresholds.length - 1; i >= 0; i--) {
            if (count >= synergy.thresholds[i]) {
              activeBonus = synergy.bonuses[i];
              break;
            }
          }
          if (activeBonus) {
            bonuses[faction] = activeBonus;
          }
        });

        return bonuses;
      },

      // Create ghost army from a player's board (deep copy for combat)
      createGhostArmy(player, asAttacker = true) {
        const synergyBonuses = this.getSynergyBonusesForPlayer(player);
        const army = [];

        Object.entries(player.board).forEach(([hexKey, unitData]) => {
          const unitId = typeof unitData === 'object' ? unitData.id : unitData;
          const stars = typeof unitData === 'object' ? unitData.stars : 1;

          // Mirror hex position if this is the "enemy" (playerB)
          let combatHexKey = hexKey;
          if (!asAttacker) {
            const [col, row] = hexKey.split(',').map(Number);
            // Mirror: row 4 -> row 3, row 5 -> row 2, row 6 -> row 1, row 7 -> row 0
            const mirrorRow = 7 - row;
            combatHexKey = `${col},${mirrorRow}`;
          }

          const unit = createCombatUnit(unitId, combatHexKey, asAttacker, synergyBonuses, stars);
          if (unit) {
            unit.stars = stars;
            unit.ownerId = player.id;
            unit.ownerColor = player.color;
            army.push(unit);
          }
        });

        return army;
      },

      // Simulate a single battle between two players (instant, no animation)
      simulateBattle(playerA, playerB, isGhostMatch = false) {
        const armyA = this.createGhostArmy(playerA, true);
        const armyB = this.createGhostArmy(playerB, false);

        const allUnits = [...armyA, ...armyB];
        const combatLog = [];
        let tick = 0;
        const MAX_TICKS = 1000; // Prevent infinite loops

        combatLog.push(`=== ${playerA.name} vs ${playerB.name} ===`);
        combatLog.push(`${playerA.name}: ${armyA.length} units`);
        combatLog.push(`${playerB.name}: ${armyB.length} units`);

        // Run simulation
        while (tick < MAX_TICKS) {
          const aliveA = armyA.filter(u => u.hp > 0);
          const aliveB = armyB.filter(u => u.hp > 0);

          if (aliveA.length === 0 || aliveB.length === 0) break;

          // Process each unit's action
          for (const unit of allUnits) {
            if (unit.hp <= 0) continue;

            // Find target
            const enemies = unit.isPlayer ? armyB : armyA;
            const target = enemies.filter(e => e.hp > 0)
              .sort((a, b) => hexDistance(unit.hexKey, a.hexKey) - hexDistance(unit.hexKey, b.hexKey))[0];

            if (!target) continue;

            const dist = hexDistance(unit.hexKey, target.hexKey);

            // Attack if in range
            if (dist <= unit.range) {
              let damage = unit.attack;

              // Crit check
              if (Math.random() * 100 < unit.critChance) {
                damage = Math.round(damage * (unit.critDamage / 100));
              }

              // Apply armor reduction
              const armorReduction = target.armor / (target.armor + 100);
              damage = Math.round(damage * (1 - armorReduction));

              target.hp -= damage;

              // Lifesteal
              if (unit.lifesteal > 0) {
                const heal = Math.round(damage * unit.lifesteal / 100);
                unit.hp = Math.min(unit.maxHp, unit.hp + heal);
              }
            } else {
              // Move toward target (simplified)
              const [col, row] = unit.hexKey.split(',').map(Number);
              const [tcol, trow] = target.hexKey.split(',').map(Number);
              const dc = Math.sign(tcol - col);
              const dr = Math.sign(trow - row);
              const newKey = `${col + dc},${row + dr}`;

              // Check if hex is valid and not occupied
              const occupied = allUnits.filter(u => u.hp > 0 && u !== unit).map(u => u.hexKey);
              if (!occupied.includes(newKey)) {
                unit.hexKey = newKey;
              }
            }
          }

          tick++;
        }

        // Determine winner
        const survivorsA = armyA.filter(u => u.hp > 0);
        const survivorsB = armyB.filter(u => u.hp > 0);

        let winner = null;
        let loser = null;
        let damage = 0;

        if (survivorsA.length > 0 && survivorsB.length === 0) {
          winner = playerA;
          loser = playerB;
          // Damage = 2 + sum of surviving unit costs
          damage = 2 + survivorsA.reduce((sum, u) => sum + (unitsData[u.id]?.cost || 1), 0);
        } else if (survivorsB.length > 0 && survivorsA.length === 0) {
          winner = playerB;
          loser = playerA;
          damage = 2 + survivorsB.reduce((sum, u) => sum + (unitsData[u.id]?.cost || 1), 0);
        } else {
          // Draw or timeout - both take minor damage
          damage = 2;
        }

        combatLog.push(`--- Result: ${winner ? winner.name + ' wins!' : 'Draw!'} ---`);
        if (damage > 0 && loser) {
          combatLog.push(`${loser.name} takes ${damage} damage`);
        }

        return {
          playerA: playerA.id,
          playerB: playerB.id,
          winner: winner?.id ?? null,
          loser: loser?.id ?? null,
          damage,
          isGhostMatch,
          survivorsA: survivorsA.length,
          survivorsB: survivorsB.length,
          combatLog,
          // Store armies for animated replay
          armyA,
          armyB
        };
      },

      // Run all matchups for the round
      runAllMatchups() {
        const matchups = GameState.getMatchupsForRound();
        const results = [];

        for (const matchup of matchups) {
          const playerA = GameState.players[matchup.playerA];
          const playerB = GameState.players[matchup.playerB];

          // Skip if either player has no units
          if (Object.keys(playerA.board).length === 0) {
            // Auto-loss for playerA
            results.push({
              ...matchup,
              winner: playerB.id,
              loser: playerA.id,
              damage: 2 + playerB.level,
              combatLog: [`${playerA.name} has no units - auto loss!`]
            });
            continue;
          }
          if (Object.keys(playerB.board).length === 0) {
            results.push({
              ...matchup,
              winner: playerA.id,
              loser: playerB.id,
              damage: 2 + playerA.level,
              combatLog: [`${playerB.name} has no units - auto loss!`]
            });
            continue;
          }

          const result = this.simulateBattle(playerA, playerB, matchup.isGhostMatch);
          results.push(result);
        }

        this.activeBattles = results;
        return results;
      },

      // Apply results to players (damage, streaks, gold)
      applyResults() {
        for (const result of this.activeBattles) {
          const playerA = GameState.players[result.playerA];
          const playerB = GameState.players[result.playerB];

          if (result.winner !== null) {
            const winner = GameState.players[result.winner];
            const loser = GameState.players[result.loser];

            // Update streaks
            winner.wins++;
            winner.streak = winner.streak > 0 ? winner.streak + 1 : 1;

            loser.losses++;
            loser.streak = loser.streak < 0 ? loser.streak - 1 : -1;

            // Apply damage (only if not ghost match, or loser is the one who initiated)
            if (!result.isGhostMatch || result.loser === result.playerA) {
              loser.takeDamage(result.damage);
            }

            // Gold rewards
            const baseGold = 5;
            const streakBonus = Math.min(3, Math.abs(winner.streak) - 1);
            winner.earnGold(baseGold + streakBonus);

            // Loser still gets some gold
            loser.earnGold(2);
          } else {
            // Draw - both get base gold, small damage
            playerA.earnGold(3);
            playerB.earnGold(3);
            if (!result.isGhostMatch) {
              playerA.takeDamage(2);
              playerB.takeDamage(2);
            }
          }
        }

        // Process eliminations
        GameState.processEliminations();
      },

      // Get the battle result for a specific player
      getPlayerBattle(playerId) {
        return this.activeBattles.find(b => b.playerA === playerId || b.playerB === playerId);
      }
    };

    // Legacy single-player variables (kept for compatibility during transition)
    let gold = 50;
    let health = 100;
    let playerLevel = 1;
    let currentRound = 1;
    let shopUnits = [];
    let playerBoard = {}; // {hexKey: {id: unitId, stars: 1-3}}
    let enemyBoard = {};
    let bench = Array(9).fill(null); // [{id: unitId, stars: 1-3}, ...]
    let preCombatBoard = {}; // Snapshot of player positions before combat
    let highlightHex = null;
    let draggedUnit = null; // {fromShop, fromBench, fromBoard, id, cost, stars, slotIndex, oldKey}
    let roundBanner = null; // {text, startTime, duration}

    // Animation state
    let animationFrame = 0;  // Global tick for idle/motion
    let unitAnimations = {};  // {hexKey: {type: 'attack', time: 0, target: {...}}}
    const ANIM_DURATION = 300;  // ms for effects

    // Unit images for rendering
    let unitImages = {};

    // ========== SOUND SYSTEM ==========
    let attackCounter = 0; // Track attacks for "every 5th" meow
    let soundEnabled = true;
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Generate a "meow" sound using Web Audio API oscillators
    function playMeow(type = 'attack') {
      if (!soundEnabled) return;

      // Resume audio context if suspended (browser autoplay policy)
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }

      const now = audioContext.currentTime;

      // Create oscillator for the meow
      const osc = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      osc.connect(gainNode);
      gainNode.connect(audioContext.destination);

      // Different meow types
      if (type === 'death') {
        // Sad descending meow for death
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(150, now + 0.4);
        gainNode.gain.setValueAtTime(0.15, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
      } else if (type === 'attack') {
        // Quick chirpy meow for attack
        osc.type = 'triangle';
        // Randomize pitch slightly for variety
        const basePitch = 400 + Math.random() * 200;
        osc.frequency.setValueAtTime(basePitch, now);
        osc.frequency.exponentialRampToValueAtTime(basePitch * 1.5, now + 0.05);
        osc.frequency.exponentialRampToValueAtTime(basePitch * 0.8, now + 0.15);
        gainNode.gain.setValueAtTime(0.12, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
      } else if (type === 'hiss') {
        // Angry hiss for crits
        const bufferSize = audioContext.sampleRate * 0.2;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
        }
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(0.1, now);
        noise.connect(noiseGain);
        noiseGain.connect(audioContext.destination);
        noise.start(now);
      }
    }

    // Call this on attack - only plays every 5th attack
    function maybePlayAttackMeow() {
      attackCounter++;
      if (attackCounter % 5 === 0) {
        playMeow('attack');
      }
    }

    // Call this on death - always plays
    function playDeathMeow() {
      playMeow('death');
    }

    // Call this on crit - hiss!
    function playHiss() {
      playMeow('hiss');
    }

    // ========== SPRITE ANIMATION SYSTEM ==========
    // Sprite sheets: 8 frames horizontal, 128x128 per frame
    const SPRITE_FRAME_SIZE = 128;
    const SPRITE_FRAMES = 8;
    const SPRITE_FPS = 10; // Frames per second for animation

    // Animation states and their frame ranges within the 8-frame sheet
    const ANIM_STATES = {
      idle: { start: 0, end: 3, loop: true },      // Frames 0-3: idle breathing/bobbing
      attack: { start: 4, end: 7, loop: false },   // Frames 4-7: attack windup + strike
      hurt: { start: 6, end: 7, loop: false },     // Frames 6-7: recoil (reuse attack end)
      death: { start: 7, end: 7, loop: false }     // Frame 7: final frame held
    };

    // Sprite sheets storage (one per faction for now, can expand to per-unit)
    let spriteSheets = {};

    // Track current animation state per combat unit
    // { unitId: { state: 'idle', frame: 0, lastFrameTime: timestamp } }
    let unitSpriteStates = {};

    // Load sprite sheet for a faction
    function loadSpriteSheet(faction, filename) {
      const img = new Image();
      img.src = `sprites/${filename}`;
      img.onload = () => {
        spriteSheets[faction] = img;
        console.log(`Loaded sprite sheet for ${faction}`);
      };
      img.onerror = () => {
        console.warn(`Failed to load sprite sheet: sprites/${filename}`);
      };
    }

    // Initialize sprite sheets (call this on game start)
    function loadAllSpriteSheets() {
      const factions = ['Alley', 'Persian', 'Siamese', 'MaineCoon', 'Bengal', 'Sphynx', 'ScottishFold', 'Ragdoll'];
      factions.forEach(faction => {
        loadSpriteSheet(faction, `${faction.toLowerCase()}_sheet.png`);
      });
    }

    // Get current animation frame for a unit
    function getUnitSpriteFrame(unitId, faction) {
      const now = Date.now();

      // Initialize state if not exists
      if (!unitSpriteStates[unitId]) {
        unitSpriteStates[unitId] = {
          state: 'idle',
          frame: 0,
          lastFrameTime: now,
          stateStartTime: now
        };
      }

      const state = unitSpriteStates[unitId];
      const animConfig = ANIM_STATES[state.state];
      const frameDuration = 1000 / SPRITE_FPS;

      // Check if we should advance frame
      if (now - state.lastFrameTime >= frameDuration) {
        state.lastFrameTime = now;
        state.frame++;

        // Check if animation complete
        if (state.frame > animConfig.end) {
          if (animConfig.loop) {
            state.frame = animConfig.start;
          } else {
            // Non-looping animation finished - return to idle (unless dead)
            if (state.state !== 'death') {
              state.state = 'idle';
              state.frame = ANIM_STATES.idle.start;
              state.stateStartTime = now;
            } else {
              state.frame = animConfig.end; // Hold on last frame
            }
          }
        }
      }

      return state.frame;
    }

    // Set animation state for a unit
    function setUnitAnimation(unitId, newState) {
      if (!unitSpriteStates[unitId]) {
        unitSpriteStates[unitId] = { state: 'idle', frame: 0, lastFrameTime: Date.now(), stateStartTime: Date.now() };
      }

      const state = unitSpriteStates[unitId];
      if (state.state !== newState) {
        state.state = newState;
        state.frame = ANIM_STATES[newState].start;
        state.stateStartTime = Date.now();
        state.lastFrameTime = Date.now();
      }
    }

    // Draw a unit using sprite sheet
    function drawUnitSprite(ctx, cx, cy, unit, stars = 1, combatUnit = null) {
      const faction = unit.faction;
      const unitId = combatUnit ? combatUnit.id : unit.id || unit.name;

      // Determine if this is a player or enemy unit
      const isPlayer = combatUnit ? combatUnit.isPlayer : true;
      const teamColor = isPlayer ? '#4488ff' : '#ff4444'; // Blue for player, red for enemy
      const teamColorGlow = isPlayer ? 'rgba(68, 136, 255, 0.6)' : 'rgba(255, 68, 68, 0.6)';

      // Get current frame
      const frame = getUnitSpriteFrame(unitId, faction);

      // Check if we have a sprite sheet for this faction
      const sheet = spriteSheets[faction];

      if (sheet && sheet.complete) {
        // Calculate source rectangle from sprite sheet
        const sx = frame * SPRITE_FRAME_SIZE;
        const sy = 0;

        // Destination size (fit in hex)
        const destSize = hexSize * 1.4;

        // Draw shadow first
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(cx, cy + destSize * 0.4, destSize * 0.3, destSize * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Draw team-colored outline/base circle BEHIND the sprite
        ctx.beginPath();
        ctx.arc(cx, cy + destSize * 0.1, destSize * 0.45, 0, Math.PI * 2);
        ctx.fillStyle = teamColorGlow;
        ctx.fill();
        ctx.strokeStyle = teamColor;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Star glow effect
        const glowColors = { 1: unit.color, 2: '#4af', 3: '#f4a' };
        ctx.shadowColor = glowColors[stars];
        ctx.shadowBlur = stars === 1 ? 10 : stars === 2 ? 20 : 30;

        // Draw the sprite
        ctx.drawImage(
          sheet,
          sx, sy, SPRITE_FRAME_SIZE, SPRITE_FRAME_SIZE,  // Source
          cx - destSize / 2, cy - destSize / 2, destSize, destSize  // Dest
        );

        ctx.shadowBlur = 0;

        // Draw team indicator arrow above unit
        ctx.fillStyle = teamColor;
        ctx.beginPath();
        if (isPlayer) {
          // Upward arrow for player (pointing at enemy)
          ctx.moveTo(cx, cy - destSize * 0.55);
          ctx.lineTo(cx - 6, cy - destSize * 0.45);
          ctx.lineTo(cx + 6, cy - destSize * 0.45);
        } else {
          // Downward arrow for enemy (pointing at player)
          ctx.moveTo(cx, cy - destSize * 0.45);
          ctx.lineTo(cx - 6, cy - destSize * 0.55);
          ctx.lineTo(cx + 6, cy - destSize * 0.55);
        }
        ctx.closePath();
        ctx.fill();

        // Draw star indicators
        ctx.font = '12px Arial';
        ctx.fillStyle = glowColors[stars];
        ctx.textAlign = 'center';
        ctx.fillText('‚òÖ'.repeat(stars), cx, cy + destSize * 0.5);

        return true; // Successfully drew sprite
      }

      return false; // No sprite available, use fallback
    }

    // Generate placeholder sprite sheet (colored silhouette with animation)
    function generatePlaceholderSheet(faction, color) {
      const canvas = document.createElement('canvas');
      canvas.width = SPRITE_FRAME_SIZE * SPRITE_FRAMES;
      canvas.height = SPRITE_FRAME_SIZE;
      const ctx = canvas.getContext('2d');

      // Faction-specific shapes
      const shapes = {
        'Alley': 'scrappy',
        'Persian': 'fluffy',
        'Siamese': 'sleek',
        'MaineCoon': 'large',
        'Bengal': 'crouched',
        'Sphynx': 'thin',
        'ScottishFold': 'round',
        'Ragdoll': 'floppy'
      };

      for (let frame = 0; frame < SPRITE_FRAMES; frame++) {
        const x = frame * SPRITE_FRAME_SIZE + SPRITE_FRAME_SIZE / 2;
        const y = SPRITE_FRAME_SIZE / 2;

        ctx.save();
        ctx.translate(x, y);

        // Animation offset based on frame
        let yOffset = 0;
        let scaleX = 1;
        let scaleY = 1;
        let rotation = 0;

        if (frame < 4) {
          // Idle: gentle bob
          yOffset = Math.sin(frame * Math.PI / 2) * 5;
        } else {
          // Attack: lunge forward
          const attackFrame = frame - 4;
          scaleX = 1 + attackFrame * 0.1;
          yOffset = -attackFrame * 3;
          rotation = attackFrame * 0.1;
        }

        ctx.translate(0, yOffset);
        ctx.rotate(rotation);
        ctx.scale(scaleX, scaleY);

        // Draw cat silhouette
        ctx.fillStyle = color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;

        // Body
        ctx.beginPath();
        ctx.ellipse(0, 10, 30, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.ellipse(0, -25, 22, 20, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Ears
        ctx.beginPath();
        ctx.moveTo(-15, -40);
        ctx.lineTo(-20, -55);
        ctx.lineTo(-5, -45);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(15, -40);
        ctx.lineTo(20, -55);
        ctx.lineTo(5, -45);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-8, -28, 6, 7, 0, 0, Math.PI * 2);
        ctx.ellipse(8, -28, 6, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pupils (follow attack direction)
        ctx.fillStyle = '#000';
        const pupilOffset = frame >= 4 ? 2 : 0;
        ctx.beginPath();
        ctx.ellipse(-8 + pupilOffset, -28, 3, 4, 0, 0, Math.PI * 2);
        ctx.ellipse(8 + pupilOffset, -28, 3, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tail
        ctx.strokeStyle = color;
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.beginPath();
        const tailWave = Math.sin(frame * Math.PI / 2) * 10;
        ctx.moveTo(25, 20);
        ctx.quadraticCurveTo(45 + tailWave, 10, 40, -10 + tailWave);
        ctx.stroke();

        ctx.restore();
      }

      // Convert canvas to image
      const img = new Image();
      img.src = canvas.toDataURL();
      return img;
    }

    // Generate all placeholder sheets
    function generateAllPlaceholderSheets() {
      const factionColors = {
        'Alley': '#A0AEC1',
        'Persian': '#F8E8FF',
        'Siamese': '#D4B896',
        'MaineCoon': '#8B7355',
        'Bengal': '#DAA520',
        'Sphynx': '#FFB6C1',
        'ScottishFold': '#98D8C8',
        'Ragdoll': '#93C5FD'
      };

      Object.entries(factionColors).forEach(([faction, color]) => {
        const sheet = generatePlaceholderSheet(faction, color);
        sheet.onload = () => {
          spriteSheets[faction] = sheet;
          console.log(`Generated placeholder sprite for ${faction}`);
        };
        // For data URLs, onload fires synchronously after setting src
        if (sheet.complete) {
          spriteSheets[faction] = sheet;
        }
      });
    }

    // ========== STAR LEVEL SYSTEM ==========
    const STAR_MULTIPLIERS = {
      1: 1.0,
      2: 1.8,
      3: 3.0
    };

    // Get sell value based on cost and stars
    function getSellValue(cost, stars) {
      if (stars === 1) return cost;
      if (stars === 2) return cost * 3; // 3 copies worth
      if (stars === 3) return cost * 9; // 9 copies worth
      return cost;
    }

    // Check if we can merge 3 units of same type/star level
    function checkForMerge(unitId, starLevel) {
      // Count matching units on board and bench
      let matches = [];

      // Check board
      Object.entries(playerBoard).forEach(([key, unit]) => {
        if (unit.id === unitId && unit.stars === starLevel) {
          matches.push({ location: 'board', key });
        }
      });

      // Check bench
      bench.forEach((unit, index) => {
        if (unit && unit.id === unitId && unit.stars === starLevel) {
          matches.push({ location: 'bench', index });
        }
      });

      return matches.length >= 3 ? matches : null;
    }

    // Perform merge: remove 3 units, create upgraded unit
    function performMerge(matches, unitId, currentStars) {
      if (currentStars >= 3) return false; // Can't upgrade beyond 3 stars

      const newStars = currentStars + 1;

      // Remove the 3 matching units, keep track of first board position
      let firstBoardKey = null;
      let firstBenchIndex = null;

      matches.slice(0, 3).forEach(match => {
        if (match.location === 'board') {
          if (!firstBoardKey) firstBoardKey = match.key;
          else delete playerBoard[match.key];
        } else {
          if (!firstBenchIndex && firstBenchIndex !== 0 && !firstBoardKey) firstBenchIndex = match.index;
          else bench[match.index] = null;
        }
      });

      // Place upgraded unit in first position found
      if (firstBoardKey) {
        playerBoard[firstBoardKey] = { id: unitId, stars: newStars };
      } else if (firstBenchIndex !== null) {
        bench[firstBenchIndex] = { id: unitId, stars: newStars };
      }

      // Show merge effect
      addMergeEffect(unitId, newStars);

      // Check for another merge at the new star level
      setTimeout(() => {
        const nextMerge = checkForMerge(unitId, newStars);
        if (nextMerge) {
          performMerge(nextMerge, unitId, newStars);
        }
        renderBench();
        renderBoard();
        renderSynergies();
        updateUI();
      }, 300);

      return true;
    }

    function addMergeEffect(unitId, stars) {
      const unit = unitsData[unitId];
      roundBanner = {
        text: `‚≠ê ${stars}-STAR ${unit.name.toUpperCase()}! ‚≠ê`,
        subtext: stars === 2 ? '√ó1.8 stats!' : '√ó3.0 stats!',
        color: stars === 2 ? '#4af' : '#f4a',
        startTime: Date.now(),
        duration: 1500
      };
    }

    // Try to add a unit (from shop) - returns true if successful
    function tryAddUnit(unitId) {
      // First check if adding this would trigger a merge
      const existingMatches = checkForMerge(unitId, 1);

      if (existingMatches && existingMatches.length >= 2) {
        // We have 2 already, this will make 3 - find a spot temporarily
        const emptyBenchSlot = bench.findIndex(s => s === null);
        if (emptyBenchSlot !== -1) {
          bench[emptyBenchSlot] = { id: unitId, stars: 1 };
          // Now check and perform merge
          const matches = checkForMerge(unitId, 1);
          if (matches) {
            performMerge(matches, unitId, 1);
          }
          return true;
        }
        return false; // No space
      }

      // No merge possible, just add to bench
      const emptySlot = bench.findIndex(s => s === null);
      if (emptySlot !== -1) {
        bench[emptySlot] = { id: unitId, stars: 1 };
        // Still check for merge in case we now have 3
        const matches = checkForMerge(unitId, 1);
        if (matches) {
          performMerge(matches, unitId, 1);
        }
        return true;
      }

      return false; // Bench full
    }

    // Visual effects for combat
    let visualEffects = []; // {type, x, y, text, color, startTime, duration}
    let particles = []; // Global array for particle effects

    function addDamageNumber(hexKey, damage, isCrit = false) {
      const hex = boardHexes.find(h => getHexKey(h) === hexKey);
      if (!hex) return;
      const p = hexToPixel(hex);
      visualEffects.push({
        type: 'damage',
        x: p.x + (Math.random() - 0.5) * 20,
        y: p.y - 20,
        text: `-${Math.round(damage)}`,
        color: isCrit ? '#ff0' : '#f44',
        startTime: Date.now(),
        duration: 800
      });
    }

    function addHealNumber(hexKey, amount) {
      const hex = boardHexes.find(h => getHexKey(h) === hexKey);
      if (!hex) return;
      const p = hexToPixel(hex);
      visualEffects.push({
        type: 'heal',
        x: p.x + (Math.random() - 0.5) * 20,
        y: p.y - 20,
        text: `+${Math.round(amount)}`,
        color: '#4f4',
        startTime: Date.now(),
        duration: 800
      });
    }

    function addAttackLine(fromKey, toKey, color = '#fff') {
      const fromHex = boardHexes.find(h => getHexKey(h) === fromKey);
      const toHex = boardHexes.find(h => getHexKey(h) === toKey);
      if (!fromHex || !toHex) return;
      const from = hexToPixel(fromHex);
      const to = hexToPixel(toHex);
      visualEffects.push({
        type: 'attackLine',
        x: from.x, y: from.y,
        x2: to.x, y2: to.y,
        color,
        startTime: Date.now(),
        duration: 150
      });
    }

    function addStatusIcon(hexKey, icon) {
      const hex = boardHexes.find(h => getHexKey(h) === hexKey);
      if (!hex) return;
      const p = hexToPixel(hex);
      visualEffects.push({
        type: 'status',
        x: p.x,
        y: p.y - 35,
        text: icon,
        color: '#fff',
        startTime: Date.now(),
        duration: 500
      });
    }

    // Particle effects
    function addAttackParticles(x, y, color) {
      for (let i = 0; i < 8; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10 - 2,
          life: 1,
          color: color + Math.floor(Math.random()*128).toString(16).padStart(2,'0')  // Shade var
        });
      }
    }

    function addDeathExplosion(hexKey) {
      const p = hexToPixel(boardHexes.find(h => getHexKey(h) === hexKey));
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: p.x, y: p.y,
          vx: (Math.random() - 0.5) * 15,
          vy: (Math.random() - 0.5) * 15,
          life: 1,
          size: Math.random() * 4 + 2,
          color: '#ff4400'
        });
      }
    }

    function addAbilityParticles(x, y, color) {
      // Add particles for ability effects
      for (let i = 0; i < 12; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 12,
          vy: (Math.random() - 0.5) * 12 - 2,
          life: 1,
          color: color + Math.floor(Math.random()*128).toString(16).padStart(2,'0')
        });
      }
    }

    function addHealParticles(hexKey, amount) {
      const p = hexToPixel(boardHexes.find(h => getHexKey(h) === hexKey));
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: p.x, y: p.y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8 - 2,
          life: 1,
          color: '#0f0' + Math.floor(Math.random()*128).toString(16).padStart(2,'0')
        });
      }
    }

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const hexSize = 55; // Slightly smaller for 8 rows fit

    // Calculate proper centering for hex grid
    const totalWidth = 7 * hexSize * Math.sqrt(3); // Width of 7 columns
    const totalHeight = 8 * (3/2) * hexSize; // Height of 8 rows

    // Adjust origin to center the grid
    const origin = {
      x: (canvas.width - totalWidth) / 2 + hexSize * Math.sqrt(3) / 2,
      y: 120
    };

    const boardHexes = [];
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 7; col++) {
        boardHexes.push({ col, row });
      }
    }

    // === SURREAL DAL√ç-INSPIRED DREAMSCAPE ===
    let backgroundTime = 0;

    function drawBackground() {
      backgroundTime += 0.008;

      // === DREAMY SKY - Dal√≠ desert palette ===
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, '#1a1a35');      // Deep dream void
      skyGradient.addColorStop(0.2, '#2d2850');    // Purple haze
      skyGradient.addColorStop(0.4, '#4a3d6a');    // Twilight lavender
      skyGradient.addColorStop(0.55, '#8b6b5a');   // Dal√≠ desert tan
      skyGradient.addColorStop(0.7, '#c4956a');    // Warm sand
      skyGradient.addColorStop(0.85, '#7a5a50');   // Earth shadow
      skyGradient.addColorStop(1, '#3a2a35');      // Ground fade

      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // === WARPED HORIZON LINE (impossible perspective) ===
      ctx.strokeStyle = 'rgba(200, 150, 100, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let x = 0; x <= canvas.width; x += 5) {
        const wave = Math.sin(x * 0.008 + backgroundTime) * 30
                   + Math.sin(x * 0.015 - backgroundTime * 0.5) * 15;
        const y = canvas.height * 0.45 + wave;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // === MELTING CLOCK (signature Dal√≠ element) ===
      const drawMeltingClock = (cx, cy, size, melt, rotation) => {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);

        // Clock face (warped ellipse)
        ctx.beginPath();
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
          const warp = 1 + Math.sin(angle * 2 + backgroundTime) * melt * 0.3;
          const droop = angle > Math.PI * 0.3 && angle < Math.PI * 1.7
                       ? Math.sin((angle - Math.PI * 0.3) / 1.4 * Math.PI) * melt * size * 0.5 : 0;
          const rx = Math.cos(angle) * size * warp;
          const ry = Math.sin(angle) * size * 0.6 * warp + droop;
          if (angle === 0) ctx.moveTo(rx, ry);
          else ctx.lineTo(rx, ry);
        }
        ctx.closePath();

        const clockGrad = ctx.createRadialGradient(0, 0, 0, 0, size * 0.3, size);
        clockGrad.addColorStop(0, 'rgba(255, 250, 230, 0.9)');
        clockGrad.addColorStop(0.7, 'rgba(220, 200, 170, 0.8)');
        clockGrad.addColorStop(1, 'rgba(180, 150, 120, 0.6)');
        ctx.fillStyle = clockGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(100, 80, 60, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Clock hands (also melting)
        const hourAngle = backgroundTime * 0.1;
        const minAngle = backgroundTime * 0.5;

        ctx.strokeStyle = 'rgba(60, 40, 30, 0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const hx = Math.sin(hourAngle) * size * 0.4;
        const hy = -Math.cos(hourAngle) * size * 0.3 + Math.sin(hourAngle + 1) * melt * 10;
        ctx.quadraticCurveTo(hx * 0.5, hy * 0.5 + melt * 5, hx, hy);
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const mx = Math.sin(minAngle) * size * 0.6;
        const my = -Math.cos(minAngle) * size * 0.4 + Math.sin(minAngle + 2) * melt * 15;
        ctx.quadraticCurveTo(mx * 0.5, my * 0.5 + melt * 8, mx, my);
        ctx.stroke();

        ctx.restore();
      };

      // Place melting clocks
      drawMeltingClock(80, canvas.height * 0.35, 45, 0.8, -0.3);
      drawMeltingClock(canvas.width - 100, canvas.height * 0.4, 35, 0.6, 0.2);
      drawMeltingClock(canvas.width * 0.15, canvas.height * 0.55, 25, 1.0, -0.5);

      // === FLOATING FISH (surreal cat dreams) ===
      const drawFloatingFish = (x, y, size, phase) => {
        const bobY = y + Math.sin(backgroundTime * 1.5 + phase) * 15;
        const wobble = Math.sin(backgroundTime * 2 + phase) * 0.1;

        ctx.save();
        ctx.translate(x, bobY);
        ctx.rotate(wobble);
        ctx.globalAlpha = 0.6;

        // Fish body
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.quadraticCurveTo(size * 0.3, -size * 0.4, -size * 0.5, 0);
        ctx.quadraticCurveTo(size * 0.3, size * 0.4, size, 0);
        ctx.fillStyle = `hsl(${200 + phase * 20}, 60%, 70%)`;
        ctx.fill();

        // Tail
        ctx.beginPath();
        ctx.moveTo(-size * 0.5, 0);
        ctx.lineTo(-size, -size * 0.3);
        ctx.lineTo(-size, size * 0.3);
        ctx.closePath();
        ctx.fill();

        // Eye
        ctx.beginPath();
        ctx.arc(size * 0.5, -size * 0.1, size * 0.12, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fill();

        ctx.restore();
      };

      // Floating fish scattered around
      drawFloatingFish(150, canvas.height * 0.25, 20, 0);
      drawFloatingFish(canvas.width - 180, canvas.height * 0.3, 25, 2);
      drawFloatingFish(canvas.width * 0.5 - 200, canvas.height * 0.2, 15, 4);
      drawFloatingFish(canvas.width * 0.7, canvas.height * 0.15, 18, 1);

      // === IMPOSSIBLE COLUMNS (perspective tricks) ===
      const drawImpossibleColumn = (x, baseY, height, width) => {
        const twist = Math.sin(backgroundTime * 0.5) * 0.1;

        // Column with impossible twist
        ctx.beginPath();
        ctx.moveTo(x - width/2, baseY);
        ctx.lineTo(x - width/2 + twist * 30, baseY - height * 0.5);
        ctx.lineTo(x + width/2 + twist * 30, baseY - height * 0.5);
        ctx.lineTo(x + width/2, baseY);
        ctx.closePath();

        const colGrad = ctx.createLinearGradient(x - width, baseY - height, x + width, baseY);
        colGrad.addColorStop(0, 'rgba(180, 160, 140, 0.4)');
        colGrad.addColorStop(0.5, 'rgba(220, 200, 180, 0.5)');
        colGrad.addColorStop(1, 'rgba(160, 140, 120, 0.4)');
        ctx.fillStyle = colGrad;
        ctx.fill();

        // Upper part (twisted other way)
        ctx.beginPath();
        ctx.moveTo(x - width/2 + twist * 30, baseY - height * 0.5);
        ctx.lineTo(x - width/2 - twist * 20, baseY - height);
        ctx.lineTo(x + width/2 - twist * 20, baseY - height);
        ctx.lineTo(x + width/2 + twist * 30, baseY - height * 0.5);
        ctx.closePath();
        ctx.fillStyle = 'rgba(200, 180, 160, 0.35)';
        ctx.fill();

        // Capital (top decoration)
        ctx.beginPath();
        ctx.ellipse(x, baseY - height, width * 0.8, width * 0.3, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(230, 210, 190, 0.5)';
        ctx.fill();
      };

      drawImpossibleColumn(60, canvas.height * 0.75, 180, 25);
      drawImpossibleColumn(canvas.width - 70, canvas.height * 0.7, 150, 20);

      // === ELONGATED SHADOWS (Dal√≠ elephants style, but cat-ified) ===
      const drawElongatedCatShadow = (x, baseY, legHeight) => {
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#2a1a20';

        // Super long spindly legs
        for (let i = 0; i < 4; i++) {
          const legX = x + (i - 1.5) * 15;
          const sway = Math.sin(backgroundTime + i) * 5;
          ctx.beginPath();
          ctx.moveTo(legX, baseY);
          ctx.quadraticCurveTo(legX + sway, baseY - legHeight * 0.5, legX + sway * 0.5, baseY - legHeight);
          ctx.lineTo(legX + 3 + sway * 0.5, baseY - legHeight);
          ctx.quadraticCurveTo(legX + 3 + sway, baseY - legHeight * 0.5, legX + 3, baseY);
          ctx.fill();
        }

        // Tiny cat body at top
        const bodyY = baseY - legHeight;
        ctx.beginPath();
        ctx.ellipse(x, bodyY, 20, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // Cat head
        ctx.beginPath();
        ctx.arc(x + 15, bodyY - 5, 8, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.beginPath();
        ctx.moveTo(x + 10, bodyY - 10);
        ctx.lineTo(x + 13, bodyY - 20);
        ctx.lineTo(x + 18, bodyY - 12);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + 18, bodyY - 12);
        ctx.lineTo(x + 22, bodyY - 20);
        ctx.lineTo(x + 24, bodyY - 8);
        ctx.fill();

        ctx.globalAlpha = 1;
      };

      drawElongatedCatShadow(200, canvas.height * 0.85, 200);
      drawElongatedCatShadow(canvas.width - 220, canvas.height * 0.82, 170);

      // === FLOATING GEOMETRIC SHAPES ===
      const drawFloatingShape = (x, y, size, sides, phase) => {
        const floatY = y + Math.sin(backgroundTime + phase) * 20;
        const rot = backgroundTime * 0.3 + phase;

        ctx.save();
        ctx.translate(x, floatY);
        ctx.rotate(rot);
        ctx.globalAlpha = 0.25;

        ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
          const angle = (i / sides) * Math.PI * 2;
          const px = Math.cos(angle) * size;
          const py = Math.sin(angle) * size;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();

        ctx.fillStyle = `hsl(${(phase * 60 + backgroundTime * 20) % 360}, 40%, 60%)`;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      };

      drawFloatingShape(canvas.width * 0.2, canvas.height * 0.15, 30, 3, 0);
      drawFloatingShape(canvas.width * 0.8, canvas.height * 0.2, 25, 5, 2);
      drawFloatingShape(canvas.width * 0.1, canvas.height * 0.45, 20, 4, 4);
      drawFloatingShape(canvas.width * 0.9, canvas.height * 0.5, 22, 6, 1);

      // === WARPED CHECKERBOARD FLOOR (receding into infinity) ===
      ctx.globalAlpha = 0.15;
      const horizonY = canvas.height * 0.55;
      const floorBottom = canvas.height;

      for (let row = 0; row < 12; row++) {
        const rowProgress = row / 12;
        const y = horizonY + (floorBottom - horizonY) * Math.pow(rowProgress, 0.7);
        const nextY = horizonY + (floorBottom - horizonY) * Math.pow((row + 1) / 12, 0.7);
        const perspectiveScale = 0.1 + rowProgress * 0.9;
        const tileWidth = 80 * perspectiveScale;
        const xOffset = canvas.width / 2 + Math.sin(backgroundTime + row * 0.3) * 20 * (1 - rowProgress);

        for (let col = -10; col < 10; col++) {
          const x = xOffset + col * tileWidth;
          const warp = Math.sin(col * 0.5 + row * 0.3 + backgroundTime) * 5 * perspectiveScale;

          if ((row + col) % 2 === 0) {
            ctx.fillStyle = 'rgba(60, 40, 50, 0.5)';
          } else {
            ctx.fillStyle = 'rgba(100, 80, 70, 0.4)';
          }

          ctx.beginPath();
          ctx.moveTo(x + warp, y);
          ctx.lineTo(x + tileWidth + warp, y);
          ctx.lineTo(x + tileWidth - warp * 0.5, nextY);
          ctx.lineTo(x - warp * 0.5, nextY);
          ctx.closePath();
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;

      // === DISTANT SURREAL ARCH ===
      ctx.globalAlpha = 0.3;
      const archX = canvas.width * 0.5;
      const archY = canvas.height * 0.35;
      const archWidth = 120;
      const archHeight = 100;

      // Arch opening
      ctx.beginPath();
      ctx.moveTo(archX - archWidth/2, archY + archHeight);
      ctx.lineTo(archX - archWidth/2, archY);
      ctx.quadraticCurveTo(archX, archY - archHeight * 0.5, archX + archWidth/2, archY);
      ctx.lineTo(archX + archWidth/2, archY + archHeight);
      ctx.lineTo(archX + archWidth/2 - 15, archY + archHeight);
      ctx.lineTo(archX + archWidth/2 - 15, archY + 10);
      ctx.quadraticCurveTo(archX, archY - archHeight * 0.3, archX - archWidth/2 + 15, archY + 10);
      ctx.lineTo(archX - archWidth/2 + 15, archY + archHeight);
      ctx.closePath();

      const archGrad = ctx.createLinearGradient(archX - archWidth, archY, archX + archWidth, archY + archHeight);
      archGrad.addColorStop(0, 'rgba(200, 180, 160, 0.8)');
      archGrad.addColorStop(1, 'rgba(150, 130, 110, 0.6)');
      ctx.fillStyle = archGrad;
      ctx.fill();

      // Sky through arch (different color)
      ctx.beginPath();
      ctx.moveTo(archX - archWidth/2 + 15, archY + archHeight);
      ctx.lineTo(archX - archWidth/2 + 15, archY + 10);
      ctx.quadraticCurveTo(archX, archY - archHeight * 0.3, archX + archWidth/2 - 15, archY + 10);
      ctx.lineTo(archX + archWidth/2 - 15, archY + archHeight);
      ctx.closePath();
      ctx.fillStyle = 'rgba(255, 200, 150, 0.4)';
      ctx.fill();

      ctx.globalAlpha = 1;

      // === ETHEREAL GLOW ===
      const glowX = canvas.width * 0.3;
      const glowY = canvas.height * 0.4;
      const glowGrad = ctx.createRadialGradient(glowX, glowY, 0, glowX, glowY, 250);
      glowGrad.addColorStop(0, 'rgba(255, 220, 180, 0.2)');
      glowGrad.addColorStop(0.5, 'rgba(255, 180, 120, 0.1)');
      glowGrad.addColorStop(1, 'rgba(200, 150, 100, 0)');
      ctx.fillStyle = glowGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // === SUBTLE VIGNETTE ===
      const vignetteGrad = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, canvas.height * 0.3,
        canvas.width/2, canvas.height/2, canvas.height
      );
      vignetteGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignetteGrad.addColorStop(1, 'rgba(20, 10, 30, 0.4)');
      ctx.fillStyle = vignetteGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Helper function to shade colors
    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.max(0, Math.min(255, (num >> 16) + amt));
      const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + amt));
      const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
      return `rgb(${R},${G},${B})`;
    }

    const playerRows = [4, 5, 6, 7];
    const enemyRows = [0, 1, 2, 3];

    function getHexKey(hex) {
      return `${hex.col},${hex.row}`;
    }

    function hexToPixel(hex) {
      const x = hexSize * Math.sqrt(3) * (hex.col + 0.5 * (hex.row & 1));
      const y = hexSize * (3/2) * hex.row;
      return { x: origin.x + x - 3 * hexSize * Math.sqrt(3) / 2, y: origin.y + y };
    }

    function pixelToHex(px, py) {
      const x = (px - origin.x + 3 * hexSize * Math.sqrt(3) / 2) / (hexSize * Math.sqrt(3));
      const y = (py - origin.y) / (hexSize * 3/2);
      const row = Math.round(y);
      const col = Math.round(x - 0.5 * (row & 1));
      return { col, row };
    }

    function getNearestHex(raw) {
      const col = Math.round(raw.col);
      const row = Math.round(raw.row);
      return boardHexes.find(h => h.col === col && h.row === row) || null;
    }

    function drawHexWithShadow(cx, cy, fill, stroke = '#555') {
      // Draw shadow first
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 3) * i - Math.PI / 2;
        ctx.lineTo(cx + hexSize * Math.cos(ang) + 2, cy + hexSize * Math.sin(ang) + 2);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fill();

      // Draw hex with 3D effect
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 3) * i - Math.PI / 2;
        ctx.lineTo(cx + hexSize * Math.cos(ang), cy + hexSize * Math.sin(ang));
      }
      ctx.closePath();

      // Add gradient for 3D effect
      const hexGradient = ctx.createRadialGradient(
        cx, cy, 0,
        cx, cy, hexSize
      );
      if (fill === '#1e2a38' || fill === '#2e1a1a') {
        // Dark hexes get a subtle gradient
        hexGradient.addColorStop(0, '#2a3a4a');
        hexGradient.addColorStop(1, fill);
      } else {
        // Lighter hexes get a more pronounced 3D effect
        hexGradient.addColorStop(0, '#ffffff');
        hexGradient.addColorStop(0.7, fill);
        hexGradient.addColorStop(1, '#333333');
      }

      ctx.fillStyle = hexGradient;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawUnitWithShadow(cx, cy, unit, stars = 1, combatUnitRef = null) {
      // Try to draw using sprite system first
      if (drawUnitSprite(ctx, cx, cy, unit, stars, combatUnitRef)) {
        return; // Successfully drew sprite
      }

      // === FALLBACK: Original emoji/image rendering ===

      // Draw shadow
      ctx.beginPath();
      ctx.arc(cx + 3, cy + 3, hexSize * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fill();

      // Star-based glow colors
      const glowColors = {
        1: unit.color,
        2: '#4af',
        3: '#f4a'
      };

      // Draw unit with 3D effect using PNG assets
      // Create a mapping from unit identifiers to image file names
      const unitImageMap = {
        'alley_tabby_thug': 'alley_tabby_thug.png',
        'alley_ginger_rogue': 'alley_ginger_rogue.png',
        'alley_tuxedo_con': 'alley_tuxedo_con.png',
        'alley_street_yowler': 'alley_street_yowler.png',
        'alley_dumpster_king': 'alley_dumpster_king.png',
        'alley_feral_boss': 'alley_feral_boss.png',
        'persian_princess': 'persian_princess.png',
        'persian_pampered': 'persian_pampered.png',
        'persian_groomer': 'persian_groomer.png',
        'persian_snob': 'persian_snob.png',
        'persian_himalayan': 'persian_himalayan.png',
        'persian_emperor': 'persian_emperor.png',
        'siamese_screamer': 'siamese_screamer.png',
        'siamese_chatterbox': 'siamese_chatterbox.png',
        'siamese_soprano': 'siamese_soprano.png',
        'siamese_gossip': 'siamese_gossip.png',
        'siamese_opera': 'siamese_opera.png',
        'siamese_conductor': 'siamese_conductor.png',
        'mainecoon_titan': 'mainecoon_titan.png',
        'mainecoon_cub': 'mainecoon_cub.png',
        'mainecoon_guardian': 'mainecoon_guardian.png',
        'mainecoon_brawler': 'mainecoon_brawler.png',
        'mainecoon_elder': 'mainecoon_elder.png',
        'mainecoon_alpha': 'mainecoon_alpha.png',
        'bengal_stalker': 'bengal_stalker.png',
        'bengal_kitten': 'bengal_kitten.png',
        'bengal_hunter': 'bengal_hunter.png',
        'bengal_assassin': 'bengal_assassin.png',
        'bengal_pack_leader': 'bengal_pack_leader.png',
        'bengal_apex': 'bengal_apex.png',
        'sphynx_menace': 'sphynx_menace.png',
        'sphynx_creeper': 'sphynx_creeper.png',
        'sphynx_warmer': 'sphynx_warmer.png',
        'sphynx_cultist': 'sphynx_cultist.png',
        'sphynx_oracle': 'sphynx_oracle.png',
        'sphynx_overlord': 'sphynx_overlord.png',
        'scottish_gambler': 'scottish_gambler.png',
        'scottish_lucky': 'scottish_lucky.png',
        'scottish_dealer': 'scottish_dealer.png',
        'scottish_bettor': 'scottish_bettor.png',
        'scottish_fortune': 'scottish_fortune.png',
        'scottish_jackpot': 'scottish_jackpot.png',
        'ragdoll_faker': 'ragdoll_faker.png',
        'ragdoll_lazy': 'ragdoll_lazy.png',
        'ragdoll_flopper': 'ragdoll_flopper.png',
        'ragdoll_dreamer': 'ragdoll_dreamer.png',
        'ragdoll_therapist': 'ragdoll_therapist.png',
        'ragdoll_zen': 'ragdoll_zen.png'
      };

      // Get unit key for animation lookup
      const unitKey = unit.name.toLowerCase().replace(/\s+/g, '_');

      // IDLE SWAY (subtle bob for all units)
      const swayOffset = Math.sin(animationFrame * 0.1 + parseInt(unitKey)) * 2;
      const swayX = cx + swayOffset;
      const swayY = cy + Math.abs(Math.cos(animationFrame * 0.08)) * 1;

      // ATTACK PULSE / ABILITY GLOW
      let pulseScale = 1;
      let glowColor = unit.color;
      if (unitAnimations[unitKey]) {
        const anim = unitAnimations[unitKey];
        const progress = (Date.now() - anim.startTime) / ANIM_DURATION;
        if (progress < 1) {
          pulseScale = 1 + Math.sin(progress * Math.PI) * 0.3;  // Scale pop
          glowColor = `hsl(${parseInt(unit.color.slice(1,7),16) % 360}, 100%, 60%)`;  // Brighten
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 20 * (1 - progress);
        } else {
          delete unitAnimations[unitKey];  // End anim
        }
      }

      // Draw unit image if available
      if (unitImageMap[unitKey] && unitImages[unitKey]) {
        const img = unitImages[unitKey];
        // Draw image with proper scaling and animation
        ctx.save();
        ctx.translate(swayX, swayY);
        ctx.scale(pulseScale, pulseScale);
        ctx.drawImage(img, cx - hexSize * 0.35, cy - hexSize * 0.35, hexSize * 0.7, hexSize * 0.7);
        ctx.restore();
      } else {
        // Fallback to emoji if image not found
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(unit.icon, cx, cy);
      }

      // Add glow effect based on star level
      ctx.shadowColor = glowColors[stars] || unit.color;
      ctx.shadowBlur = stars === 1 ? 15 : stars === 2 ? 25 : 35;

      if (unitImageMap[unitKey] && unitImages[unitKey]) {
        // Redraw image with glow effect and animation
        ctx.save();
        ctx.translate(swayX, swayY);
        ctx.scale(pulseScale, pulseScale);
        const scale = hexSize * 0.7 / 64;
        ctx.drawImage(unitImages[unitKey], cx - hexSize * 0.35, cy - hexSize * 0.35, hexSize * 0.7, hexSize * 0.7);
        ctx.restore();
      } else {
        // Fallback to emoji with glow
        ctx.fillText(unit.icon, cx, cy);
      }
      ctx.shadowBlur = 0;

      // Draw unit border for 3D effect (color based on stars)
      const borderColors = {
        1: 'rgba(255, 255, 255, 0.7)',
        2: 'rgba(68, 170, 255, 0.9)',
        3: 'rgba(255, 68, 170, 0.9)'
      };
      ctx.strokeStyle = borderColors[stars];
      ctx.lineWidth = stars === 1 ? 2 : stars === 2 ? 3 : 4;
      ctx.beginPath();
      ctx.arc(cx, cy, hexSize * 0.4, 0, Math.PI * 2);
      ctx.stroke();

      // Draw star indicators below unit
      ctx.font = '10px Arial';
      ctx.fillStyle = stars === 1 ? '#ffd700' : stars === 2 ? '#4af' : '#f4a';
      ctx.fillText('‚≠ê'.repeat(stars), cx, cy + 28);

      // Draw faction label
      ctx.font = '10px Arial';
      ctx.fillStyle = '#aaa';
      ctx.fillText(unit.faction, cx, cy + 40);
    }

    function drawHex(cx, cy, fill, stroke = '#555') {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 3) * i - Math.PI / 2;
        ctx.lineTo(cx + hexSize * Math.cos(ang), cy + hexSize * Math.sin(ang));
      }
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // FIXED: Proper odd-r offset to cube distance
    function hexDistance(key1, key2) {
      const [c1, r1] = key1.split(',').map(Number);
      const [c2, r2] = key2.split(',').map(Number);
      const x1 = c1 - Math.floor(r1 / 2);
      const z1 = r1;
      const y1 = -x1 - z1;
      const x2 = c2 - Math.floor(r2 / 2);
      const z2 = r2;
      const y2 = -x2 - z2;
      return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
    }

    function renderBoard() {
      // Increment animation frame
      animationFrame++;

      // Update and draw particles
      particles = particles.filter(part => {
        part.x += part.vx;
        part.y += part.vy;
        part.vy += 0.2;  // Gravity
        part.life -= 0.03;
        return part.life > 0;
      });

      // Draw 3D background
      drawBackground();

      boardHexes.forEach(hex => {
        const p = hexToPixel(hex);
        const key = getHexKey(hex);
        const isPlayer = playerRows.includes(hex.row);

        // Get unit data (new format: {id, stars} or old format: string)
        let unitData = playerBoard[key] || enemyBoard[key];
        let unitId = null;
        let stars = 1;

        if (unitData) {
          if (typeof unitData === 'object') {
            unitId = unitData.id;
            stars = unitData.stars || 1;
          } else {
            unitId = unitData; // Old format compatibility
          }
        }

        let fill = isPlayer ? '#1e2a38' : '#2e1a1a';
        let stroke = '#555';

        if (unitId) {
          fill = unitsData[unitId].color;
          stroke = '#ddd';
          // Star level border colors
          if (stars === 2) stroke = '#4af';
          if (stars === 3) stroke = '#f4a';
        }

        const isDragging = draggedUnit && (draggedUnit.fromBoard || draggedUnit.fromBench) && draggedUnit.oldKey === key;
        if (isDragging) {
          fill = isPlayer ? '#1e2a38' : '#2e1a1a';
          stroke = '#555';
        }

        // Draw hex with 3D shadow effect
        drawHexWithShadow(p.x, p.y, fill, stroke);

        // Draw particles
        particles.forEach(part => {
          ctx.save();
          ctx.globalAlpha = part.life;
          ctx.fillStyle = part.color;
          ctx.beginPath();
          ctx.arc(part.x, part.y, part.size * part.life, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        if (unitId && !isDragging) {
          const u = unitsData[unitId];
          // Find combat unit reference if in combat (for sprite animation state)
          let combatUnitRef = null;
          if (combatState === 'combat') {
            combatUnitRef = combatUnits.find(cu => cu.hexKey === key && cu.hp > 0);
          }
          // Draw unit with 3D shadow effect
          drawUnitWithShadow(p.x, p.y, u, stars, combatUnitRef);
        }
      });

      if (highlightHex) {
        const p = hexToPixel(highlightHex);
        ctx.globalAlpha = 0.4;
        drawHex(p.x, p.y, '#33ff66', '#33ff66');
        ctx.globalAlpha = 1;
      }

      // Combat visuals (health/mana bars)
      if (combatState === 'combat' || combatState === 'resolution') {
        combatUnits.forEach(unit => {
          if (unit.hp <= 0) return;
          const hex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
          if (!hex) return;
          const p = hexToPixel(hex);

          // Status effect indicators with shadows
          if (hasStatus && hasStatus(unit, STATUS?.STUN)) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(p.x + 2, p.y + 2, hexSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, hexSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
          }
          if (hasStatus && hasStatus(unit, STATUS?.POISON)) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(p.x + 2, p.y + 2, hexSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, hexSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
          if (hasStatus && hasStatus(unit, STATUS?.SHIELD)) {
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x + 2, p.y + 2, hexSize * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x, p.y, hexSize * 0.7, 0, Math.PI * 2);
            ctx.stroke();
          }

          // HP bar with 3D effect
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(p.x - 24, p.y - 44, 48, 7);
          ctx.fillStyle = '#333';
          ctx.fillRect(p.x - 22, p.y - 42, 44, 5);
          const hpPct = Math.max(0, unit.hp / unit.maxHp);
          ctx.fillStyle = hpPct > 0.5 ? 'rgba(0, 255, 0, 0.8)' : hpPct > 0.25 ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
          ctx.fillRect(p.x - 22, p.y - 42, 44 * hpPct, 5);

          // Mana bar with 3D effect
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(p.x - 24, p.y - 37, 48, 6);
          ctx.fillStyle = '#003';
          ctx.fillRect(p.x - 22, p.y - 35, 44, 4);
          const manaPct = unit.mana / unit.maxMana;
          ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';
          ctx.fillRect(p.x - 22, p.y - 35, 44 * manaPct, 4);
        });

        // Draw visual effects
        const now = Date.now();
        visualEffects = visualEffects.filter(fx => now - fx.startTime < fx.duration);

        visualEffects.forEach(fx => {
          const progress = (now - fx.startTime) / fx.duration;
          const alpha = 1 - progress;

          if (fx.type === 'damage' || fx.type === 'heal') {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = fx.color;
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';

            // Add glow effect to damage numbers
            if (fx.type === 'damage') {
              ctx.shadowColor = fx.color;
              ctx.shadowBlur = 15;
            } else if (fx.type === 'heal') {
              ctx.shadowColor = '#0f0';
              ctx.shadowBlur = 15;
            }
            ctx.fillText(fx.text, fx.x, fx.y - progress * 30);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'attackLine') {
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = fx.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(fx.x, fx.y);
            ctx.lineTo(fx.x2, fx.y2);
            ctx.stroke();

            // Add glow to attack lines
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 5;
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'status') {
            ctx.globalAlpha = alpha;
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';

            // Add glow effect to status icons
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 12;
            ctx.fillText(fx.text, fx.x, fx.y - progress * 15);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'attackPulse') {
            // Attack pulse animation
            ctx.globalAlpha = alpha * 0.7;

            // Create a multi-layered pulse effect
            const layers = 3;
            for (let i = 0; i < layers; i++) {
              const layerProgress = Math.min(1, progress + (i * 0.2));
              const layerRadius = fx.radius * (1 - layerProgress);

              if (layerProgress < 1) {
                ctx.strokeStyle = fx.color;
                ctx.lineWidth = 2 + (i * 0.5);
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, layerRadius, 0, Math.PI * 2);
                ctx.stroke();
              }
            }

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 10;
            ctx.strokeStyle = fx.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, fx.radius * (1 - progress), 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
          } else if (fx.type === 'deathEffect') {
            // Death explosion animation
            ctx.globalAlpha = alpha;

            // Create a multi-layered explosion effect
            const layers = 3;
            for (let i = 0; i < layers; i++) {
              const layerProgress = Math.min(1, progress + (i * 0.2));
              const layerRadius = fx.radius * layerProgress;

              if (layerProgress < 1) {
                ctx.fillStyle = `rgba(${parseInt(fx.color.slice(1, 3), 16)}, ${parseInt(fx.color.slice(3, 5), 16)}, ${parseInt(fx.color.slice(5, 7), 16)}, ${0.8 - (i * 0.2)})`;
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, layerRadius, 0, Math.PI * 2);
                ctx.fill();
              }
            }

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 20;
            ctx.fillStyle = fx.color;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, fx.radius * progress * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
          } else if (fx.type === 'abilityEffect') {
            // Ability casting circle animation
            ctx.globalAlpha = alpha * 0.5;

            // Create a multi-layered circle effect
            const layers = 4;
            for (let i = 0; i < layers; i++) {
              const layerProgress = Math.min(1, progress + (i * 0.15));
              const layerRadius = fx.radius * (1 - layerProgress);

              if (layerProgress < 1) {
                ctx.strokeStyle = fx.color;
                ctx.lineWidth = 1 + (i * 0.5);
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, layerRadius, 0, Math.PI * 2);
                ctx.stroke();
              }
            }

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 15;
            ctx.strokeStyle = fx.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, fx.radius * (1 - progress), 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
          } else if (fx.type === 'hitEffect') {
            // Hit effect animation
            ctx.globalAlpha = alpha * 0.8;
            ctx.fillStyle = fx.color;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, 15 * (1 - progress), 0, Math.PI * 2);
            ctx.fill();

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, 15 * (1 - progress), 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'unitScale') {
            // Unit scaling animation
            const scale = 1 + (0.5 * progress);
            ctx.globalAlpha = alpha;
            // This would be handled by drawing the unit with scaling
            ctx.globalAlpha = 1;
          }
        });
      }

      // Draw round banner
      if (roundBanner) {
        const now = Date.now();
        const elapsed = now - roundBanner.startTime;
        if (elapsed < roundBanner.duration) {
          const progress = elapsed / roundBanner.duration;
          // Fade in for first 20%, hold, fade out for last 20%
          let alpha = 1;
          if (progress < 0.2) alpha = progress / 0.2;
          else if (progress > 0.8) alpha = (1 - progress) / 0.2;

          ctx.globalAlpha = alpha;

          // Dark banner background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);

          // Add glow effect to banner
          ctx.shadowColor = roundBanner.color || '#fff';
          ctx.shadowBlur = 15;

          // Banner text
          ctx.fillStyle = roundBanner.color || '#fff';
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(roundBanner.text, canvas.width / 2, canvas.height / 2);

          ctx.shadowBlur = 0;

          // Subtext if present
          if (roundBanner.subtext) {
            ctx.font = '24px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText(roundBanner.subtext, canvas.width / 2, canvas.height / 2 + 35);
          }

          ctx.globalAlpha = 1;
        } else {
          roundBanner = null;
        }
      }
    }

    function renderShop() {
      const shopEl = document.getElementById('shop');
      shopEl.innerHTML = '';
      shopUnits.forEach(id => {
        const u = unitsData[id];
        const synergy = factionSynergies[u.faction];
        const div = document.createElement('div');
        div.className = 'unit';
        div.draggable = true;
        div.style.borderColor = synergy?.color || '#777';
        div.innerHTML = `
          <div class="unit-icon">${u.icon}</div>
          <div class="unit-name">${u.name}</div>
          <div class="unit-cost">${u.cost}g</div>
          <div class="unit-faction" style="color: ${synergy?.color || '#aaa'}">${synergy?.icon || ''} ${u.faction}</div>
        `;
        div.addEventListener('dragstart', e => {
          draggedUnit = { fromShop: true, id, cost: u.cost };
          e.dataTransfer.setData('text/plain', id);
          hideTooltip();
        });
        div.addEventListener('mouseenter', e => {
          showTooltip(id, e.clientX, e.clientY);
        });
        div.addEventListener('mousemove', e => {
          if (tooltipVisible) {
            showTooltip(id, e.clientX, e.clientY);
          }
        });
        div.addEventListener('mouseleave', () => {
          hideTooltip();
        });
        shopEl.appendChild(div);
      });
    }

    // Get max units allowed based on player level (level 1 = 3 units, level 2 = 4, etc.)
    function getMaxUnits() {
      return playerLevel + 2;
    }

    // Get current unit count on board
    function getUnitCount() {
      return Object.keys(playerBoard).length;
    }

    // Check if we can place another unit
    function canPlaceUnit() {
      return getUnitCount() < getMaxUnits();
    }

    // ========== BENCH RENDERING ==========
    function renderBench() {
      const slots = document.querySelectorAll('.bench-slot');
      slots.forEach((slot, index) => {
        const unit = bench[index];
        slot.innerHTML = '';
        slot.classList.remove('occupied');

        if (unit) {
          const data = unitsData[unit.id];
          slot.classList.add('occupied');
          slot.style.borderColor = data.color;

          const starText = '‚≠ê'.repeat(unit.stars);
          slot.innerHTML = `
            <span class="bench-unit">${data.icon}</span>
            <span class="bench-unit-stars">${starText}</span>
            <span class="bench-unit-cost">${data.cost}</span>
          `;
        } else {
          slot.style.borderColor = '#444';
        }
      });
    }

    // Setup bench interactions
    function setupBenchEvents() {
      const slots = document.querySelectorAll('.bench-slot');
      const sellZone = document.getElementById('sell-zone');

      slots.forEach((slot, index) => {
        // Drag start from bench
        slot.addEventListener('mousedown', e => {
          const unit = bench[index];
          if (unit && combatState === 'idle') {
            draggedUnit = {
              fromBench: true,
              id: unit.id,
              stars: unit.stars,
              slotIndex: index,
              cost: unitsData[unit.id].cost
            };
            sellZone.classList.add('active');
            slot.style.opacity = '0.5';
          }
        });

        // Hover for tooltip
        slot.addEventListener('mouseenter', e => {
          const unit = bench[index];
          if (unit && !draggedUnit) {
            showTooltip(unit.id, e.clientX, e.clientY);
          }
        });

        slot.addEventListener('mousemove', e => {
          const unit = bench[index];
          if (unit && tooltipVisible && !draggedUnit) {
            showTooltip(unit.id, e.clientX, e.clientY);
          }
        });

        slot.addEventListener('mouseleave', () => {
          hideTooltip();
        });

        // Drop onto bench slot
        slot.addEventListener('dragover', e => {
          e.preventDefault();
          slot.classList.add('drag-over');
        });

        slot.addEventListener('dragleave', () => {
          slot.classList.remove('drag-over');
        });

        slot.addEventListener('drop', e => {
          e.preventDefault();
          slot.classList.remove('drag-over');

          if (draggedUnit?.fromShop && bench[index] === null) {
            // Buy from shop to bench
            if (gold >= draggedUnit.cost) {
              if (tryAddUnit(draggedUnit.id)) {
                gold -= draggedUnit.cost;
                // Remove from shop
                const shopIndex = shopUnits.indexOf(draggedUnit.id);
                if (shopIndex > -1) shopUnits[shopIndex] = rollShopUnit();
                renderShop();
                renderBench();
                updateUI();
              }
            }
          }
          draggedUnit = null;
        });
      });

      // Sell zone events
      sellZone.addEventListener('dragover', e => {
        e.preventDefault();
        sellZone.classList.add('drag-over');
      });

      sellZone.addEventListener('dragleave', () => {
        sellZone.classList.remove('drag-over');
      });

      sellZone.addEventListener('drop', e => {
        e.preventDefault();
        sellZone.classList.remove('drag-over');
        sellZone.classList.remove('active');

        if (draggedUnit) {
          const sellValue = getSellValue(draggedUnit.cost, draggedUnit.stars || 1);
          gold += sellValue;

          if (draggedUnit.fromBench) {
            bench[draggedUnit.slotIndex] = null;
          } else if (draggedUnit.fromBoard) {
            delete playerBoard[draggedUnit.oldKey];
          }

          renderBench();
          renderBoard();
          renderSynergies();
          updateUI();
        }
        draggedUnit = null;
      });

      // Global mouseup to handle bench drag end
      document.addEventListener('mouseup', e => {
        if (draggedUnit?.fromBench) {
          const slot = document.querySelector(`.bench-slot[data-slot="${draggedUnit.slotIndex}"]`);
          if (slot) slot.style.opacity = '1';

          // Check if dropped on board
          const rect = canvas.getBoundingClientRect();
          if (e.clientX >= rect.left && e.clientX <= rect.right &&
              e.clientY >= rect.top && e.clientY <= rect.bottom) {
            const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
            const hex = getNearestHex(raw);

            if (hex && playerRows.includes(hex.row)) {
              const key = getHexKey(hex);
              const boardUnit = playerBoard[key];

              if (!boardUnit) {
                // Move from bench to empty board slot (if within cap)
                if (canPlaceUnit()) {
                  playerBoard[key] = { id: draggedUnit.id, stars: draggedUnit.stars };
                  bench[draggedUnit.slotIndex] = null;

                  // Check for merge on board
                  const matches = checkForMerge(draggedUnit.id, draggedUnit.stars);
                  if (matches) {
                    performMerge(matches, draggedUnit.id, draggedUnit.stars);
                  }
                }
              } else {
                // Swap bench unit with board unit
                playerBoard[key] = { id: draggedUnit.id, stars: draggedUnit.stars };
                bench[draggedUnit.slotIndex] = { id: boardUnit.id, stars: boardUnit.stars };

                // Check for merges after swap
                const boardMatches = checkForMerge(draggedUnit.id, draggedUnit.stars);
                if (boardMatches) {
                  performMerge(boardMatches, draggedUnit.id, draggedUnit.stars);
                }
                const benchMatches = checkForMerge(boardUnit.id, boardUnit.stars);
                if (benchMatches) {
                  performMerge(benchMatches, boardUnit.id, boardUnit.stars);
                }
              }
            }
          }

          // Check if dropped on another bench slot
          const benchSlots = document.querySelectorAll('.bench-slot');
          benchSlots.forEach((targetSlot, targetIndex) => {
            const slotRect = targetSlot.getBoundingClientRect();
            if (e.clientX >= slotRect.left && e.clientX <= slotRect.right &&
                e.clientY >= slotRect.top && e.clientY <= slotRect.bottom) {
              if (targetIndex !== draggedUnit.slotIndex) {
                // Swap or move
                const targetUnit = bench[targetIndex];
                bench[targetIndex] = bench[draggedUnit.slotIndex];
                bench[draggedUnit.slotIndex] = targetUnit;
              }
            }
          });

          sellZone.classList.remove('active');
          renderBench();
          renderBoard();
          renderSynergies();
          updateUI();
          draggedUnit = null;
        }
      });
    }

    function updateUI() {
      document.getElementById('round').textContent = currentRound;
      document.getElementById('gold').textContent = gold;
      document.getElementById('health').textContent = health;
      document.getElementById('level').textContent = playerLevel;
      const unitCapEl = document.getElementById('unitcap');
      unitCapEl.textContent = `${getUnitCount()}/${getMaxUnits()}`;
      // Color code: green if room, yellow if close, red if at cap
      const ratio = getUnitCount() / getMaxUnits();
      unitCapEl.style.color = ratio >= 1 ? '#f44' : ratio >= 0.8 ? '#ff0' : '#4f4';
      document.getElementById('reroll').disabled = gold < 2;
      const lvlCost = 4;  // Fixed 4 gold per level (TFT style)
      document.getElementById('levelup').textContent = `LEVEL UP (${lvlCost}g)`;
      document.getElementById('levelup').disabled = gold < lvlCost || playerLevel >= 9;
      document.getElementById('fight').disabled = combatState !== 'idle';

      // Sync human player state to GameState in multiplayer mode
      if (typeof GameState !== 'undefined' && GameState.mode === 'multiplayer') {
        const human = GameState.getHumanPlayer();
        if (human) {
          human.board = { ...playerBoard };
          human.bench = [...bench];
          human.gold = gold;
          human.level = playerLevel;
          human.health = health;
        }
      }
    }

    // Mouse/Drag events
    canvas.addEventListener('mousedown', e => {
      if (draggedUnit || combatState !== 'idle') return;
      const rect = canvas.getBoundingClientRect();
      const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
      const hex = getNearestHex(raw);
      if (hex && playerRows.includes(hex.row)) {
        const key = getHexKey(hex);
        const unit = playerBoard[key];
        if (unit) {
          draggedUnit = {
            fromBoard: true,
            id: unit.id,
            stars: unit.stars,
            oldKey: key,
            cost: unitsData[unit.id].cost
          };
          document.getElementById('sell-zone').classList.add('active');
          renderBoard();
        }
      }
    });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
      const hex = getNearestHex(raw);
      if (draggedUnit) {
        const targetKey = hex ? getHexKey(hex) : null;
        const isPlayerArea = hex && playerRows.includes(hex.row);

        let valid = false;
        if (isPlayerArea) {
          const targetUnit = playerBoard[getHexKey(hex)];
          const isSameSpot = getHexKey(hex) === draggedUnit.oldKey;

          if (draggedUnit.fromShop) {
            // Shop: can only drop on empty slots if within cap
            valid = !targetUnit && canPlaceUnit();
          } else if (draggedUnit.fromBoard) {
            // Board: can drop on empty or swap with another unit
            valid = !targetUnit || isSameSpot || (targetUnit && !isSameSpot);
          } else if (draggedUnit.fromBench) {
            // Bench: can drop on empty (if cap allows) or swap with board unit
            valid = (!targetUnit && canPlaceUnit()) || (targetUnit && true);
          }
        }

        highlightHex = valid ? hex : null;
        canvas.style.cursor = valid ? 'grab' : 'no-drop';
        hideTooltip(); // Hide tooltip while dragging
      } else {
        highlightHex = null;
        canvas.style.cursor = 'default';

        // Show tooltip for units on board
        if (hex && combatState === 'idle') {
          const key = getHexKey(hex);
          const unitData = playerBoard[key] || enemyBoard[key];
          // Handle both object format {id, stars} and legacy string format
          const unitId = unitData ? (typeof unitData === 'object' ? unitData.id : unitData) : null;
          if (unitId && unitId !== hoveredBoardUnit) {
            hoveredBoardUnit = unitId;
            showTooltip(unitId, e.clientX, e.clientY);
          } else if (unitId && tooltipVisible) {
            // Update position while hovering same unit
            showTooltip(unitId, e.clientX, e.clientY);
          } else if (!unitId) {
            hoveredBoardUnit = null;
            hideTooltip();
          }
        } else if (!hex) {
          hoveredBoardUnit = null;
          hideTooltip();
        }
      }
      renderBoard();
    });

    canvas.addEventListener('mouseup', e => {
      if (!draggedUnit || !draggedUnit.fromBoard) return;

      const sellZone = document.getElementById('sell-zone');
      const sellRect = sellZone.getBoundingClientRect();

      // Check if dropped on sell zone
      if (sellZone.classList.contains('active') &&
          e.clientX >= sellRect.left && e.clientX <= sellRect.right &&
          e.clientY >= sellRect.top && e.clientY <= sellRect.bottom) {
        // Sell the unit
        const sellValue = getSellValue(draggedUnit.cost, draggedUnit.stars);
        gold += sellValue;
        delete playerBoard[draggedUnit.oldKey];
        sellZone.classList.remove('active');
      } else {
        // Check if dropped on bench
        let droppedOnBench = false;
        const benchSlots = document.querySelectorAll('.bench-slot');
        benchSlots.forEach((slot, index) => {
          const slotRect = slot.getBoundingClientRect();
          if (e.clientX >= slotRect.left && e.clientX <= slotRect.right &&
              e.clientY >= slotRect.top && e.clientY <= slotRect.bottom) {
            droppedOnBench = true;
            const benchUnit = bench[index];

            if (benchUnit === null) {
              // Move from board to empty bench slot
              bench[index] = { id: draggedUnit.id, stars: draggedUnit.stars };
              delete playerBoard[draggedUnit.oldKey];
            } else {
              // Swap board unit with bench unit
              bench[index] = { id: draggedUnit.id, stars: draggedUnit.stars };
              playerBoard[draggedUnit.oldKey] = { id: benchUnit.id, stars: benchUnit.stars };

              // Check for merge after swap
              const matches = checkForMerge(benchUnit.id, benchUnit.stars);
              if (matches) {
                performMerge(matches, benchUnit.id, benchUnit.stars);
              }
            }
          }
        });

        if (!droppedOnBench) {
          // Board movement or swap
          const rect = canvas.getBoundingClientRect();
          const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
          const hex = getNearestHex(raw);
          if (hex && playerRows.includes(hex.row)) {
            const newKey = getHexKey(hex);
            if (newKey !== draggedUnit.oldKey) {
              const targetUnit = playerBoard[newKey];

              if (!targetUnit) {
                // Move to empty slot
                delete playerBoard[draggedUnit.oldKey];
                playerBoard[newKey] = { id: draggedUnit.id, stars: draggedUnit.stars };
              } else {
                // Swap with another board unit
                playerBoard[newKey] = { id: draggedUnit.id, stars: draggedUnit.stars };
                playerBoard[draggedUnit.oldKey] = { id: targetUnit.id, stars: targetUnit.stars };
              }

              // Check for merge
              const matches = checkForMerge(draggedUnit.id, draggedUnit.stars);
              if (matches) {
                performMerge(matches, draggedUnit.id, draggedUnit.stars);
              }
            }
          }
        }
        sellZone.classList.remove('active');
      }

      draggedUnit = null;
      highlightHex = null;
      canvas.style.cursor = 'default';
      renderBench();
      renderBoard();
      renderSynergies();
      updateUI();
    });

    canvas.addEventListener('mouseleave', () => {
      hoveredBoardUnit = null;
      hideTooltip();
    });

    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      if (!draggedUnit?.fromShop) return;

      if (gold >= draggedUnit.cost) {
        const rect = canvas.getBoundingClientRect();
        const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
        const hex = getNearestHex(raw);

        // Dropping directly on board (if space)
        if (hex && playerRows.includes(hex.row) && canPlaceUnit()) {
          const key = getHexKey(hex);
          if (!playerBoard[key]) {
            // First add to bench (for merge logic)
            if (tryAddUnit(draggedUnit.id)) {
              gold -= draggedUnit.cost;
              // Now move from bench to board
              const benchIdx = bench.findIndex(b => b && b.id === draggedUnit.id);
              if (benchIdx !== -1) {
                playerBoard[key] = bench[benchIdx];
                bench[benchIdx] = null;
                // Check for merge on board
                const matches = checkForMerge(draggedUnit.id, playerBoard[key].stars);
                if (matches) {
                  performMerge(matches, draggedUnit.id, playerBoard[key].stars);
                }
              }
              // Remove from shop
              const shopIndex = shopUnits.indexOf(draggedUnit.id);
              if (shopIndex > -1) shopUnits[shopIndex] = rollShopUnit();
              renderShop();
              renderBench();
              updateUI();
              renderSynergies();
            }
          }
        } else {
          // Dropping elsewhere - buy to bench
          if (tryAddUnit(draggedUnit.id)) {
            gold -= draggedUnit.cost;
            const shopIndex = shopUnits.indexOf(draggedUnit.id);
            if (shopIndex > -1) shopUnits[shopIndex] = rollShopUnit();
            renderShop();
            renderBench();
            updateUI();
          }
        }
      }
      draggedUnit = null;
      highlightHex = null;
      renderBoard();
    });

    // FIXED: Proper handlers
    document.getElementById('reroll').onclick = () => {
      if (gold >= 2) {
        gold -= 2;
        shopUnits = Array(5).fill().map(() => rollShopUnit());
        renderShop();
        updateUI();
        // Sync to multiplayer state
        if (GameState.mode === 'multiplayer') {
          const human = GameState.getHumanPlayer();
          human.gold = gold;
          human.shop = [...shopUnits];
        }
      }
    };

    document.getElementById('levelup').onclick = () => {
      const cost = 4;  // Fixed cost of 4 gold per level (TFT style)
      if (gold >= cost && playerLevel < 9) {
        gold -= cost;
        playerLevel++;
        renderSynergies(); // Update synergies (shows unit cap hint)
        updateUI();
        // Sync to multiplayer state
        if (GameState.mode === 'multiplayer') {
          const human = GameState.getHumanPlayer();
          human.gold = gold;
          human.level = playerLevel;
        }
      }
    };

    // ========== COMBAT SYSTEM ==========
    let combatState = 'idle'; // 'idle' | 'combat'
    let combatUnits = [];
    let combatLog = [];
    let lastCombatTime = 0;
    let combatStartTime = 0;
    const COMBAT_TICK_MS = 50;
    const MANA_TO_CAST = 100;

    // Status effect types
    const STATUS = {
      STUN: 'stun',
      SLOW: 'slow',
      POISON: 'poison',
      SILENCE: 'silence',
      SHIELD: 'shield'
    };

    function createCombatUnit(unitId, hexKey, isPlayer, synergyBonuses = null, stars = 1) {
      const data = unitsData[unitId];
      if (!data) return null;
      const stats = data.stats;
      const baseSpeed = stats.speed || 1.0;

      // Apply star level multiplier
      const starMult = STAR_MULTIPLIERS[stars] || 1.0;

      // Start with base stats (scaled by stars)
      let hp = Math.round(stats.hp * starMult);
      let attack = Math.round(stats.attack * starMult);
      let speed = baseSpeed;
      let range = stats.range || 1;
      let armor = 0;
      let critChance = 0;
      let critDamage = 150; // Base crit damage 150%
      let lifesteal = 0;
      let poisonOnHit = 0;
      let damageVsPoisoned = 0;
      let executeThreshold = 0;
      let damageAmp = 0;

      // Apply synergy bonuses for player units
      if (isPlayer && synergyBonuses) {
        const faction = data.faction;
        const bonus = synergyBonuses[faction];

        if (bonus) {
          // HP amplification
          if (bonus.hp_amp) {
            hp = Math.round(hp * (1 + bonus.hp_amp / 100));
          }
          // Attack amplification
          if (bonus.attack_amp) {
            attack = Math.round(attack * (1 + bonus.attack_amp / 100));
          }
          // Attack speed
          if (bonus.attack_speed) {
            speed = speed * (1 + bonus.attack_speed / 100);
          }
          // Range bonus
          if (bonus.range_bonus) {
            range += bonus.range_bonus;
          }
          // Armor
          if (bonus.armor) {
            armor += bonus.armor;
          }
          // Crit chance
          if (bonus.crit_chance) {
            critChance += bonus.crit_chance;
          }
          // Crit damage
          if (bonus.crit_damage) {
            critDamage += bonus.crit_damage;
          }
          // Lifesteal
          if (bonus.lifesteal) {
            lifesteal += bonus.lifesteal;
          }
          // Disease on hit (Sphynx)
          if (bonus.poison_on_hit) {
            poisonOnHit = bonus.poison_on_hit;
          }
          // Damage vs poisoned
          if (bonus.damage_vs_poisoned) {
            damageVsPoisoned = bonus.damage_vs_poisoned;
          }
          // Execute threshold
          if (bonus.execute_threshold) {
            executeThreshold = bonus.execute_threshold;
          }
          // Damage amplification
          if (bonus.damage_amp) {
            damageAmp = bonus.damage_amp;
          }
        }
      }

      return {
        id: unitId,
        hexKey,
        isPlayer,
        maxHp: hp,
        hp: hp,
        baseAttack: attack,
        attack: attack,
        baseSpeed: speed,
        speed: speed,
        range: range,
        armor: armor,
        mana: 0,
        maxMana: MANA_TO_CAST,
        faction: data.faction,
        ability: data.ability,
        lastActionTime: 0,
        lastMoveTime: 0,
        actionCooldown: 1000 / speed, // Attack cooldown based on speed
        moveCooldown: 600 / speed, // Move cooldown
        statusEffects: [], // {type, duration, value, startTime}
        attackedTargets: new Set(), // For "once per target" effects
        hasCast: false, // For once-per-combat abilities
        hasRevived: false, // For Ragdoll revive
        // Synergy combat bonuses
        critChance,
        critDamage,
        lifesteal,
        poisonOnHit,
        damageVsPoisoned,
        executeThreshold,
        damageAmp
      };
    }

    // Get neighbors of a hex (odd-r offset)
    function getHexNeighbors(hexKey) {
      const [col, row] = hexKey.split(',').map(Number);
      const isOddRow = row & 1;
      const directions = isOddRow
        ? [[1,0], [1,-1], [0,-1], [-1,0], [0,1], [1,1]]
        : [[1,0], [0,-1], [-1,-1], [-1,0], [-1,1], [0,1]];
      return directions
        .map(([dc, dr]) => ({ col: col + dc, row: row + dr }))
        .filter(h => h.col >= 0 && h.col < 7 && h.row >= 0 && h.row < 8)
        .map(h => getHexKey(h));
    }

    // Find path toward target (simple greedy)
    function findMoveToward(unit, target, units) {
      const neighbors = getHexNeighbors(unit.hexKey);
      const occupied = new Set(units.filter(u => u.hp > 0 && u !== unit).map(u => u.hexKey));

      let bestHex = null;
      let bestDist = hexDistance(unit.hexKey, target.hexKey);

      for (const hex of neighbors) {
        if (occupied.has(hex)) continue;
        const dist = hexDistance(hex, target.hexKey);
        if (dist < bestDist) {
          bestDist = dist;
          bestHex = hex;
        }
      }
      return bestHex;
    }

    function findNearestEnemy(unit, units) {
      let nearest = null;
      let minDist = Infinity;
      for (const other of units) {
        if (other.isPlayer === unit.isPlayer || other.hp <= 0) continue;
        const dist = hexDistance(unit.hexKey, other.hexKey);
        if (dist < minDist) {
          minDist = dist;
          nearest = other;
        }
      }
      return { target: nearest, distance: minDist };
    }

    function hasStatus(unit, type) {
      return unit.statusEffects.some(s => s.type === type);
    }

    function getStatusValue(unit, type) {
      const effect = unit.statusEffects.find(s => s.type === type);
      return effect ? effect.value : 0;
    }

    function applyStatus(unit, type, duration, value = 0) {
      // Remove existing of same type
      unit.statusEffects = unit.statusEffects.filter(s => s.type !== type);
      unit.statusEffects.push({ type, duration, value, startTime: Date.now() });

      const name = unitsData[unit.id].name;
      if (type === STATUS.STUN) combatLog.push(`${name} is STUNNED for ${(duration/1000).toFixed(1)}s!`);
      else if (type === STATUS.SLOW) combatLog.push(`${name} is SLOWED ${value}%!`);
      else if (type === STATUS.POISON) combatLog.push(`${name} is POISONED for ${value} dmg/sec!`);
      else if (type === STATUS.SHIELD) combatLog.push(`${name} gains ${value} SHIELD!`);
    }

    function updateStatusEffects(unit, deltaTime) {
      const now = Date.now();
      // Process poison damage
      const poison = unit.statusEffects.find(s => s.type === STATUS.POISON);
      if (poison) {
        const tickDamage = poison.value * (deltaTime / 1000);
        unit.hp -= tickDamage;
      }

      // Update speed based on slow
      const slow = unit.statusEffects.find(s => s.type === STATUS.SLOW);
      if (slow) {
        unit.speed = unit.baseSpeed * (1 - slow.value / 100);
        unit.actionCooldown = 1000 / unit.speed;
        unit.moveCooldown = 600 / unit.speed;
      } else {
        unit.speed = unit.baseSpeed;
        unit.actionCooldown = 1000 / unit.speed;
        unit.moveCooldown = 600 / unit.speed;
      }

      // Remove expired effects
      unit.statusEffects = unit.statusEffects.filter(s => now - s.startTime < s.duration);
    }

    function calculateDamage(attacker, defender, baseDamage) {
      // Armor reduces damage: damage * 100 / (100 + armor)
      const armorReduction = 100 / (100 + defender.armor);
      let damage = baseDamage * armorReduction;

      // Shield absorbs damage
      const shield = defender.statusEffects.find(s => s.type === STATUS.SHIELD);
      if (shield) {
        if (shield.value >= damage) {
          shield.value -= damage;
          return 0;
        } else {
          damage -= shield.value;
          defender.statusEffects = defender.statusEffects.filter(s => s.type !== STATUS.SHIELD);
        }
      }

      // Persian synergy: Damage reflect
      if (defender.isPlayer) {
        const persianSynergy = activeCombatSynergies['Persian'];
        if (persianSynergy?.damage_reflect && defender.faction === 'Persian') {
          const reflectDamage = damage * persianSynergy.damage_reflect / 100;
          attacker.hp -= reflectDamage;
          if (reflectDamage > 5) {
            addDamageNumber(attacker.hexKey, reflectDamage);
          }
        }
      }

      return damage;
    }

    function executeAbility(unit, target, trigger) {
      const abl = unit.ability;
      if (!abl || !abl.effect) return;
      if (abl.trigger !== trigger) return;

      // Add ability particles at unit location
      const unitHex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
      if (unitHex) {
        const unitPos = hexToPixel(unitHex);
        addAbilityParticles(unitPos.x, unitPos.y, unit.color);
      }

      const effect = abl.effect;
      const attackerName = unitsData[unit.id].name;
      const targetName = target ? unitsData[target.id].name : '';

      // Gold effects
      if (effect.gold_per_attack) {
        gold += effect.gold_per_attack;
        combatLog.push(`${attackerName}'s ${abl.name}: +${effect.gold_per_attack}g!`);
      }
      if (effect.gold_steal && target) {
        if (!effect.once_per_target || !unit.attackedTargets.has(target.hexKey)) {
          gold += effect.gold_steal;
          combatLog.push(`${attackerName} steals ${effect.gold_steal}g!`);
          if (effect.once_per_target) unit.attackedTargets.add(target.hexKey);
        }
      }
      if (effect.gold_drop_chance && Math.random() * 100 < effect.gold_drop_chance) {
        gold += effect.gold_drop;
        combatLog.push(`${attackerName}'s ${abl.name}: +${effect.gold_drop}g drop!`);
      }

      // Damage effects
      if (effect.damage_mult && target) {
        const bonusDmg = unit.attack * (effect.damage_mult - 1);
        const finalDmg = calculateDamage(unit, target, bonusDmg);
        target.hp -= finalDmg;
        combatLog.push(`${abl.name} deals ${Math.round(finalDmg)} bonus damage!`);
      }

      // Self heal
      if (effect.self_heal) {
        const heal = unit.maxHp * effect.self_heal / 100;
        unit.hp = Math.min(unit.maxHp, unit.hp + heal);
        addHealNumber(unit.hexKey, heal);
        combatLog.push(`${attackerName} heals for ${Math.round(heal)}!`);
      }
      if (effect.self_heal_on_damage && target) {
        const heal = unit.attack * effect.self_heal_on_damage / 100;
        unit.hp = Math.min(unit.maxHp, unit.hp + heal);
        addHealNumber(unit.hexKey, heal);
      }

      // Status effects
      if (effect.attack_speed_slow && target) {
        applyStatus(target, STATUS.SLOW, (effect.duration || 3) * 1000, effect.attack_speed_slow);
      }
      if (effect.poison && target) {
        applyStatus(target, STATUS.POISON, effect.poison.duration * 1000, effect.poison.damage);
      }
      if (effect.bleed && target) {
        applyStatus(target, STATUS.POISON, effect.bleed.duration * 1000, effect.bleed.damage / effect.bleed.duration);
      }
      if (effect.stun && target) {
        applyStatus(target, STATUS.STUN, effect.stun * 1000);
      }
      if (effect.root && target) {
        applyStatus(target, STATUS.STUN, effect.root.duration * 1000);
      }
      if (effect.silence && target) {
        applyStatus(target, STATUS.SILENCE, effect.silence * 1000);
      }

      // AOE effects
      if (effect.aoe_stun) {
        const radius = effect.aoe_stun.radius || 2;
        const duration = (effect.aoe_stun.duration || effect.aoe_stun) * 1000;
        combatUnits.filter(u => u.isPlayer !== unit.isPlayer && u.hp > 0)
          .filter(u => hexDistance(unit.hexKey, u.hexKey) <= radius)
          .forEach(u => applyStatus(u, STATUS.STUN, duration));
      }
      if (effect.aoe_slow) {
        const radius = effect.aoe_slow.radius || 2;
        const percent = effect.aoe_slow.percent || effect.aoe_slow;
        combatUnits.filter(u => u.isPlayer !== unit.isPlayer && u.hp > 0)
          .filter(u => hexDistance(unit.hexKey, u.hexKey) <= radius)
          .forEach(u => applyStatus(u, STATUS.SLOW, 3000, percent));
      }

      // Ally buffs
      if (effect.ally_shield) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.hp > 0)
          .forEach(u => applyStatus(u, STATUS.SHIELD, (effect.duration || 5) * 1000, effect.ally_shield));
      }
      if (effect.ally_damage_amp) {
        // Simplified: just boost attack temporarily
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.hp > 0)
          .forEach(u => { u.attack = u.baseAttack * (1 + effect.ally_damage_amp / 100); });
      }

      // Crit chance
      if (effect.crit_chance && target && Math.random() * 100 < effect.crit_chance) {
        const critMult = effect.crit_mult || 2;
        const critDmg = unit.attack * (critMult - 1);
        const finalCrit = calculateDamage(unit, target, critDmg);
        target.hp -= finalCrit;
        addDamageNumber(target.hexKey, finalCrit, true); // true = crit (yellow)
        addStatusIcon(unit.hexKey, 'üí•');
        combatLog.push(`CRIT! ${Math.round(finalCrit)} bonus damage!`);
      }

      // Execute low HP
      if (effect.execute_threshold && target) {
        const threshold = target.maxHp * effect.execute_threshold / 100;
        if (target.hp > 0 && target.hp < threshold) {
          target.hp = 0;
          combatLog.push(`${attackerName} EXECUTES ${targetName}!`);
        }
      }

      // Damage reduction (passive armor)
      if (effect.damage_reduction) {
        unit.armor += effect.damage_reduction;
      }
      if (effect.armor) {
        unit.armor += effect.armor;
      }
    }

    function executePassives(unit) {
      const abl = unit.ability;
      if (!abl || abl.trigger !== 'passive' || !abl.effect) return;

      const effect = abl.effect;

      // Ally-wide passives
      if (effect.ally_attack_speed) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.faction === unit.faction && u.hp > 0)
          .forEach(u => {
            u.speed = u.baseSpeed * (1 + effect.ally_attack_speed / 100);
            u.actionCooldown = 1000 / u.speed;
          });
      }
      if (effect.ally_hp_amp) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.faction === unit.faction && u.hp > 0)
          .forEach(u => {
            const bonus = u.maxHp * effect.ally_hp_amp / 100;
            u.maxHp += bonus;
            u.hp += bonus;
          });
      }
      if (effect.ally_armor) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.faction === unit.faction && u.hp > 0)
          .forEach(u => { u.armor += effect.ally_armor; });
      }
      if (effect.ally_crit) {
        // Store for later use in attacks
        unit.bonusCrit = effect.ally_crit;
      }
      if (effect.damage_reduction) {
        unit.armor += effect.damage_reduction;
      }
      if (effect.armor) {
        unit.armor += effect.armor;
      }
    }

    function processCombatTick(deltaTime) {
      const now = Date.now();

      // Timeout safety (60s max)
      if (now - combatStartTime > 60000) {
        const playerHp = combatUnits.filter(u => u.isPlayer && u.hp > 0).reduce((s, u) => s + u.hp, 0);
        const enemyHp = combatUnits.filter(u => !u.isPlayer && u.hp > 0).reduce((s, u) => s + u.hp, 0);
        endCombat(playerHp >= enemyHp);
        return;
      }

      let playerAlive = false, enemyAlive = false;

      // Sort by speed for turn order
      const sortedUnits = [...combatUnits].sort((a, b) => b.speed - a.speed);

      for (const unit of sortedUnits) {
        if (unit.hp <= 0) {
          // Check for Ragdoll revive synergy
          if (unit.isPlayer && !unit.hasRevived) {
            const ragdollSynergy = activeCombatSynergies['Ragdoll'];
            if (ragdollSynergy?.revive_pct && unit.faction === 'Ragdoll') {
              unit.hp = unit.maxHp * ragdollSynergy.revive_pct / 100;
              unit.hasRevived = true;
              addStatusIcon(unit.hexKey, 'üé≠');
              addHealNumber(unit.hexKey, unit.hp);
              combatLog.push(`${unitsData[unit.id].name} goes LIMP and REVIVES with ${Math.round(unit.hp)} HP!`);
            }
          }
          if (unit.hp <= 0) continue;
        }
        if (unit.isPlayer) playerAlive = true;
        else enemyAlive = true;

        // Update status effects
        updateStatusEffects(unit, deltaTime);
        if (unit.hp <= 0) {
          combatLog.push(`${unitsData[unit.id].name} dies from poison!`);
          continue;
        }

        // Apply synergy healing over time
        if (unit.isPlayer) {
          // Maine Coon synergy: lifesteal is handled on attack (see lifesteal code below)

          // Sphynx synergy: disease spread is passive on poison application
        }

        // Stunned units can't act
        if (hasStatus(unit, STATUS.STUN)) continue;

        // Passive mana regen
        unit.mana = Math.min(unit.maxMana, unit.mana + deltaTime * 0.02);

        const { target, distance } = findNearestEnemy(unit, combatUnits);
        if (!target) continue;

        // In range: try to attack
        if (distance <= unit.range) {
          if (now - unit.lastActionTime >= unit.actionCooldown) {
            // Check for on-cast ability with full mana
            if (unit.mana >= MANA_TO_CAST && unit.ability?.trigger === 'on-cast' && !hasStatus(unit, STATUS.SILENCE)) {
              addStatusIcon(unit.hexKey, '‚ú®');
              combatLog.push(`${unitsData[unit.id].name} casts ${unit.ability.name}!`);
              executeAbility(unit, target, 'on-cast');
              unit.mana = 0;
            }

            // Calculate base damage with damage amp
            let baseDamage = unit.attack;
            if (unit.damageAmp) {
              baseDamage = baseDamage * (1 + unit.damageAmp / 100);
            }

            // Check for bonus damage vs diseased targets (Sphynx synergy)
            if (unit.damageVsPoisoned && hasStatus(target, STATUS.POISON)) {
              baseDamage = baseDamage * (1 + unit.damageVsPoisoned / 100);
              addStatusIcon(unit.hexKey, 'ü¶†');
            }

            // Check for critical hit (synergy bonus)
            let isCrit = false;
            if (unit.critChance && Math.random() * 100 < unit.critChance) {
              isCrit = true;
              baseDamage = baseDamage * (unit.critDamage / 100);
              addStatusIcon(unit.hexKey, 'üí•');
              playHiss(); // HISS on crit!

              // Mana on hit (Siamese synergy)
              const siameseSynergy = activeCombatSynergies['Siamese'];
              if (siameseSynergy?.mana_on_hit && unit.faction === 'Siamese') {
                unit.mana = Math.min(unit.maxMana, unit.mana + siameseSynergy.mana_on_hit);
              }
            }

            const damage = calculateDamage(unit, target, baseDamage);
            target.hp -= damage;
            unit.lastActionTime = now;
            unit.mana = Math.min(unit.maxMana, unit.mana + 10); // Mana on attack

            // Meow on every 5th attack!
            maybePlayAttackMeow();

            // Apply lifesteal (Maine Coon synergy)
            if (unit.lifesteal && damage > 0) {
              const healAmount = damage * unit.lifesteal / 100;
              unit.hp = Math.min(unit.maxHp, unit.hp + healAmount);
              if (healAmount > 5) {
                addHealNumber(unit.hexKey, healAmount);
              }
            }

            // Apply disease on hit (Sphynx synergy)
            if (unit.poisonOnHit && !hasStatus(target, STATUS.POISON)) {
              applyStatus(target, STATUS.POISON, 4000, unit.poisonOnHit);
              addStatusIcon(target.hexKey, 'ü¶†');
            }

            // Visual feedback
            addCombatHitEffect(unit, target, damage, isCrit);

            // Add attack animation
            unitAnimations[unit.hexKey] = { type: 'attack', startTime: Date.now() };

            // Trigger sprite animations
            setUnitAnimation(unit.id, 'attack');
            setUnitAnimation(target.id, 'hurt');
            const attackerHex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
            if (attackerHex) {
              const pos = hexToPixel(attackerHex);
              addAttackParticles(pos.x, pos.y, unit.color);
            }

            combatLog.push(`${unitsData[unit.id].name} hits ${unitsData[target.id].name} for ${Math.round(damage)}${isCrit ? ' CRIT!' : ''} (${Math.round(Math.max(0, target.hp))} HP)`);

            // Check for execute (Bengal synergy)
            if (unit.executeThreshold && target.hp > 0) {
              const threshold = target.maxHp * unit.executeThreshold / 100;
              if (target.hp < threshold) {
                target.hp = 0;
                addStatusIcon(target.hexKey, 'üêÜ');
                combatLog.push(`${unitsData[unit.id].name} POUNCES and EXECUTES ${unitsData[target.id].name}!`);
              }
            }

            // On-attack abilities
            if (!hasStatus(unit, STATUS.SILENCE)) {
              executeAbility(unit, target, 'on-attack');
            }

            if (target.hp <= 0) {
              combatLog.push(`${unitsData[target.id].name} defeated!`);

              // Add death animation
              unitAnimations[target.hexKey] = { type: 'death', startTime: Date.now(), deathTime: Date.now() };
              setUnitAnimation(target.id, 'death');
              addDeathExplosion(target.hexKey);

              // Sad death meow üòø
              playDeathMeow();
            }
          }
        } else {
          // Out of range: move toward enemy
          if (now - unit.lastMoveTime >= unit.moveCooldown) {
            const newHex = findMoveToward(unit, target, combatUnits);
            if (newHex) {
              // Update board state for rendering
              if (unit.isPlayer) {
                delete playerBoard[unit.hexKey];
                playerBoard[newHex] = unit.id;
              } else {
                delete enemyBoard[unit.hexKey];
                enemyBoard[newHex] = unit.id;
              }
              unit.hexKey = newHex;
              unit.lastMoveTime = now;
            }
          }
        }
      }

      // Check win/lose
      playerAlive = combatUnits.some(u => u.isPlayer && u.hp > 0);
      enemyAlive = combatUnits.some(u => !u.isPlayer && u.hp > 0);

      if (!playerAlive || !enemyAlive) {
        endCombat(playerAlive);
      }
    }

    // Get combined synergy bonuses for a faction
    function getSynergyBonuses() {
      const { activeSynergies } = calculateSynergies();
      const bonuses = {};

      Object.entries(activeSynergies).forEach(([faction, data]) => {
        if (data.activeBonus) {
          bonuses[faction] = data.activeBonus;
        }
      });

      return bonuses;
    }

    // Track active synergies for combat effects
    let activeCombatSynergies = {};

    function startCombat() {
      if (Object.keys(playerBoard).length === 0) {
        alert('Place some units first!');
        return;
      }
      if (combatState !== 'idle') return;

      // Save pre-combat positions for reset after combat
      preCombatBoard = { ...playerBoard };

      combatState = 'combat';
      combatUnits = [];
      combatLog = [];
      visualEffects = []; // Clear visual effects
      combatStartTime = Date.now();
      lastCombatTime = combatStartTime;

      // Calculate synergy bonuses for this combat
      const synergyBonuses = getSynergyBonuses();
      activeCombatSynergies = synergyBonuses;

      // Log active synergies
      const activeSynergyNames = Object.entries(synergyBonuses)
        .map(([faction, bonus]) => `${factionSynergies[faction].name}: ${bonus.description}`)
        .filter(Boolean);
      if (activeSynergyNames.length > 0) {
        combatLog.push(`=== ACTIVE SYNERGIES ===`);
        activeSynergyNames.forEach(s => combatLog.push(`‚Ä¢ ${s}`));
      }

      // Show round banner
      roundBanner = {
        text: `ROUND ${currentRound}`,
        subtext: 'FIGHT!',
        color: '#ffd700',
        startTime: Date.now(),
        duration: 1500
      };

      // Create player combat units with synergy bonuses and star levels
      Object.entries(playerBoard).forEach(([key, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;
        const unit = createCombatUnit(unitId, key, true, synergyBonuses, stars);
        if (unit) {
          unit.stars = stars; // Store for display
          combatUnits.push(unit);
        }
      });

      // Spawn enemies in rows 0-3 (enemy half of board)
      enemyBoard = {};
      const enemyCount = Math.min(3 + currentRound, 12); // Scale with round, not level
      const enemyHexes = boardHexes.filter(h => h.row <= 3);

      // Shuffle enemy hexes for variety
      const shuffledHexes = [...enemyHexes].sort(() => Math.random() - 0.5);

      // Scale enemy star levels with round
      const getEnemyStars = () => {
        if (currentRound >= 15) return Math.random() < 0.3 ? 3 : 2;
        if (currentRound >= 8) return Math.random() < 0.5 ? 2 : 1;
        if (currentRound >= 4) return Math.random() < 0.3 ? 2 : 1;
        return 1;
      };

      // Prefer higher cost units in later rounds
      const getEnemyUnitId = () => {
        const maxTier = Math.min(5, 1 + Math.floor(currentRound / 3));
        const availableTiers = [];
        for (let t = 1; t <= maxTier; t++) {
          if (unitsByTier[t] && unitsByTier[t].length > 0) {
            // Weight higher tiers more in later rounds
            const weight = t <= maxTier - 1 ? 1 : 2;
            for (let w = 0; w < weight; w++) {
              availableTiers.push(...unitsByTier[t]);
            }
          }
        }
        return availableTiers[Math.floor(Math.random() * availableTiers.length)];
      };

      for (let i = 0; i < enemyCount && i < shuffledHexes.length; i++) {
        const hex = shuffledHexes[i];
        const key = getHexKey(hex);
        const unitId = getEnemyUnitId();
        const stars = getEnemyStars();
        enemyBoard[key] = { id: unitId, stars: stars };
      }

      Object.entries(enemyBoard).forEach(([key, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;
        const unit = createCombatUnit(unitId, key, false, null, stars);
        if (unit) {
          unit.stars = stars;
          combatUnits.push(unit);
        }
      });

      // Execute passive abilities at combat start
      combatUnits.forEach(u => executePassives(u));

      // Add initial combat animations
      combatUnits.forEach(u => {
        if (u.isPlayer) {
          // Add a subtle glow effect to player units at start
          const hex = boardHexes.find(h => getHexKey(h) === u.hexKey);
          if (hex) {
            const p = hexToPixel(hex);
            addAbilityEffect(p.x, p.y, u.color, 30);
          }
        }
      });

      // Add initial combat animations
      combatUnits.forEach(u => {
        if (u.isPlayer) {
          // Add a subtle glow effect to player units at start
          const hex = boardHexes.find(h => getHexKey(h) === u.hexKey);
          if (hex) {
            const p = hexToPixel(hex);
            addAbilityEffect(p.x, p.y, u.color, 30);
          }
        }
      });

      combatLog.push(`=== COMBAT START ===`);
      combatLog.push(`Your army: ${combatUnits.filter(u => u.isPlayer).length} units`);
      combatLog.push(`Enemy army: ${combatUnits.filter(u => !u.isPlayer).length} units`);

      document.getElementById('combatLog').style.display = 'block';
      updateCombatLog();
      renderBoard();
      requestAnimationFrame(combatLoop);
    }

    function combatLoop() {
      if (combatState !== 'combat') return;

      const now = Date.now();
      const delta = now - lastCombatTime;

      if (delta >= COMBAT_TICK_MS) {
        processCombatTick(delta);
        lastCombatTime = now;
        renderBoard();
        updateCombatLog();
      }

      if (combatState === 'combat') {
        requestAnimationFrame(combatLoop);
      }
    }

    // Add attack animation to units when they attack
    function addUnitAttackAnimation(attacker, target) {
      const attackerHex = boardHexes.find(h => getHexKey(h) === attacker.hexKey);
      const targetHex = boardHexes.find(h => getHexKey(h) === target.hexKey);

      if (attackerHex && targetHex) {
        const attackerPos = hexToPixel(attackerHex);
        const targetPos = hexToPixel(targetHex);

        // Add attack pulse effect
        addAttackPulse(attackerPos.x, attackerPos.y, attacker.color, 40);

        // Add attack line effect
        visualEffects.push({
          type: 'attackLine',
          x: attackerPos.x,
          y: attackerPos.y,
          x2: targetPos.x,
          y2: targetPos.y,
          color: attacker.color,
          startTime: Date.now(),
          duration: 300
        });
      }
    }

    function updateCombatLog() {
      const logEl = document.getElementById('combatLog');
      logEl.innerHTML = combatLog.slice(-20).map(line => `<div>${line}</div>`).join('');
      logEl.scrollTop = logEl.scrollHeight;
    }

    function endCombat(playerWon) {
      // In multiplayer mode, use the multiplayer end combat handler
      if (typeof GameState !== 'undefined' && GameState.mode === 'multiplayer') {
        endMultiplayerCombat(playerWon);
        return;
      }

      combatState = 'idle';

      const survivors = combatUnits.filter(u => u.isPlayer && u.hp > 0).length;
      const totalPlayerUnits = Object.keys(preCombatBoard).length;
      const enemiesKilled = combatUnits.filter(u => !u.isPlayer && u.hp <= 0).length;

      // Calculate Alley synergy gold bonus
      let synergyGoldBonus = 0;
      const alleySynergy = activeCombatSynergies['Alley'];
      if (alleySynergy?.gold_per_round) {
        synergyGoldBonus = alleySynergy.gold_per_round;
      }

      // Show result banner
      if (playerWon) {
        const baseGold = 5 + Math.floor(enemiesKilled / 2);
        const totalGold = baseGold + synergyGoldBonus;
        gold += totalGold;
        combatLog.push(`=== VICTORY! ===`);
        combatLog.push(`+${baseGold} gold (${survivors} survivors)`);
        if (synergyGoldBonus > 0) {
          combatLog.push(`+${synergyGoldBonus} gold (Alley synergy)`);
        }

        roundBanner = {
          text: 'VICTORY!',
          subtext: synergyGoldBonus > 0 ? `+${totalGold} gold (+${synergyGoldBonus} Alley)` : `+${baseGold} gold`,
          color: '#4f4',
          startTime: Date.now(),
          duration: 2000
        };
      } else {
        const damage = 5 + combatUnits.filter(u => !u.isPlayer && u.hp > 0).length * 2;
        health -= damage;
        // Still give Alley synergy gold on loss
        if (synergyGoldBonus > 0) {
          gold += synergyGoldBonus;
          combatLog.push(`+${synergyGoldBonus} gold (Alley synergy)`);
        }
        combatLog.push(`=== DEFEAT! ===`);
        combatLog.push(`-${damage} health`);

        roundBanner = {
          text: 'DEFEAT',
          subtext: `-${damage} health`,
          color: '#f44',
          startTime: Date.now(),
          duration: 2000
        };
      }

      // Restore player board to pre-combat positions (units reset)
      playerBoard = { ...preCombatBoard };

      // Increment round
      currentRound++;

      updateUI();
      enemyBoard = {};

      setTimeout(() => {
        document.getElementById('combatLog').style.display = 'none';

        // Auto-refresh shop each round
        shopUnits = Array(5).fill().map(() => rollShopUnit());
        renderShop();

        // Show "Preparing Round X" banner
        roundBanner = {
          text: `ROUND ${currentRound}`,
          subtext: 'Prepare your units!',
          color: '#fff',
          startTime: Date.now(),
          duration: 1500
        };

        renderBoard();
        renderBench();
        renderSynergies(); // Update synergies panel after combat

        if (health <= 0) {
          setTimeout(() => {
            alert('GAME OVER! You have been eliminated.');
            health = 100;
            gold = 50;
            playerLevel = 1;
            currentRound = 1;
            playerBoard = {};
            bench = Array(9).fill(null);
            preCombatBoard = {};
            shopUnits = Array(5).fill().map(() => rollShopUnit());
            renderShop();
            renderBench();
            updateUI();
            renderBoard();
          }, 500);
        }
      }, 2000);
    }

    document.getElementById('fight').onclick = startCombat;

    // Animation loop - always render for background animation
    function animationLoop() {
      if (combatState === 'idle') {
        renderBoard();
      }
      requestAnimationFrame(animationLoop);
    }

    function addUnitAbilityAnimation(unit) {
      const hex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
      if (hex) {
        const p = hexToPixel(hex);
        addAbilityEffect(p.x, p.y, unit.color, 60);
      }
    }

    // Function to trigger various combat animations
    function triggerCombatAnimation(unit, animationType) {
      switch(animationType) {
        case 'attack':
          // Attack animation is handled in addUnitAttackAnimation
          break;
        case 'death':
          addUnitDeathAnimation(unit);
          break;
        case 'ability':
          addUnitAbilityAnimation(unit);
          break;
        case 'hit':
          // Add a hit flash effect
          const hex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
          if (hex) {
            const p = hexToPixel(hex);
            addAttackPulse(p.x, p.y, unit.color, 20);
          }
          break;
      }
    }

    function init() {
      shopUnits = Array(5).fill().map(() => rollShopUnit());
      renderShop();
      renderBoard();
      renderBench();
      setupBenchEvents();
      updateUI();
      renderSynergies(); // Initialize synergies panel

      // Show initial round banner
      roundBanner = {
        text: `ROUND ${currentRound}`,
        subtext: 'Place your units and FIGHT!',
        color: '#ffd700',
        startTime: Date.now(),
        duration: 2000
      };

      // Start animation loop
      requestAnimationFrame(animationLoop);
    }

    // Load unit images
    function loadUnitImages() {
      const unitImageMap = {
        'alley_tabby_thug': 'alley_tabby_thug.png',
        'alley_ginger_rogue': 'alley_ginger_rogue.png',
        'alley_tuxedo_con': 'alley_tuxedo_con.png',
        'alley_street_yowler': 'alley_street_yowler.png',
        'alley_dumpster_king': 'alley_dumpster_king.png',
        'alley_feral_boss': 'alley_feral_boss.png',
        'persian_princess': 'persian_princess.png',
        'persian_pampered': 'persian_pampered.png',
        'persian_groomer': 'persian_groomer.png',
        'persian_snob': 'persian_snob.png',
        'persian_himalayan': 'persian_himalayan.png',
        'persian_emperor': 'persian_emperor.png',
        'siamese_screamer': 'siamese_screamer.png',
        'siamese_chatterbox': 'siamese_chatterbox.png',
        'siamese_soprano': 'siamese_soprano.png',
        'siamese_gossip': 'siamese_gossip.png',
        'siamese_opera': 'siamese_opera.png',
        'siamese_conductor': 'siamese_conductor.png',
        'mainecoon_titan': 'mainecoon_titan.png',
        'mainecoon_cub': 'mainecoon_cub.png',
        'mainecoon_guardian': 'mainecoon_guardian.png',
        'mainecoon_brawler': 'mainecoon_brawler.png',
        'mainecoon_elder': 'mainecoon_elder.png',
        'mainecoon_alpha': 'mainecoon_alpha.png',
        'bengal_stalker': 'bengal_stalker.png',
        'bengal_kitten': 'bengal_kitten.png',
        'bengal_hunter': 'bengal_hunter.png',
        'bengal_assassin': 'bengal_assassin.png',
        'bengal_pack_leader': 'bengal_pack_leader.png',
        'bengal_apex': 'bengal_apex.png',
        'sphynx_menace': 'sphynx_menace.png',
        'sphynx_creeper': 'sphynx_creeper.png',
        'sphynx_warmer': 'sphynx_warmer.png',
        'sphynx_cultist': 'sphynx_cultist.png',
        'sphynx_oracle': 'sphynx_oracle.png',
        'sphynx_overlord': 'sphynx_overlord.png',
        'scottish_gambler': 'scottish_gambler.png',
        'scottish_lucky': 'scottish_lucky.png',
        'scottish_dealer': 'scottish_dealer.png',
        'scottish_bettor': 'scottish_bettor.png',
        'scottish_fortune': 'scottish_fortune.png',
        'scottish_jackpot': 'scottish_jackpot.png',
        'ragdoll_faker': 'ragdoll_faker.png',
        'ragdoll_lazy': 'ragdoll_lazy.png',
        'ragdoll_flopper': 'ragdoll_flopper.png',
        'ragdoll_dreamer': 'ragdoll_dreamer.png',
        'ragdoll_therapist': 'ragdoll_therapist.png',
        'ragdoll_zen': 'ragdoll_zen.png'
      };

      // Load all images
      Object.keys(unitImageMap).forEach(unitId => {
        const img = new Image();
        img.src = 'assets/images/units/' + unitId + '.png';
        img.onload = function() {
          unitImages[unitId] = img;
        };
        img.onerror = function() {
//          console.warn(`Failed to load image for unit: ${unitId}`);
        };
      });
    }

    // ========== MULTIPLAYER UI FUNCTIONS ==========

    // Render the scoreboard
    function renderScoreboard() {
      if (GameState.mode !== 'multiplayer') return;

      const list = document.getElementById('scoreboard-list');
      if (!list) return;

      // Sort players by health (alive first), then by placement
      const sortedPlayers = [...GameState.players].sort((a, b) => {
        if (a.isAlive && !b.isAlive) return -1;
        if (!a.isAlive && b.isAlive) return 1;
        return b.health - a.health;
      });

      list.innerHTML = sortedPlayers.map(player => {
        const isHuman = player.id === GameState.humanPlayerIndex;
        const isFighting = GameState.phase === 'combat' &&
          MultiplayerCombat.activeBattles.some(b =>
            (b.playerA === player.id || b.playerB === player.id));

        let classes = 'scoreboard-player';
        if (!player.isAlive) classes += ' eliminated';
        if (isHuman) classes += ' current';
        if (isFighting) classes += ' fighting';

        const healthClass = player.health > 50 ? 'healthy' : '';
        const streakText = player.streak > 0 ? `W${player.streak}` :
                          player.streak < 0 ? `L${Math.abs(player.streak)}` : '-';
        const streakClass = player.streak > 0 ? 'win' : player.streak < 0 ? 'loss' : '';

        return `
          <div class="${classes}">
            <div class="player-color" style="background: ${player.color}"></div>
            <div class="player-name">${player.name}${isHuman ? ' (You)' : ''}</div>
            <div class="player-health ${healthClass}">‚ù§Ô∏è${player.health}</div>
            <div class="player-gold">üí∞${player.gold}</div>
            <div class="player-streak ${streakClass}">${streakText}</div>
          </div>
        `;
      }).join('');
    }

    // Show matchup result
    function showMatchupResult(result) {
      const display = document.getElementById('matchup-display');
      const playerAEl = document.getElementById('matchup-player-a');
      const playerBEl = document.getElementById('matchup-player-b');
      const resultEl = document.getElementById('matchup-result');
      const damageEl = document.getElementById('matchup-damage');

      const playerA = GameState.players[result.playerA];
      const playerB = GameState.players[result.playerB];
      const humanId = GameState.humanPlayerIndex;

      playerAEl.textContent = playerA.name;
      playerAEl.style.background = playerA.color;
      playerAEl.style.color = '#fff';

      playerBEl.textContent = playerB.name;
      playerBEl.style.background = playerB.color;
      playerBEl.style.color = '#fff';

      // Determine result from human perspective
      const humanWon = result.winner === humanId;
      const humanLost = result.loser === humanId;
      const humanInvolved = humanWon || humanLost;

      if (humanInvolved) {
        if (humanWon) {
          resultEl.textContent = 'üèÜ VICTORY!';
          resultEl.className = 'matchup-result win';
          damageEl.textContent = '';
        } else {
          resultEl.textContent = 'üíÄ DEFEAT';
          resultEl.className = 'matchup-result loss';
          damageEl.textContent = `-${result.damage} HP`;
        }
      } else {
        const winner = result.winner !== null ? GameState.players[result.winner] : null;
        resultEl.textContent = winner ? `${winner.name} wins!` : 'Draw!';
        resultEl.className = 'matchup-result';
        damageEl.textContent = '';
      }

      display.classList.add('active');

      // Auto-hide after delay
      setTimeout(() => {
        display.classList.remove('active');
      }, 2500);
    }

    // Run multiplayer combat phase
    function runMultiplayerCombat() {
      if (GameState.mode !== 'multiplayer') return;
      if (combatState !== 'idle') return;

      GameState.phase = 'combat';

      // Have all bots take their turns first
      GameState.players.forEach(player => {
        if (player.isBot && player.isAlive) {
          BotAI.takeTurn(player);
        }
      });

      // Sync human player state to legacy variables
      const human = GameState.getHumanPlayer();
      playerBoard = human.board;
      bench = human.bench;
      gold = human.gold;
      health = human.health;
      playerLevel = human.level;

      // Find who the human is fighting this round
      const matchups = GameState.getMatchupsForRound();
      const humanMatchup = matchups.find(m =>
        m.playerA === GameState.humanPlayerIndex || m.playerB === GameState.humanPlayerIndex
      );

      if (!humanMatchup || Object.keys(playerBoard).length === 0) {
        // No matchup or no units - skip combat animation
        skipMultiplayerCombat();
        return;
      }

      // Determine opponent
      const opponentId = humanMatchup.playerA === GameState.humanPlayerIndex
        ? humanMatchup.playerB
        : humanMatchup.playerA;
      const opponent = GameState.players[opponentId];

      // Start animated combat against opponent's ghost army
      startAnimatedMultiplayerCombat(opponent, matchups);
    }

    function skipMultiplayerCombat() {
      // Run instant simulation for all matchups
      const results = MultiplayerCombat.runAllMatchups();
      MultiplayerCombat.applyResults();

      // Advance to next round
      renderScoreboard();
      const humanAfter = GameState.getHumanPlayer();
      gold = humanAfter.gold;
      health = humanAfter.health;
      updateUI();

      startNextMultiplayerRound();
    }

    function startAnimatedMultiplayerCombat(opponent, matchups) {
      // Save pre-combat positions for reset
      preCombatBoard = { ...playerBoard };

      combatState = 'combat';
      combatUnits = [];
      combatLog = [];
      visualEffects = [];
      combatStartTime = Date.now();
      lastCombatTime = combatStartTime;

      // Calculate synergy bonuses for player
      const synergyBonuses = getSynergyBonuses();
      activeCombatSynergies = synergyBonuses;

      // Show round banner with opponent name
      roundBanner = {
        text: `ROUND ${GameState.round}`,
        subtext: `vs ${opponent.name}`,
        color: opponent.color,
        startTime: Date.now(),
        duration: 1500
      };

      // Create player combat units
      Object.entries(playerBoard).forEach(([key, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;
        const unit = createCombatUnit(unitId, key, true, synergyBonuses, stars);
        if (unit) {
          unit.stars = stars;
          combatUnits.push(unit);
        }
      });

      // Create opponent's ghost army (mirrored to enemy rows)
      enemyBoard = {};
      const opponentSynergies = MultiplayerCombat.getSynergyBonusesForPlayer(opponent);

      Object.entries(opponent.board).forEach(([hexKey, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;

        // Mirror hex position: row 4->3, 5->2, 6->1, 7->0
        const [col, row] = hexKey.split(',').map(Number);
        const mirrorRow = 7 - row;
        const mirrorKey = `${col},${mirrorRow}`;

        enemyBoard[mirrorKey] = { id: unitId, stars: stars };

        const unit = createCombatUnit(unitId, mirrorKey, false, opponentSynergies, stars);
        if (unit) {
          unit.stars = stars;
          unit.ownerName = opponent.name;
          unit.ownerColor = opponent.color;
          combatUnits.push(unit);
        }
      });

      // Execute passive abilities
      combatUnits.forEach(u => executePassives(u));

      // Store matchups for later resolution
      currentMultiplayerMatchups = matchups;
      currentOpponent = opponent;

      // Log combat start
      combatLog.push(`=== COMBAT START ===`);
      combatLog.push(`You vs ${opponent.name}`);
      combatLog.push(`Your army: ${combatUnits.filter(u => u.isPlayer).length} units`);
      combatLog.push(`Enemy army: ${combatUnits.filter(u => !u.isPlayer).length} units`);

      document.getElementById('combatLog').style.display = 'block';
      updateCombatLog();
      renderBoard();

      // Start the combat loop!
      requestAnimationFrame(combatLoop);
    }

    let currentMultiplayerMatchups = null;
    let currentOpponent = null;

    // Modified combat end for multiplayer
    function endMultiplayerCombat(playerWon) {
      combatState = 'idle';

      // Run the full simulation for ALL matchups (including human's)
      const results = MultiplayerCombat.runAllMatchups();

      // Find human's result
      const humanBattle = MultiplayerCombat.getPlayerBattle(GameState.humanPlayerIndex);

      // Show result popup
      if (humanBattle) {
        showMatchupResult(humanBattle);
      }

      // Apply all results
      MultiplayerCombat.applyResults();

      // Update UI
      renderScoreboard();
      const humanAfter = GameState.getHumanPlayer();
      gold = humanAfter.gold;
      health = humanAfter.health;
      updateUI();

      // Reset board positions
      playerBoard = { ...preCombatBoard };
      enemyBoard = {};
      renderBoard();

      // Show combat log briefly
      document.getElementById('combatLog').style.display = 'block';
      const allLogs = results.flatMap(r => r.combatLog);
      combatLog = allLogs;
      updateCombatLog();

      // Check for game over after delay
      setTimeout(() => {
        document.getElementById('combatLog').style.display = 'none';
        startNextMultiplayerRound();
      }, 3000);
    }

    function startNextMultiplayerRound() {
      const humanAfter = GameState.getHumanPlayer();

      if (GameState.isGameOver()) {
        const winner = GameState.getWinner();
        const humanWon = winner && winner.id === GameState.humanPlayerIndex;

        roundBanner = {
          text: humanWon ? 'üèÜ VICTORY!' : 'üíÄ GAME OVER',
          subtext: humanWon ? 'You are the champion!' : `${winner?.name || 'Nobody'} wins!`,
          color: humanWon ? '#ffd700' : '#f44',
          startTime: Date.now(),
          duration: 5000
        };
        renderBoard();

        setTimeout(() => {
          if (confirm(humanWon ? 'Congratulations! Play again?' : 'Game Over! Play again?')) {
            location.reload();
          }
        }, 3000);
        return;
      }

      // Check if human is eliminated
      if (!humanAfter.isAlive) {
        const placement = humanAfter.placement || (8 - GameState.eliminationOrder.length);
        roundBanner = {
          text: 'üíÄ ELIMINATED',
          subtext: `You placed #${placement}`,
          color: '#f44',
          startTime: Date.now(),
          duration: 3000
        };
        renderBoard();

        setTimeout(() => {
          if (confirm(`You placed #${placement}! Watch the rest or restart?`)) {
            location.reload();
          }
        }, 2000);
        return;
      }

      // Advance to next round
      GameState.nextRound();
      currentRound = GameState.round;

      // Sync human's new shop
      const humanNext = GameState.getHumanPlayer();
      shopUnits = humanNext.shop;
      gold = humanNext.gold;

      roundBanner = {
        text: `ROUND ${GameState.round}`,
        subtext: `${GameState.getAliveCount()} players remaining`,
        color: '#fff',
        startTime: Date.now(),
        duration: 2000
      };

      renderShop();
      renderBoard();
      renderBench();
      renderScoreboard();
      updateUI();
    }

    // Sync human player actions to GameState
    function syncHumanToGameState() {
      if (GameState.mode !== 'multiplayer') return;

      const human = GameState.getHumanPlayer();
      human.board = { ...playerBoard };
      human.bench = [...bench];
      human.gold = gold;
      human.level = playerLevel;
      human.shop = [...shopUnits];
    }

    // Start single player mode
    function startSinglePlayer() {
      document.getElementById('mode-select').style.display = 'none';
      GameState.mode = 'single';
      init();
    }

    // Start multiplayer mode
    function startMultiplayer() {
      document.getElementById('mode-select').style.display = 'none';
      GameState.mode = 'multiplayer';

      // Initialize 8 players
      const human = GameState.init(1);

      // Sync human's initial state to legacy variables
      gold = human.gold;
      health = human.health;
      playerLevel = human.level;
      playerBoard = human.board;
      bench = human.bench;
      shopUnits = human.shop;
      currentRound = GameState.round;

      // Show scoreboard
      document.getElementById('scoreboard').classList.add('active');

      // Initialize game
      renderShop();
      renderBoard();
      renderBench();
      setupBenchEvents();
      updateUI();
      renderSynergies();
      renderScoreboard();

      // Change fight button to work with multiplayer
      document.getElementById('fight').onclick = function() {
        if (combatState !== 'idle') return;
        syncHumanToGameState();
        runMultiplayerCombat();
      };

      // Show initial banner
      roundBanner = {
        text: 'ROUND 1',
        subtext: '8 players - Round Robin!',
        color: '#ffd700',
        startTime: Date.now(),
        duration: 2500
      };

      requestAnimationFrame(animationLoop);
    }

    // Hook up mode selection buttons
    document.getElementById('btn-single').onclick = startSinglePlayer;
    document.getElementById('btn-multiplayer').onclick = startMultiplayer;

    // Initialize images (but don't start game until mode selected)
    loadUnitImages();

    // Generate placeholder sprite sheets for all factions
    generateAllPlaceholderSheets();
  </script>
</body>
</html>