<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FFFA - Feline Free For All Auto-Battler</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    body { background: #111; color: #fff; font-family: Arial, sans-serif; display: flex; flex-direction: column; padding: 8px; gap: 6px; height: 100vh; }
    #ui { display: flex; gap: 12px; align-items: center; font-size: 14px; font-weight: bold; justify-content: center; flex-shrink: 0; }
    button { background: #444; color: #fff; border: 2px solid #666; padding: 6px 14px; border-radius: 5px; cursor: pointer; font-size: 14px; }
    button:hover { background: #555; border-color: #888; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button:disabled:hover { background: #444; }
    #shop { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; flex-shrink: 0; }
    .unit { background: linear-gradient(145deg, #333, #555); border: 2px solid #777; border-radius: 8px; padding: 8px; width: 100px; height: 110px; text-align: center; cursor: grab; user-select: none; transition: transform 0.2s; box-shadow: 0 2px 6px rgba(0,0,0,0.5); }
    .unit:hover { transform: scale(1.05); }
    .unit:active { cursor: grabbing; }
    .unit-icon { font-size: 32px; margin: 4px 0; }
    .unit-name { font-size: 11px; margin: 3px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .unit-cost { font-size: 13px; font-weight: bold; color: #ffd700; }
    .unit-faction { font-size: 10px; color: #aaa; }
    #game-container { display: flex; gap: 10px; justify-content: center; align-items: flex-start; flex: 1; min-height: 0; }
    #synergies-panel { width: 160px; background: rgba(0,0,0,0.6); border: 2px solid #444; border-radius: 8px; padding: 8px; max-height: 100%; overflow-y: auto; flex-shrink: 0; }
    #synergies-panel h3 { margin: 0 0 6px 0; font-size: 13px; text-align: center; color: #ffd700; }
    .synergy-item { display: flex; align-items: center; gap: 6px; padding: 5px; margin: 3px 0; border-radius: 4px; background: rgba(255,255,255,0.05); }
    .synergy-item.active { background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.5); }
    .synergy-item.inactive { opacity: 0.5; }
    .synergy-icon { font-size: 16px; }
    .synergy-info { flex: 1; }
    .synergy-name { font-size: 10px; font-weight: bold; }
    .synergy-count { font-size: 9px; color: #aaa; }
    .synergy-bonus { font-size: 9px; color: #4f4; margin-top: 1px; }
    .threshold { display: inline-block; padding: 1px 3px; margin: 1px; border-radius: 3px; font-size: 9px; }
    .threshold.active { background: #ffd700; color: #000; }
    .threshold.inactive { background: #333; color: #666; }
    #board { border: 2px solid #444; border-radius: 8px; background: #000; display: block; box-shadow: 0 4px 12px rgba(0,0,0,0.8); pointer-events: all; max-height: 100%; }
    #combatLog { position: fixed; top: 10px; right: 10px; width: 280px; height: 180px; background: rgba(0,0,0,0.9); padding: 8px; overflow-y: auto; font-size: 11px; display: none; border: 1px solid #666; border-radius: 5px; }

    /* Unit Tooltip */
    #unit-tooltip {
      position: fixed;
      display: none;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 2px solid #4a4a6a;
      border-radius: 10px;
      padding: 0;
      min-width: 220px;
      max-width: 260px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.8), 0 0 15px rgba(100,100,255,0.2);
      z-index: 1000;
      pointer-events: none;
      font-size: 11px;
    }
    .tooltip-header {
      background: linear-gradient(90deg, #2a2a4a, #3a3a5a);
      padding: 8px 10px;
      border-radius: 8px 8px 0 0;
      border-bottom: 1px solid #4a4a6a;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tooltip-icon {
      font-size: 28px;
      text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }
    .tooltip-title {
      flex: 1;
    }
    .tooltip-name {
      font-size: 13px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 2px;
    }
    .tooltip-faction {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 8px;
      display: inline-block;
    }
    .tooltip-cost {
      background: linear-gradient(135deg, #ffd700, #ffaa00);
      color: #000;
      font-weight: bold;
      font-size: 14px;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(255,215,0,0.4);
    }
    .tooltip-body {
      padding: 8px 10px;
    }
    .tooltip-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      margin-bottom: 8px;
    }
    .tooltip-stat {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(255,255,255,0.05);
      padding: 4px 6px;
      border-radius: 4px;
    }
    .stat-icon {
      font-size: 11px;
    }
    .stat-label {
      color: #888;
      font-size: 9px;
      text-transform: uppercase;
    }
    .stat-value {
      color: #fff;
      font-weight: bold;
      margin-left: auto;
      font-size: 11px;
    }
    .tooltip-ability {
      background: linear-gradient(135deg, rgba(100,50,150,0.3), rgba(50,50,100,0.3));
      border: 1px solid rgba(150,100,200,0.3);
      border-radius: 6px;
      padding: 6px 8px;
    }
    .ability-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .ability-name {
      color: #c8a2ff;
      font-weight: bold;
      font-size: 11px;
    }
    .ability-trigger {
      font-size: 8px;
      padding: 2px 5px;
      border-radius: 6px;
      text-transform: uppercase;
      font-weight: bold;
    }
    .trigger-passive { background: #2d5a2d; color: #6fcf6f; }
    .trigger-on-attack { background: #5a2d2d; color: #cf6f6f; }
    .trigger-on-cast { background: #2d2d5a; color: #6f6fcf; }
    .ability-desc {
      color: #aaa;
      font-size: 10px;
      line-height: 1.3;
    }

    /* Bench System */
    #bench-container {
      display: flex;
      justify-content: center;
      gap: 6px;
      padding: 8px;
      background: linear-gradient(180deg, #1a1a2e 0%, #0d0d1a 100%);
      border: 2px solid #333;
      border-radius: 8px;
      margin: 0 auto;
      flex-shrink: 0;
    }
    #bench-label {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #666;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .bench-slot {
      width: 54px;
      height: 54px;
      background: rgba(255,255,255,0.05);
      border: 2px dashed #444;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .bench-slot:hover {
      background: rgba(255,255,255,0.1);
      border-color: #666;
    }
    .bench-slot.occupied {
      border-style: solid;
      cursor: grab;
    }
    .bench-slot.drag-over {
      background: rgba(50,255,100,0.2);
      border-color: #4f4;
    }
    .bench-unit {
      font-size: 28px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .bench-unit-stars {
      position: absolute;
      bottom: 1px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      color: #ffd700;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }
    .bench-unit-cost {
      position: absolute;
      top: 1px;
      right: 3px;
      font-size: 9px;
      color: #ffd700;
      font-weight: bold;
    }

    /* Star display on board */
    .star-indicator {
      color: #ffd700;
      text-shadow: 0 0 4px rgba(255,215,0,0.8);
    }
    .star-2 { color: #4af; text-shadow: 0 0 6px rgba(68,170,255,0.8); }
    .star-3 { color: #f4a; text-shadow: 0 0 8px rgba(255,68,170,0.8); }

    /* Sell zone */
    #sell-zone {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 40px;
      background: rgba(255,50,50,0.2);
      border: 2px dashed #f44;
      border-radius: 10px;
      color: #f88;
      font-weight: bold;
      font-size: 14px;
      display: none;
      z-index: 100;
    }
    #sell-zone.active {
      display: block;
    }
    #sell-zone.drag-over {
      background: rgba(255,50,50,0.4);
      border-color: #f88;
      color: #fff;
    }

    /* Multiplayer Scoreboard */
    #scoreboard {
      position: fixed;
      right: 8px;
      top: 40px;
      width: 180px;
      background: rgba(0,0,0,0.9);
      border: 2px solid #444;
      border-radius: 8px;
      padding: 8px;
      display: none;
      z-index: 500;
      max-height: calc(100vh - 60px);
      overflow-y: auto;
    }
    #scoreboard.active {
      display: block;
    }
    #scoreboard h3 {
      margin: 0 0 6px 0;
      font-size: 12px;
      color: #ffd700;
      text-align: center;
      border-bottom: 1px solid #444;
      padding-bottom: 6px;
    }
    .scoreboard-player {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      margin: 3px 0;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      transition: all 0.2s;
      font-size: 11px;
    }
    .scoreboard-player.eliminated {
      opacity: 0.4;
      text-decoration: line-through;
    }
    .scoreboard-player.current {
      background: rgba(255,215,0,0.2);
      border: 1px solid rgba(255,215,0,0.4);
    }
    .scoreboard-player.fighting {
      background: rgba(255,100,100,0.2);
      border: 1px solid rgba(255,100,100,0.4);
    }
    .player-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .player-name {
      flex: 1;
      font-size: 12px;
      font-weight: bold;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .player-health {
      font-size: 11px;
      color: #f66;
      min-width: 30px;
      text-align: right;
    }
    .player-health.healthy {
      color: #6f6;
    }
    .player-gold {
      font-size: 11px;
      color: #ffd700;
      min-width: 25px;
      text-align: right;
    }
    .player-streak {
      font-size: 10px;
      min-width: 20px;
      text-align: center;
    }
    .player-streak.win {
      color: #6f6;
    }
    .player-streak.loss {
      color: #f66;
    }

    /* Matchup Display */
    #matchup-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 3px solid #ffd700;
      border-radius: 15px;
      padding: 30px 50px;
      text-align: center;
      z-index: 1000;
      display: none;
    }
    #matchup-display.active {
      display: block;
    }
    .matchup-vs {
      font-size: 48px;
      color: #ffd700;
      margin: 20px 0;
    }
    .matchup-player {
      display: inline-block;
      padding: 15px 25px;
      margin: 0 20px;
      border-radius: 10px;
      font-size: 20px;
      font-weight: bold;
    }
    .matchup-result {
      margin-top: 20px;
      font-size: 24px;
      font-weight: bold;
    }
    .matchup-result.win {
      color: #4f4;
    }
    .matchup-result.loss {
      color: #f44;
    }
    .matchup-damage {
      font-size: 16px;
      color: #f88;
      margin-top: 10px;
    }

    /* Mode Selection */
    #mode-select {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      z-index: 2000;
    }
    #mode-select h1 {
      color: #ffd700;
      margin-bottom: 10px;
      font-size: 32px;
    }
    #mode-select h2 {
      color: #aaa;
      font-size: 16px;
      font-weight: normal;
      margin-bottom: 30px;
    }
    .mode-button {
      display: block;
      width: 100%;
      padding: 20px 40px;
      margin: 15px 0;
      font-size: 18px;
      font-weight: bold;
      border: 2px solid #666;
      border-radius: 10px;
      background: linear-gradient(145deg, #333, #444);
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-button:hover {
      background: linear-gradient(145deg, #444, #555);
      border-color: #ffd700;
      transform: scale(1.02);
    }
    .mode-button small {
      display: block;
      font-size: 12px;
      font-weight: normal;
      color: #aaa;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <span>Round: <span id="round">1</span></span>
    <span>Gold: <span id="gold">50</span></span>
    <span>Health: <span id="health">100</span></span>
    <span>Level: <span id="level">1</span></span>
    <span>Units: <span id="unitcap">0/3</span></span>
    <button id="fight">FIGHT!</button>
    <button id="reroll">REROLL (2g)</button>
    <button id="levelup">LEVEL UP (4g)</button>
  </div>
  <div id="game-container">
    <div id="synergies-panel">
      <h3>üê± Feline Factions</h3>
      <div id="synergies-list"></div>
    </div>
    <canvas id="board" width="950" height="680"></canvas>
  </div>
  <div id="bench-container">
    <div class="bench-slot" data-slot="0"></div>
    <div class="bench-slot" data-slot="1"></div>
    <div class="bench-slot" data-slot="2"></div>
    <div class="bench-slot" data-slot="3"></div>
    <div class="bench-slot" data-slot="4"></div>
    <div class="bench-slot" data-slot="5"></div>
    <div class="bench-slot" data-slot="6"></div>
    <div class="bench-slot" data-slot="7"></div>
    <div class="bench-slot" data-slot="8"></div>
  </div>
  <div id="shop"></div>
  <div id="sell-zone">üóëÔ∏è SELL UNIT</div>
  <div id="combatLog"></div>
  <div id="unit-tooltip"></div>

  <!-- Multiplayer UI -->
  <div id="scoreboard">
    <h3>üèÜ PLAYERS</h3>
    <div id="scoreboard-list"></div>
  </div>

  <div id="matchup-display">
    <div class="matchup-player" id="matchup-player-a">Player A</div>
    <div class="matchup-vs">‚öîÔ∏è</div>
    <div class="matchup-player" id="matchup-player-b">Player B</div>
    <div class="matchup-result" id="matchup-result"></div>
    <div class="matchup-damage" id="matchup-damage"></div>
  </div>

  <div id="mode-select">
    <h1>üê± FFFA</h1>
    <h2>Auto-Battler</h2>
    <button class="mode-button" id="btn-single">
      üéÆ Single Player
      <small>Classic mode - fight random enemies</small>
    </button>
    <button class="mode-button" id="btn-multiplayer">
      üë• 8-Player Battle
      <small>Fight 7 bot opponents in round-robin</small>
    </button>
    <button class="mode-button" id="btn-online" style="border-color: #4CAF50;">
      üåê Online Multiplayer
      <small>Play with real players + bot fillers</small>
    </button>
  </div>

  <!-- Lobby overlay -->
  <div id="lobby-screen" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:2000; display:none; flex-direction:column; align-items:center; justify-content:center; gap:16px; color:#fff; font-family:Arial,sans-serif;">
    <h1 style="color:#ffd700; margin:0;">üê± FFFA Online</h1>
    <div style="background:#222; border:2px solid #444; border-radius:10px; padding:20px; min-width:320px; text-align:center;">
      <div style="margin-bottom:12px;">
        <label style="font-size:12px; color:#aaa;">Server URL</label><br>
        <input id="server-url" type="text" value="" style="background:#333; color:#fff; border:1px solid #555; padding:6px 10px; border-radius:4px; width:260px; text-align:center; margin-top:4px;">
      </div>
      <div style="margin-bottom:12px;">
        <label style="font-size:12px; color:#aaa;">Your Name</label><br>
        <input id="player-name" type="text" value="Player" maxlength="16" style="background:#333; color:#fff; border:1px solid #555; padding:6px 10px; border-radius:4px; width:260px; text-align:center; margin-top:4px;">
      </div>
      <div style="margin-bottom:12px;">
        <label style="font-size:12px; color:#aaa;">Lobby Code (leave blank to create new)</label><br>
        <input id="lobby-code" type="text" maxlength="6" placeholder="ABC123" style="background:#333; color:#fff; border:1px solid #555; padding:6px 10px; border-radius:4px; width:260px; text-align:center; margin-top:4px; text-transform:uppercase;">
      </div>
      <div style="display:flex; gap:8px; justify-content:center; margin-top:16px;">
        <button id="btn-join-lobby" style="background:#4CAF50; padding:8px 20px; border:none; border-radius:6px; color:#fff; font-weight:bold; cursor:pointer;">Join / Create Lobby</button>
        <button id="btn-practice" style="background:#2196F3; padding:8px 20px; border:none; border-radius:6px; color:#fff; font-weight:bold; cursor:pointer;">Solo Practice</button>
      </div>
      <button id="btn-lobby-back" style="background:#666; padding:6px 16px; border:none; border-radius:4px; color:#fff; cursor:pointer; margin-top:12px; font-size:12px;">‚Üê Back</button>
    </div>
    <div id="lobby-info" style="display:none; background:#222; border:2px solid #4CAF50; border-radius:10px; padding:16px; min-width:320px; text-align:center;">
      <div style="font-size:14px; color:#aaa;">Lobby Code: <span id="lobby-id-display" style="color:#4CAF50; font-weight:bold; font-size:18px; letter-spacing:2px;"></span></div>
      <div id="lobby-players-list" style="margin:12px 0; text-align:left;"></div>
      <button id="btn-start-game" style="background:#ffd700; color:#000; padding:8px 24px; border:none; border-radius:6px; font-weight:bold; cursor:pointer; font-size:14px;">START GAME (fill bots)</button>
      <div style="font-size:11px; color:#666; margin-top:8px;">Share the lobby code with friends!</div>
    </div>
    <div id="lobby-status" style="color:#888; font-size:12px;"></div>
  </div>

  <!-- Phase timer display (for online mode) -->
  <div id="phase-timer-display" style="display:none; position:fixed; top:8px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); border:2px solid #ffd700; border-radius:8px; padding:6px 16px; z-index:500; color:#ffd700; font-weight:bold; font-size:16px; font-family:Arial,sans-serif;">
    <span id="phase-timer-label">Shop Phase</span> ‚Äî <span id="phase-timer-value">30</span>s
  </div>

  <script src="shared.js"></script>
  <script src="unit_animations_data.js"></script>
  <script>
    // ============================================================
    //  Shared data (UNIT_ROLES, TANK_ARMOR_BONUS, TANK_DAMAGE_REDUCTION,
    //  unitsData, allUnitIds, unitsByTier, shopOdds, rollShopUnitForLevel,
    //  factionSynergies, STAR_MULTIPLIERS, MANA_TO_CAST, hexDistance,
    //  getSellValue, getSynergyBonusesForBoard, createCombatUnit)
    //  is loaded from shared.js above.
    // ============================================================

    // Client-only rollShopUnit uses the legacy global playerLevel
    function rollShopUnit() {
      return rollShopUnitForLevel(playerLevel);
    }

    // ========== NETWORK MANAGER (Online Multiplayer) ==========
    const NetworkManager = {
      ws: null,
      isOnline: false,
      lobbyId: null,
      playerIndex: null,
      authToken: null,
      phaseTimerInterval: null,
      phaseTimeRemaining: 0,

      connect(serverUrl, name, lobbyId, practice) {
        try {
          this.ws = new WebSocket(serverUrl);
        } catch (e) {
          this.setStatus('Connection failed: ' + e.message);
          return;
        }

        this.ws.onopen = () => {
          this.setStatus('Connected! Joining...');
          this.send({
            type: 'join',
            name: name,
            lobbyId: lobbyId || undefined,
            practice: practice || false
          });
        };

        this.ws.onmessage = (e) => {
          let msg;
          try { msg = JSON.parse(e.data); } catch { return; }
          this.onMessage(msg);
        };

        this.ws.onclose = () => {
          this.setStatus('Disconnected. Refresh to reconnect.');
          if (this.isOnline) {
            // Try to reconnect
            setTimeout(() => this.tryReconnect(), 2000);
          }
        };

        this.ws.onerror = () => {
          this.setStatus('Connection error');
        };
      },

      send(msg) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify(msg));
        }
      },

      tryReconnect() {
        if (!this.lobbyId || !this.authToken) return;
        const url = document.getElementById('server-url').value;
        try {
          this.ws = new WebSocket(url);
          this.ws.onopen = () => {
            this.send({
              type: 'reconnect',
              lobbyId: this.lobbyId,
              playerIndex: this.playerIndex,
              authToken: this.authToken
            });
          };
          this.ws.onmessage = (e) => {
            let msg;
            try { msg = JSON.parse(e.data); } catch { return; }
            this.onMessage(msg);
          };
          this.ws.onclose = () => {
            setTimeout(() => this.tryReconnect(), 3000);
          };
        } catch (e) { /* retry later */ }
      },

      setStatus(text) {
        const el = document.getElementById('lobby-status');
        if (el) el.textContent = text;
      },

      onMessage(msg) {
        switch (msg.type) {
          case 'lobby_state': this.handleLobbyState(msg); break;
          case 'game_start': this.handleGameStart(msg); break;
          case 'state_sync': this.handleStateSync(msg); break;
          case 'shop_update': this.handleShopUpdate(msg); break;
          case 'board_update': this.handleBoardUpdate(msg); break;
          case 'phase_change': this.handlePhaseChange(msg); break;
          case 'matchup': this.handleMatchup(msg); break;
          case 'combat_result': this.handleCombatResult(msg); break;
          case 'scoreboard': this.handleScoreboard(msg); break;
          case 'elimination': this.handleElimination(msg); break;
          case 'game_over': this.handleGameOver(msg); break;
          case 'error': this.handleError(msg); break;
        }
      },

      handleLobbyState(msg) {
        this.lobbyId = msg.lobbyId;
        if (msg.you !== undefined) this.playerIndex = msg.you;
        if (msg.authToken) {
          this.authToken = msg.authToken;
          sessionStorage.setItem('fffa_auth', JSON.stringify({
            lobbyId: this.lobbyId,
            playerIndex: this.playerIndex,
            authToken: this.authToken
          }));
        }

        // Show lobby info
        const lobbyInfo = document.getElementById('lobby-info');
        lobbyInfo.style.display = 'block';
        document.getElementById('lobby-id-display').textContent = msg.lobbyId;

        const list = document.getElementById('lobby-players-list');
        list.innerHTML = msg.players.map(p =>
          `<div style="padding:4px 8px; margin:2px 0; background:${p.isBot ? '#333' : '#1a3a1a'}; border-radius:4px; font-size:13px;">
            ${p.isBot ? 'ü§ñ' : 'üë§'} ${p.name} ${p.id === this.playerIndex ? '(you)' : ''}
          </div>`
        ).join('');

        this.setStatus(`${msg.players.length}/8 players in lobby`);
      },

      handleGameStart(msg) {
        this.isOnline = true;

        // Hide lobby, show game
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('mode-select').style.display = 'none';

        // Store player info
        GameState.mode = 'online';

        // Set up PLAYER_NAMES and PLAYER_COLORS from server data
        msg.players.forEach((p, i) => {
          if (typeof PLAYER_NAMES !== 'undefined') PLAYER_NAMES[i] = p.name;
        });
      },

      handleStateSync(msg) {
        this.playerIndex = msg.you;

        // Sync to legacy globals
        const p = msg.player;
        gold = p.gold;
        health = p.health;
        playerLevel = p.level;
        playerBoard = p.board;
        bench = p.bench;
        shopUnits = p.shop;
        currentRound = msg.round;

        // Initialize GameState players from scoreboard
        GameState.mode = 'online';
        GameState.round = msg.round;
        GameState.phase = msg.phase;
        GameState.players = msg.scoreboard.map(s => {
          const pl = new Player(s.id, s.name, s.isBot);
          pl.health = s.health;
          pl.gold = s.gold;
          pl.level = s.level;
          pl.isAlive = s.isAlive;
          pl.wins = s.wins;
          pl.losses = s.losses;
          pl.streak = s.streak;
          pl.placement = s.placement;
          pl.color = s.color;
          return pl;
        });
        GameState.humanPlayerIndex = this.playerIndex;

        // Show scoreboard
        document.getElementById('scoreboard').classList.add('active');

        // Render everything
        renderShop();
        renderBoard();
        renderBench();
        setupBenchEvents();
        updateUI();
        renderSynergies();
        renderScoreboard();

        // Override fight button for online
        document.getElementById('fight').onclick = function() {
          if (combatState !== 'idle') return;
          NetworkManager.send({ type: 'ready_combat' });
          document.getElementById('fight').textContent = '‚è≥ WAITING...';
          document.getElementById('fight').disabled = true;
        };

        // Start animation loop
        requestAnimationFrame(animationLoop);

        // Show round banner
        roundBanner = {
          text: `ROUND ${msg.round}`,
          subtext: 'Online Match',
          color: '#4CAF50',
          startTime: Date.now(),
          duration: 2000
        };
      },

      handleShopUpdate(msg) {
        shopUnits = msg.shop;
        gold = msg.gold;
        renderShop();
        updateUI();
      },

      handleBoardUpdate(msg) {
        playerBoard = msg.board;
        bench = msg.bench;
        gold = msg.gold;
        playerLevel = msg.level;
        shopUnits = msg.shop;
        renderBoard();
        renderBench();
        renderSynergies();
        updateUI();
      },

      handlePhaseChange(msg) {
        if (msg.phase === 'shop') {
          combatState = 'idle';
          combatUnits = [];
          currentRound = msg.round;

          // Re-enable fight button
          const fightBtn = document.getElementById('fight');
          fightBtn.textContent = '‚öîÔ∏è READY';
          fightBtn.disabled = false;

          // Start phase timer
          this.startPhaseTimer(msg.timer, 'Shop Phase');

          roundBanner = {
            text: `ROUND ${msg.round}`,
            subtext: `Shop Phase ‚Äî ${msg.timer}s`,
            color: '#fff',
            startTime: Date.now(),
            duration: 2000
          };
          renderBoard();
        } else if (msg.phase === 'combat') {
          this.startPhaseTimer(msg.timer, 'Combat');
          document.getElementById('fight').textContent = '‚öîÔ∏è FIGHTING';
          document.getElementById('fight').disabled = true;
        } else if (msg.phase === 'results') {
          this.startPhaseTimer(msg.timer || 5, 'Results');
        }
      },

      handleMatchup(msg) {
        // Receive armies and play animated combat
        combatState = 'combat';
        preCombatBoard = { ...playerBoard };

        // Build combatUnits from the armies
        const allArmyUnits = [...msg.armyA, ...msg.armyB];

        combatUnits = allArmyUnits.map(u => ({
          ...u,
          maxHp: u.maxHp,
          hp: u.hp || u.maxHp,
          statusEffects: [],
          attackedTargets: new Set(),
          hasCast: false,
          hasRevived: false,
          lastActionTime: 0,
          lastMoveTime: 0,
          actionCooldown: 1000 / (u.speed || 1),
          moveCooldown: 600 / (u.speed || 1),
          mana: 0,
          maxMana: MANA_TO_CAST
        }));

        // Show matchup banner
        roundBanner = {
          text: `VS ${msg.opponent.name}`,
          subtext: 'Combat!',
          color: msg.opponent.color || '#f44',
          startTime: Date.now(),
          duration: 2000
        };

        renderBoard();

        // Run client-side animated combat (cosmetic only ‚Äî server result is canonical)
        combatStartTime = performance.now();
      },

      handleCombatResult(msg) {
        // Apply canonical results from server
        // The results contain all matchups; find ours
        const myResult = msg.results.find(r =>
          r.playerA === this.playerIndex || r.playerB === this.playerIndex
        );

        if (myResult) {
          const won = myResult.winner === this.playerIndex;
          const damage = myResult.damage;

          roundBanner = {
            text: won ? 'üèÜ VICTORY' : 'üíÄ DEFEAT',
            subtext: won ? 'Well played!' : `${damage} damage taken`,
            color: won ? '#4f4' : '#f44',
            startTime: Date.now(),
            duration: 2500
          };
        }

        // End combat visuals
        setTimeout(() => {
          combatState = 'idle';
          combatUnits = [];
          if (preCombatBoard) {
            playerBoard = preCombatBoard;
            preCombatBoard = null;
          }
          renderBoard();
        }, 500);
      },

      handleScoreboard(msg) {
        // Update GameState players from scoreboard data
        msg.players.forEach(s => {
          if (GameState.players[s.id]) {
            const p = GameState.players[s.id];
            p.health = s.health;
            p.gold = s.gold;
            p.isAlive = s.isAlive;
            p.wins = s.wins;
            p.losses = s.losses;
            p.streak = s.streak;
            p.placement = s.placement;
          }
        });

        // Update own health
        const me = msg.players.find(p => p.id === this.playerIndex);
        if (me) {
          health = me.health;
          gold = me.gold;
          updateUI();
        }

        renderScoreboard();
      },

      handleElimination(msg) {
        if (msg.playerId === this.playerIndex) {
          roundBanner = {
            text: 'üíÄ ELIMINATED',
            subtext: `You placed #${msg.placement}`,
            color: '#f44',
            startTime: Date.now(),
            duration: 4000
          };
          renderBoard();
        } else {
          roundBanner = {
            text: `${msg.playerName} Eliminated`,
            subtext: `Placed #${msg.placement}`,
            color: '#888',
            startTime: Date.now(),
            duration: 2000
          };
        }
      },

      handleGameOver(msg) {
        this.stopPhaseTimer();
        const isWinner = msg.winner && msg.winner.id === this.playerIndex;

        roundBanner = {
          text: isWinner ? 'üèÜ YOU WIN!' : `${msg.winner?.name || 'Nobody'} Wins!`,
          subtext: `Final placement: #${msg.placements.find(p => p.id === this.playerIndex)?.placement || '?'}`,
          color: isWinner ? '#ffd700' : '#aaa',
          startTime: Date.now(),
          duration: 10000
        };
        renderBoard();

        setTimeout(() => {
          if (confirm('Game over! Play again?')) {
            location.reload();
          }
        }, 3000);
      },

      handleError(msg) {
        console.warn('Server error:', msg.message);
        // Could show a toast notification
      },

      // Phase timer
      startPhaseTimer(seconds, label) {
        this.stopPhaseTimer();
        this.phaseTimeRemaining = seconds;

        const timerDisplay = document.getElementById('phase-timer-display');
        const timerLabel = document.getElementById('phase-timer-label');
        const timerValue = document.getElementById('phase-timer-value');

        timerDisplay.style.display = 'block';
        timerLabel.textContent = label;
        timerValue.textContent = seconds;

        this.phaseTimerInterval = setInterval(() => {
          this.phaseTimeRemaining--;
          timerValue.textContent = Math.max(0, this.phaseTimeRemaining);
          if (this.phaseTimeRemaining <= 0) {
            this.stopPhaseTimer();
          }
        }, 1000);
      },

      stopPhaseTimer() {
        clearInterval(this.phaseTimerInterval);
        this.phaseTimerInterval = null;
        const timerDisplay = document.getElementById('phase-timer-display');
        if (timerDisplay) timerDisplay.style.display = 'none';
      }
    };

    // ========== TOOLTIP SYSTEM ==========
    const tooltip = document.getElementById('unit-tooltip');
    let tooltipVisible = false;

    function getAbilityDescription(ability) {
      if (!ability || !ability.effect) return ability?.name || 'No ability';

      const e = ability.effect;
      const parts = [];

      // Gold effects
      if (e.gold_per_round) parts.push(`+${e.gold_per_round} gold per round`);
      if (e.gold_per_attack) parts.push(`+${e.gold_per_attack} gold per attack`);
      if (e.gold_steal) parts.push(`Steal ${e.gold_steal} gold${e.once_per_target ? ' (once per target)' : ''}`);
      if (e.gold_drop_chance) parts.push(`${e.gold_drop_chance}% chance for +${e.gold_drop} gold`);

      // Damage effects
      if (e.damage_mult) parts.push(`${Math.round((e.damage_mult - 1) * 100)}% bonus damage`);
      if (e.aoe_damage_mult) parts.push(`${Math.round(e.aoe_damage_mult * 100)}% AoE damage`);
      if (e.crit_chance) parts.push(`+${e.crit_chance}% crit chance`);
      if (e.crit_mult) parts.push(`${e.crit_mult}x crit damage`);
      if (e.execute_threshold) parts.push(`Execute enemies below ${e.execute_threshold}% HP`);

      // Healing
      if (e.self_heal) parts.push(`Heal ${e.self_heal}% of max HP`);
      if (e.self_heal_on_damage) parts.push(`${e.self_heal_on_damage}% lifesteal`);

      // CC effects
      if (e.stun) parts.push(`Stun for ${e.stun}s`);
      if (e.aoe_stun) parts.push(`AoE stun for ${e.aoe_stun.duration || e.aoe_stun}s`);
      if (e.silence) parts.push(`Silence for ${e.silence}s`);
      if (e.root) parts.push(`Root for ${e.root.duration}s`);
      if (e.attack_speed_slow) parts.push(`Slow attack speed ${e.attack_speed_slow}%`);
      if (e.aoe_slow) parts.push(`AoE slow ${e.aoe_slow.percent || e.aoe_slow}%`);

      // DoT effects
      if (e.poison) parts.push(`Poison: ${e.poison.damage} dmg/s for ${e.poison.duration}s`);
      if (e.bleed) parts.push(`Bleed: ${e.bleed.damage} dmg over ${e.bleed.duration}s`);

      // Defensive
      if (e.armor) parts.push(`+${e.armor} armor`);
      if (e.damage_reduction) parts.push(`${e.damage_reduction}% damage reduction`);
      if (e.ally_shield) parts.push(`Shield allies for ${e.ally_shield}`);

      // Buffs
      if (e.ally_attack_speed) parts.push(`+${e.ally_attack_speed}% ally attack speed`);
      if (e.ally_damage_amp) parts.push(`+${e.ally_damage_amp}% ally damage`);
      if (e.ally_armor) parts.push(`+${e.ally_armor} armor to allies`);
      if (e.ally_crit) parts.push(`+${e.ally_crit}% crit to allies`);

      return parts.length > 0 ? parts.join('. ') + '.' : 'Special effect';
    }

    function showTooltip(unitId, x, y) {
      const unit = unitsData[unitId];
      if (!unit) return;

      const synergy = factionSynergies[unit.faction];
      const factionColor = synergy?.color || '#888';
      const factionName = synergy?.name || unit.faction;
      const factionIcon = synergy?.icon || 'üåê';

      // Role styling
      const roleIcons = { Tank: 'üõ°Ô∏è', Ranged: 'üèπ', Melee: '‚öîÔ∏è' };
      const roleColors = { Tank: '#4a9eff', Ranged: '#22c55e', Melee: '#ef4444' };
      const role = unit.role || 'Melee';
      const roleIcon = roleIcons[role] || '‚öîÔ∏è';
      const roleColor = roleColors[role] || '#888';
      const roleBonus = role === 'Tank' ? `+${TANK_ARMOR_BONUS}% Armor, +${TANK_DAMAGE_REDUCTION}% DR` : '';

      const triggerClass = unit.ability?.trigger === 'passive' ? 'trigger-passive' :
                          unit.ability?.trigger === 'on-attack' ? 'trigger-on-attack' : 'trigger-on-cast';

      tooltip.innerHTML = `
        <div class="tooltip-header">
          <span class="tooltip-icon">${unit.icon}</span>
          <div class="tooltip-title">
            <div class="tooltip-name">${unit.name}</div>
            <div style="display: flex; gap: 6px; flex-wrap: wrap; align-items: center;">
              <span class="tooltip-faction" style="background: ${factionColor}33; color: ${factionColor}; border: 1px solid ${factionColor}55;">
                ${factionIcon} ${factionName}
              </span>
              <span class="tooltip-faction" style="background: ${roleColor}33; color: ${roleColor}; border: 1px solid ${roleColor}55;">
                ${roleIcon} ${role}
              </span>
            </div>
          </div>
          <div class="tooltip-cost">${unit.cost}</div>
        </div>
        <div class="tooltip-body">
          ${roleBonus ? `<div style="font-size: 11px; color: ${roleColor}; margin-bottom: 8px; padding: 4px 8px; background: ${roleColor}22; border-radius: 4px; text-align: center;">${roleIcon} Tank Bonus: ${roleBonus}</div>` : ''}
          <div class="tooltip-stats">
            <div class="tooltip-stat">
              <span class="stat-icon">‚ù§Ô∏è</span>
              <span class="stat-label">HP</span>
              <span class="stat-value">${unit.stats.hp}</span>
            </div>
            <div class="tooltip-stat">
              <span class="stat-icon">‚öîÔ∏è</span>
              <span class="stat-label">ATK</span>
              <span class="stat-value">${unit.stats.attack}</span>
            </div>
            <div class="tooltip-stat">
              <span class="stat-icon">‚ö°</span>
              <span class="stat-label">SPD</span>
              <span class="stat-value">${unit.stats.speed.toFixed(1)}</span>
            </div>
            <div class="tooltip-stat">
              <span class="stat-icon">üéØ</span>
              <span class="stat-label">RNG</span>
              <span class="stat-value">${unit.stats.range}</span>
            </div>
          </div>
          ${unit.ability ? `
          <div class="tooltip-ability">
            <div class="ability-header">
              <span class="ability-name">‚ú® ${unit.ability.name}</span>
              <span class="ability-trigger ${triggerClass}">${unit.ability.trigger}</span>
            </div>
            <div class="ability-desc">${getAbilityDescription(unit.ability)}</div>
          </div>
          ` : ''}
        </div>
      `;

      // Position tooltip
      const tooltipRect = tooltip.getBoundingClientRect();
      const padding = 15;

      // Default: show to the right of cursor
      let left = x + padding;
      let top = y - 20;

      // Adjust if would go off screen
      if (left + 280 > window.innerWidth) {
        left = x - 280 - padding;
      }
      if (top + 250 > window.innerHeight) {
        top = window.innerHeight - 260;
      }
      if (top < 10) top = 10;

      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      tooltip.style.display = 'block';
      tooltipVisible = true;
    }

    function hideTooltip() {
      tooltip.style.display = 'none';
      tooltipVisible = false;
    }

    // Track hovered unit on board
    let hoveredBoardUnit = null;

    // Animation utility functions
    function addAttackPulse(x, y, color, radius = 30) {
      visualEffects.push({
        type: 'attackPulse',
        x: x,
        y: y,
        color: color,
        radius: radius,
        startTime: Date.now(),
        duration: 400
      });
    }

    function addDeathEffect(x, y, color, radius = 40) {
      visualEffects.push({
        type: 'deathEffect',
        x: x,
        y: y,
        color: color,
        radius: radius,
        startTime: Date.now(),
        duration: 600
      });
    }

    function addAbilityEffect(x, y, color, radius = 50) {
      visualEffects.push({
        type: 'abilityEffect',
        x: x,
        y: y,
        color: color,
        radius: radius,
        startTime: Date.now(),
        duration: 800
      });
    }

    // Enhanced combat effects
    function addCombatHitEffect(attacker, target, damage, isCrit = false) {
      const attackerHex = boardHexes.find(h => getHexKey(h) === attacker.hexKey);
      const targetHex = boardHexes.find(h => getHexKey(h) === target.hexKey);

      if (attackerHex && targetHex) {
        const attackerPos = hexToPixel(attackerHex);
        const targetPos = hexToPixel(targetHex);

        // Add attack pulse effect
        addAttackPulse(attackerPos.x, attackerPos.y, attacker.color, 40);

        // Add attack particles
        addAttackParticles(attackerPos.x, attackerPos.y, attacker.color);

        // Add attack line effect
        visualEffects.push({
          type: 'attackLine',
          x: attackerPos.x,
          y: attackerPos.y,
          x2: targetPos.x,
          y2: targetPos.y,
          color: attacker.color,
          startTime: Date.now(),
          duration: 300
        });

        // Add damage number
        addDamageNumber(target.hexKey, damage, isCrit);

        // Add hit effect at target location
        visualEffects.push({
          type: 'hitEffect',
          x: targetPos.x,
          y: targetPos.y,
          color: attacker.color,
          startTime: Date.now(),
          duration: 400
        });
      }
    }

    function addHitEffect(x, y, color) {
      visualEffects.push({
        type: 'hitEffect',
        x: x,
        y: y,
        color: color,
        startTime: Date.now(),
        duration: 400
      });
    }

    // ========== FACTION SYNERGY SYSTEM ==========
    // factionSynergies loaded from shared.js

    // Calculate active synergies based on player board
    function calculateSynergies() {
      const factionCounts = {};
      const activeSynergies = {};

      // Count units per faction (handle new {id, stars} format)
      Object.values(playerBoard).forEach(unitData => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const unit = unitsData[unitId];
        if (unit) {
          const faction = unit.faction;
          factionCounts[faction] = (factionCounts[faction] || 0) + 1;
        }
      });

      // Determine active bonuses
      Object.entries(factionSynergies).forEach(([faction, synergy]) => {
        const count = factionCounts[faction] || 0;
        let activeThreshold = 0;
        let activeBonus = null;

        for (const threshold of synergy.thresholds) {
          if (count >= threshold) {
            activeThreshold = threshold;
            activeBonus = synergy.bonuses[threshold];
          }
        }

        activeSynergies[faction] = {
          count,
          activeThreshold,
          activeBonus,
          synergy
        };
      });

      return { factionCounts, activeSynergies };
    }

    // Render synergies panel
    function renderSynergies() {
      const { activeSynergies } = calculateSynergies();
      const list = document.getElementById('synergies-list');
      list.innerHTML = '';

      // Sort: active synergies first, then by count
      const sorted = Object.entries(activeSynergies)
        .sort((a, b) => {
          if (a[1].activeBonus && !b[1].activeBonus) return -1;
          if (!a[1].activeBonus && b[1].activeBonus) return 1;
          return b[1].count - a[1].count;
        });

      sorted.forEach(([faction, data]) => {
        if (data.count === 0) return; // Don't show factions with no units

        const div = document.createElement('div');
        div.className = `synergy-item ${data.activeBonus ? 'active' : 'inactive'}`;

        // Build threshold indicators
        const thresholds = data.synergy.thresholds.map(t =>
          `<span class="threshold ${data.count >= t ? 'active' : 'inactive'}">${t}</span>`
        ).join('');

        div.innerHTML = `
          <span class="synergy-icon">${data.synergy.icon}</span>
          <div class="synergy-info">
            <div class="synergy-name" style="color: ${data.synergy.color}">${data.synergy.name}</div>
            <div class="synergy-count">${thresholds} (${data.count})</div>
            ${data.activeBonus ? `<div class="synergy-bonus">${data.activeBonus.description}</div>` : ''}
          </div>
        `;
        list.appendChild(div);
      });

      // If no synergies active, show hint
      if (list.children.length === 0) {
        list.innerHTML = '<div style="text-align: center; color: #666; font-size: 12px; padding: 20px;">Place units to activate synergies!</div>';
      }
    }

    // ========== 8-PLAYER MULTIPLAYER SYSTEM ==========
    const PLAYER_COLORS = [
      '#4CAF50', // Green - Human player
      '#F44336', // Red
      '#2196F3', // Blue
      '#FF9800', // Orange
      '#9C27B0', // Purple
      '#00BCD4', // Cyan
      '#FFEB3B', // Yellow
      '#E91E63'  // Pink
    ];

    const PLAYER_NAMES = [
      'You', 'Whiskers', 'Mittens', 'Shadow',
      'Luna', 'Felix', 'Cleo', 'Tiger'
    ];

    // Player class - encapsulates all player state
    class Player {
      constructor(id, name, isBot = false) {
        this.id = id;
        this.name = name;
        this.color = PLAYER_COLORS[id];
        this.isBot = isBot;
        this.gold = 50;
        this.health = 100;
        this.level = 1;
        this.board = {};        // hexKey -> {id, stars}
        this.bench = Array(9).fill(null);
        this.shop = [];
        this.synergies = {};    // Cached synergy bonuses
        this.isAlive = true;
        this.wins = 0;
        this.losses = 0;
        this.streak = 0;        // Positive = win streak, negative = loss streak
        this.placement = 0;     // Final placement (1-8)
      }

      getUnitCap() {
        return this.level + 2;
      }

      getBoardUnitCount() {
        return Object.keys(this.board).length;
      }

      canAfford(cost) {
        return this.gold >= cost;
      }

      spendGold(amount) {
        this.gold = Math.max(0, this.gold - amount);
      }

      earnGold(amount) {
        this.gold += amount;
      }

      takeDamage(amount) {
        this.health = Math.max(0, this.health - amount);
        if (this.health <= 0) {
          this.isAlive = false;
        }
      }

      // Roll a shop based on player level
      rollShop() {
        this.shop = Array(5).fill().map(() => rollShopUnitForLevel(this.level));
      }

      // Calculate synergies from board
      calculateSynergies() {
        const factionCounts = {};
        const coatCounts = {};

        Object.values(this.board).forEach(unitData => {
          const unitId = typeof unitData === 'object' ? unitData.id : unitData;
          const unit = unitsData[unitId];
          if (unit) {
            factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
            if (unit.coat) {
              coatCounts[unit.coat] = (coatCounts[unit.coat] || 0) + 1;
            }
          }
        });

        this.synergies = { factions: factionCounts, coats: coatCounts };
        return this.synergies;
      }
    }

    // Game state manager for 8-player mode
    const GameState = {
      mode: 'single',           // 'single' or 'multiplayer'
      round: 1,
      phase: 'shop',            // 'shop', 'combat', 'settlement'
      players: [],              // Array of Player objects
      humanPlayerIndex: 0,      // Index of human player
      matchups: [],             // Current round matchups: [{playerA: idx, playerB: idx, winner: null}]
      currentMatchupIndex: 0,   // Which matchup is being displayed
      eliminationOrder: [],     // Track order of elimination for placements
      roundRobinSchedule: [],   // Pre-generated schedule

      // Initialize 8-player game
      init(humanCount = 1) {
        this.mode = 'multiplayer';
        this.round = 1;
        this.phase = 'shop';
        this.players = [];
        this.humanPlayerIndex = 0;
        this.eliminationOrder = [];

        // Create players (first one is human, rest are bots)
        for (let i = 0; i < 8; i++) {
          const isBot = i >= humanCount;
          const player = new Player(i, PLAYER_NAMES[i], isBot);
          player.rollShop();
          this.players.push(player);
        }

        // Generate round-robin schedule
        this.generateRoundRobinSchedule();

        return this.players[this.humanPlayerIndex];
      },

      // Generate round-robin schedule for 8 players
      // Each round: 4 matches, each player fights once
      // Full cycle: 7 rounds for everyone to fight everyone
      generateRoundRobinSchedule() {
        this.roundRobinSchedule = [];
        const n = 8;

        // Circle method for round-robin tournament
        // Fix player 0, rotate others
        for (let round = 0; round < n - 1; round++) {
          const matches = [];
          const rotation = [0];

          // Build rotation array
          for (let i = 1; i < n; i++) {
            const pos = (i - 1 + round) % (n - 1) + 1;
            rotation.push(pos);
          }

          // Pair up: first with last, second with second-last, etc.
          for (let i = 0; i < n / 2; i++) {
            matches.push({
              playerA: rotation[i],
              playerB: rotation[n - 1 - i]
            });
          }

          this.roundRobinSchedule.push(matches);
        }
      },

      // Get matchups for current round (handles dead players)
      getMatchupsForRound() {
        const scheduleIndex = (this.round - 1) % 7;
        const baseMatchups = this.roundRobinSchedule[scheduleIndex];

        // Filter to only alive players and create ghost army matchups
        const alivePlayers = this.players.filter(p => p.isAlive).map(p => p.id);

        if (alivePlayers.length <= 1) {
          return []; // Game over
        }

        const matchups = [];
        const paired = new Set();

        // Try to use scheduled matchups first
        for (const match of baseMatchups) {
          const aAlive = this.players[match.playerA].isAlive;
          const bAlive = this.players[match.playerB].isAlive;

          if (aAlive && bAlive && !paired.has(match.playerA) && !paired.has(match.playerB)) {
            matchups.push({
              playerA: match.playerA,
              playerB: match.playerB,
              winner: null,
              combatLog: [],
              damage: 0
            });
            paired.add(match.playerA);
            paired.add(match.playerB);
          }
        }

        // Handle unpaired alive players (fight ghost of random opponent)
        const unpaired = alivePlayers.filter(id => !paired.has(id));
        for (const playerId of unpaired) {
          // Fight ghost army of random alive opponent
          const opponents = alivePlayers.filter(id => id !== playerId);
          if (opponents.length > 0) {
            const ghostOpponent = opponents[Math.floor(Math.random() * opponents.length)];
            matchups.push({
              playerA: playerId,
              playerB: ghostOpponent,
              isGhostMatch: true,  // Mark that playerB won't take damage
              winner: null,
              combatLog: [],
              damage: 0
            });
          }
        }

        this.matchups = matchups;
        return matchups;
      },

      // Get human player
      getHumanPlayer() {
        return this.players[this.humanPlayerIndex];
      },

      // Get alive players count
      getAliveCount() {
        return this.players.filter(p => p.isAlive).length;
      },

      // Check if game is over
      isGameOver() {
        return this.getAliveCount() <= 1;
      },

      // Get winner
      getWinner() {
        const alive = this.players.filter(p => p.isAlive);
        return alive.length === 1 ? alive[0] : null;
      },

      // Process eliminations after combat
      processEliminations() {
        this.players.forEach(player => {
          if (!player.isAlive && player.placement === 0) {
            player.placement = 8 - this.eliminationOrder.length;
            this.eliminationOrder.push(player.id);
          }
        });
      },

      // Advance to next round
      nextRound() {
        this.round++;
        this.phase = 'shop';
        this.currentMatchupIndex = 0;

        // Refresh shops for all alive players
        this.players.forEach(player => {
          if (player.isAlive) {
            player.rollShop();
          }
        });
      }
    };

    // ========== BOT AI SYSTEM (Medium Difficulty) ==========
    const BotAI = {
      // Run bot turn: buy units, level up, place on board
      takeTurn(player) {
        if (!player.isBot || !player.isAlive) return;

        // 1. Decide whether to level up or save
        this.decideLevelUp(player);

        // 2. Buy units from shop
        this.buyUnits(player);

        // 3. Position units on board
        this.positionUnits(player);

        // 4. Maybe reroll if gold is high and looking for upgrades
        this.decideReroll(player);
      },

      // Level up decision: level if gold > 50 and can benefit
      decideLevelUp(player) {
        const levelUpCost = player.level < 9 ? 4 : 999;
        // Level up if: plenty of gold AND bench has units waiting
        const benchCount = player.bench.filter(u => u !== null).length;
        const boardCount = player.getBoardUnitCount();

        if (player.gold >= levelUpCost + 10 && boardCount >= player.getUnitCap() && player.level < 9) {
          player.spendGold(levelUpCost);
          player.level++;
        }
      },

      // Buy units that complete synergies or can upgrade
      buyUnits(player) {
        const shop = player.shop;
        if (!shop || shop.length === 0) return;

        // Count units we have for upgrade potential
        const unitCounts = this.countUnits(player);

        // Get current faction counts
        const factionCounts = {};
        Object.values(player.board).forEach(u => {
          const unit = unitsData[typeof u === 'object' ? u.id : u];
          if (unit) factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
        });
        player.bench.forEach(u => {
          if (u) {
            const unit = unitsData[u.id];
            if (unit) factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
          }
        });

        // Score and buy units
        for (let i = 0; i < shop.length; i++) {
          const unitId = shop[i];
          if (!unitId) continue;

          const unit = unitsData[unitId];
          if (!unit || !player.canAfford(unit.cost)) continue;

          // Find empty bench slot
          const emptySlot = player.bench.findIndex(s => s === null);
          if (emptySlot === -1) break; // Bench full

          // Calculate buy priority
          let priority = 0;

          // High priority: can upgrade (have 2 copies already)
          const count = unitCounts[unitId] || 0;
          if (count >= 2) priority += 50;
          else if (count >= 1) priority += 20;

          // Medium priority: completes synergy threshold
          const factionCount = factionCounts[unit.faction] || 0;
          if (factionCount === 1 || factionCount === 3 || factionCount === 5) {
            priority += 30; // One away from threshold
          }

          // Lower priority for expensive units early
          if (GameState.round <= 5 && unit.cost >= 4) {
            priority -= 20;
          }

          // Buy if priority is decent or we have lots of gold
          if (priority >= 20 || (player.gold >= 30 && unit.cost <= 2)) {
            player.spendGold(unit.cost);
            player.bench[emptySlot] = { id: unitId, stars: 1 };
            shop[i] = null; // Remove from shop

            // Check for merge
            this.checkAndMerge(player, unitId, 1);

            // Update counts
            unitCounts[unitId] = (unitCounts[unitId] || 0) + 1;
            factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
          }
        }
      },

      // Count all units (board + bench) by ID and star level
      countUnits(player) {
        const counts = {};

        Object.values(player.board).forEach(u => {
          const id = typeof u === 'object' ? u.id : u;
          const stars = typeof u === 'object' ? u.stars : 1;
          const key = `${id}_${stars}`;
          counts[id] = (counts[id] || 0) + 1;
          counts[key] = (counts[key] || 0) + 1;
        });

        player.bench.forEach(u => {
          if (u) {
            const key = `${u.id}_${u.stars}`;
            counts[u.id] = (counts[u.id] || 0) + 1;
            counts[key] = (counts[key] || 0) + 1;
          }
        });

        return counts;
      },

      // Check and perform merges for bot
      checkAndMerge(player, unitId, starLevel) {
        if (starLevel >= 3) return;

        let matches = [];

        // Check board
        Object.entries(player.board).forEach(([key, unit]) => {
          if (unit.id === unitId && unit.stars === starLevel) {
            matches.push({ location: 'board', key });
          }
        });

        // Check bench
        player.bench.forEach((unit, index) => {
          if (unit && unit.id === unitId && unit.stars === starLevel) {
            matches.push({ location: 'bench', index });
          }
        });

        if (matches.length >= 3) {
          // Perform merge
          const newStars = starLevel + 1;
          let firstBoardKey = null;
          let firstBenchIndex = null;

          matches.slice(0, 3).forEach(match => {
            if (match.location === 'board') {
              if (!firstBoardKey) firstBoardKey = match.key;
              else delete player.board[match.key];
            } else {
              if (firstBenchIndex === null && !firstBoardKey) firstBenchIndex = match.index;
              else player.bench[match.index] = null;
            }
          });

          if (firstBoardKey) {
            player.board[firstBoardKey] = { id: unitId, stars: newStars };
          } else if (firstBenchIndex !== null) {
            player.bench[firstBenchIndex] = { id: unitId, stars: newStars };
          }

          // Recursively check for next level merge
          this.checkAndMerge(player, unitId, newStars);
        }
      },

      // Position units: tanks front (row 4), damage back (rows 5-7)
      positionUnits(player) {
        // Get all units from bench that can be placed
        const boardCount = player.getBoardUnitCount();
        const unitCap = player.getUnitCap();

        if (boardCount >= unitCap) return;

        // Get available hexes in player zone (rows 4-7)
        const frontRow = [4];
        const backRows = [5, 6, 7];

        const occupiedHexes = new Set(Object.keys(player.board));

        // Categorize bench units by role
        const benchUnits = player.bench
          .map((u, idx) => u ? { ...u, benchIndex: idx } : null)
          .filter(u => u !== null);

        // Sort: tanks (Maine Coon, high HP) first, then damage dealers
        benchUnits.sort((a, b) => {
          const unitA = unitsData[a.id];
          const unitB = unitsData[b.id];
          const tankFactions = ['MaineCoon', 'Persian', 'Ragdoll'];

          const aIsTank = tankFactions.includes(unitA?.faction) || (unitA?.stats?.hp > 700);
          const bIsTank = tankFactions.includes(unitB?.faction) || (unitB?.stats?.hp > 700);

          if (aIsTank && !bIsTank) return -1;
          if (!aIsTank && bIsTank) return 1;
          return (unitB?.cost || 0) - (unitA?.cost || 0); // Higher cost first
        });

        // Place units
        let placed = 0;
        for (const benchUnit of benchUnits) {
          if (boardCount + placed >= unitCap) break;

          const unit = unitsData[benchUnit.id];
          const tankFactions = ['MaineCoon', 'Persian', 'Ragdoll'];
          const isTank = tankFactions.includes(unit?.faction) || (unit?.stats?.hp > 700);

          // Find hex
          let targetHex = null;
          const rows = isTank ? frontRow : backRows;

          for (const row of [...rows, ...frontRow, ...backRows]) {
            for (let col = 0; col < 7; col++) {
              const key = `${col},${row}`;
              if (!occupiedHexes.has(key)) {
                targetHex = key;
                break;
              }
            }
            if (targetHex) break;
          }

          if (targetHex) {
            player.board[targetHex] = { id: benchUnit.id, stars: benchUnit.stars };
            player.bench[benchUnit.benchIndex] = null;
            occupiedHexes.add(targetHex);
            placed++;
          }
        }
      },

      // Reroll decision
      decideReroll(player) {
        // Reroll if: high gold, looking for upgrades, still have bench space
        if (player.gold < 10) return;

        const unitCounts = this.countUnits(player);
        const hasUpgradePotential = Object.values(unitCounts).some(c => c === 2);
        const benchHasSpace = player.bench.some(s => s === null);

        if (hasUpgradePotential && benchHasSpace && player.gold >= 20) {
          player.spendGold(2);
          player.rollShop();
          // Try buying again after reroll
          this.buyUnits(player);
        }
      }
    };

    // ========== MULTIPLAYER COMBAT SYSTEM ==========
    const MultiplayerCombat = {
      // Current combat state
      activeBattles: [],       // Array of battle simulations
      displayedBattleIndex: 0, // Which battle is shown to human player
      combatPhaseComplete: false,

      // Calculate synergy bonuses for a player's board
      getSynergyBonusesForPlayer(player) {
        const factionCounts = {};
        Object.values(player.board).forEach(unitData => {
          const unitId = typeof unitData === 'object' ? unitData.id : unitData;
          const unit = unitsData[unitId];
          if (unit) {
            factionCounts[unit.faction] = (factionCounts[unit.faction] || 0) + 1;
          }
        });

        const bonuses = {};
        Object.entries(factionCounts).forEach(([faction, count]) => {
          const synergy = factionSynergies[faction];
          if (!synergy) return;

          let activeBonus = null;
          for (let i = synergy.thresholds.length - 1; i >= 0; i--) {
            if (count >= synergy.thresholds[i]) {
              activeBonus = synergy.bonuses[i];
              break;
            }
          }
          if (activeBonus) {
            bonuses[faction] = activeBonus;
          }
        });

        return bonuses;
      },

      // Create ghost army from a player's board (deep copy for combat)
      createGhostArmy(player, asAttacker = true) {
        const synergyBonuses = this.getSynergyBonusesForPlayer(player);
        const army = [];

        Object.entries(player.board).forEach(([hexKey, unitData]) => {
          const unitId = typeof unitData === 'object' ? unitData.id : unitData;
          const stars = typeof unitData === 'object' ? unitData.stars : 1;

          // Mirror hex position if this is the "enemy" (playerB)
          let combatHexKey = hexKey;
          if (!asAttacker) {
            const [col, row] = hexKey.split(',').map(Number);
            // Mirror: row 4 -> row 3, row 5 -> row 2, row 6 -> row 1, row 7 -> row 0
            const mirrorRow = 7 - row;
            combatHexKey = `${col},${mirrorRow}`;
          }

          const unit = createCombatUnit(unitId, combatHexKey, asAttacker, synergyBonuses, stars);
          if (unit) {
            unit.stars = stars;
            unit.ownerId = player.id;
            unit.ownerColor = player.color;
            army.push(unit);
          }
        });

        return army;
      },

      // Simulate a single battle between two players (instant, no animation)
      simulateBattle(playerA, playerB, isGhostMatch = false) {
        const armyA = this.createGhostArmy(playerA, true);
        const armyB = this.createGhostArmy(playerB, false);

        const allUnits = [...armyA, ...armyB];
        const combatLog = [];
        let tick = 0;
        const MAX_TICKS = 1000; // Prevent infinite loops

        combatLog.push(`=== ${playerA.name} vs ${playerB.name} ===`);
        combatLog.push(`${playerA.name}: ${armyA.length} units`);
        combatLog.push(`${playerB.name}: ${armyB.length} units`);

        // Run simulation
        while (tick < MAX_TICKS) {
          const aliveA = armyA.filter(u => u.hp > 0);
          const aliveB = armyB.filter(u => u.hp > 0);

          if (aliveA.length === 0 || aliveB.length === 0) break;

          // Process each unit's action
          for (const unit of allUnits) {
            if (unit.hp <= 0) continue;

            // Find target
            const enemies = unit.isPlayer ? armyB : armyA;
            const target = enemies.filter(e => e.hp > 0)
              .sort((a, b) => hexDistance(unit.hexKey, a.hexKey) - hexDistance(unit.hexKey, b.hexKey))[0];

            if (!target) continue;

            const dist = hexDistance(unit.hexKey, target.hexKey);

            // Attack if in range
            if (dist <= unit.range) {
              let damage = unit.attack;

              // Crit check
              if (Math.random() * 100 < unit.critChance) {
                damage = Math.round(damage * (unit.critDamage / 100));
              }

              // Apply armor reduction
              const armorReduction = target.armor / (target.armor + 100);
              damage = Math.round(damage * (1 - armorReduction));

              // Apply flat damage reduction (Tank class bonus)
              if (target.damageReduction && target.damageReduction > 0) {
                damage = Math.round(damage * (1 - target.damageReduction / 100));
              }

              target.hp -= damage;

              // Lifesteal
              if (unit.lifesteal > 0) {
                const heal = Math.round(damage * unit.lifesteal / 100);
                unit.hp = Math.min(unit.maxHp, unit.hp + heal);
              }
            } else {
              // Move toward target (improved pathfinding)
              const [col, row] = unit.hexKey.split(',').map(Number);
              const [tcol, trow] = target.hexKey.split(',').map(Number);
              const occupied = new Set(allUnits.filter(u => u.hp > 0 && u !== unit).map(u => u.hexKey));

              // Try direct path first
              const dc = Math.sign(tcol - col);
              const dr = Math.sign(trow - row);
              const directKey = `${col + dc},${row + dr}`;

              if (!occupied.has(directKey) && col + dc >= 0 && col + dc < 7 && row + dr >= 0 && row + dr < 8) {
                unit.hexKey = directKey;
              } else {
                // Direct path blocked - try alternative moves
                const currentDist = hexDistance(unit.hexKey, target.hexKey);
                const isOddRow = row & 1;
                const directions = isOddRow
                  ? [[1,0], [1,-1], [0,-1], [-1,0], [0,1], [1,1]]
                  : [[1,0], [0,-1], [-1,-1], [-1,0], [-1,1], [0,1]];

                let bestMove = null;
                let bestDist = currentDist;

                for (const [dcAlt, drAlt] of directions) {
                  const nc = col + dcAlt;
                  const nr = row + drAlt;
                  if (nc < 0 || nc >= 7 || nr < 0 || nr >= 8) continue;
                  const altKey = `${nc},${nr}`;
                  if (occupied.has(altKey)) continue;
                  const altDist = hexDistance(altKey, target.hexKey);
                  if (altDist < bestDist) {
                    bestDist = altDist;
                    bestMove = altKey;
                  }
                }

                // If no closer hex, try lateral movement
                if (!bestMove) {
                  for (const [dcAlt, drAlt] of directions) {
                    const nc = col + dcAlt;
                    const nr = row + drAlt;
                    if (nc < 0 || nc >= 7 || nr < 0 || nr >= 8) continue;
                    const altKey = `${nc},${nr}`;
                    if (occupied.has(altKey)) continue;
                    const altDist = hexDistance(altKey, target.hexKey);
                    if (altDist === currentDist) {
                      bestMove = altKey;
                      break;
                    }
                  }
                }

                if (bestMove) {
                  unit.hexKey = bestMove;
                }
              }
            }
          }

          tick++;
        }

        // Determine winner
        const survivorsA = armyA.filter(u => u.hp > 0);
        const survivorsB = armyB.filter(u => u.hp > 0);

        let winner = null;
        let loser = null;
        let damage = 0;

        if (survivorsA.length > 0 && survivorsB.length === 0) {
          winner = playerA;
          loser = playerB;
          // Damage = 2 + sum of surviving unit costs
          damage = 2 + survivorsA.reduce((sum, u) => sum + (unitsData[u.id]?.cost || 1), 0);
        } else if (survivorsB.length > 0 && survivorsA.length === 0) {
          winner = playerB;
          loser = playerA;
          damage = 2 + survivorsB.reduce((sum, u) => sum + (unitsData[u.id]?.cost || 1), 0);
        } else {
          // Draw or timeout - both take minor damage
          damage = 2;
        }

        combatLog.push(`--- Result: ${winner ? winner.name + ' wins!' : 'Draw!'} ---`);
        if (damage > 0 && loser) {
          combatLog.push(`${loser.name} takes ${damage} damage`);
        }

        return {
          playerA: playerA.id,
          playerB: playerB.id,
          winner: winner?.id ?? null,
          loser: loser?.id ?? null,
          damage,
          isGhostMatch,
          survivorsA: survivorsA.length,
          survivorsB: survivorsB.length,
          combatLog,
          // Store armies for animated replay
          armyA,
          armyB
        };
      },

      // Run all matchups for the round
      runAllMatchups() {
        const matchups = GameState.getMatchupsForRound();
        const results = [];

        for (const matchup of matchups) {
          const playerA = GameState.players[matchup.playerA];
          const playerB = GameState.players[matchup.playerB];

          // Skip if either player has no units
          if (Object.keys(playerA.board).length === 0) {
            // Auto-loss for playerA
            results.push({
              ...matchup,
              winner: playerB.id,
              loser: playerA.id,
              damage: 2 + playerB.level,
              combatLog: [`${playerA.name} has no units - auto loss!`]
            });
            continue;
          }
          if (Object.keys(playerB.board).length === 0) {
            results.push({
              ...matchup,
              winner: playerA.id,
              loser: playerB.id,
              damage: 2 + playerA.level,
              combatLog: [`${playerB.name} has no units - auto loss!`]
            });
            continue;
          }

          const result = this.simulateBattle(playerA, playerB, matchup.isGhostMatch);
          results.push(result);
        }

        this.activeBattles = results;
        return results;
      },

      // Apply results to players (damage, streaks, gold)
      applyResults() {
        for (const result of this.activeBattles) {
          const playerA = GameState.players[result.playerA];
          const playerB = GameState.players[result.playerB];

          if (result.winner !== null) {
            const winner = GameState.players[result.winner];
            const loser = GameState.players[result.loser];

            // Update streaks
            winner.wins++;
            winner.streak = winner.streak > 0 ? winner.streak + 1 : 1;

            loser.losses++;
            loser.streak = loser.streak < 0 ? loser.streak - 1 : -1;

            // Apply damage (only if not ghost match, or loser is the one who initiated)
            if (!result.isGhostMatch || result.loser === result.playerA) {
              loser.takeDamage(result.damage);
            }

            // Gold rewards
            const baseGold = 5;
            const streakBonus = Math.min(3, Math.abs(winner.streak) - 1);
            winner.earnGold(baseGold + streakBonus);

            // Loser still gets some gold
            loser.earnGold(2);
          } else {
            // Draw - both get base gold, small damage
            playerA.earnGold(3);
            playerB.earnGold(3);
            if (!result.isGhostMatch) {
              playerA.takeDamage(2);
              playerB.takeDamage(2);
            }
          }
        }

        // Process eliminations
        GameState.processEliminations();
      },

      // Get the battle result for a specific player
      getPlayerBattle(playerId) {
        return this.activeBattles.find(b => b.playerA === playerId || b.playerB === playerId);
      }
    };

    // Legacy single-player variables (kept for compatibility during transition)
    let gold = 50;
    let health = 100;
    let playerLevel = 1;
    let currentRound = 1;
    let shopUnits = [];
    let playerBoard = {}; // {hexKey: {id: unitId, stars: 1-3}}
    let enemyBoard = {};
    let bench = Array(9).fill(null); // [{id: unitId, stars: 1-3}, ...]
    let preCombatBoard = {}; // Snapshot of player positions before combat
    let highlightHex = null;
    let draggedUnit = null; // {fromShop, fromBench, fromBoard, id, cost, stars, slotIndex, oldKey}
    let roundBanner = null; // {text, startTime, duration}

    // Animation state
    let animationFrame = 0;  // Global tick for idle/motion
    let unitAnimations = {};  // {hexKey: {type: 'attack', time: 0, target: {...}}}
    const ANIM_DURATION = 300;  // ms for effects

    // Unit images for rendering
    let unitImages = {};

    // ========== SOUND SYSTEM ==========
    let attackCounter = 0; // Track attacks for "every 5th" meow
    let soundEnabled = true;
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Generate a "meow" sound using Web Audio API oscillators
    function playMeow(type = 'attack') {
      if (!soundEnabled) return;

      // Resume audio context if suspended (browser autoplay policy)
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }

      const now = audioContext.currentTime;

      // Create oscillator for the meow
      const osc = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      osc.connect(gainNode);
      gainNode.connect(audioContext.destination);

      // Different meow types
      if (type === 'death') {
        // Sad descending meow for death
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(150, now + 0.4);
        gainNode.gain.setValueAtTime(0.15, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
      } else if (type === 'attack') {
        // Quick chirpy meow for attack
        osc.type = 'triangle';
        // Randomize pitch slightly for variety
        const basePitch = 400 + Math.random() * 200;
        osc.frequency.setValueAtTime(basePitch, now);
        osc.frequency.exponentialRampToValueAtTime(basePitch * 1.5, now + 0.05);
        osc.frequency.exponentialRampToValueAtTime(basePitch * 0.8, now + 0.15);
        gainNode.gain.setValueAtTime(0.12, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
      } else if (type === 'hiss') {
        // Angry hiss for crits
        const bufferSize = audioContext.sampleRate * 0.2;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
        }
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(0.1, now);
        noise.connect(noiseGain);
        noiseGain.connect(audioContext.destination);
        noise.start(now);
      }
    }

    // Call this on attack - only plays every 5th attack
    function maybePlayAttackMeow() {
      attackCounter++;
      if (attackCounter % 5 === 0) {
        playMeow('attack');
      }
    }

    // Call this on death - always plays
    function playDeathMeow() {
      playMeow('death');
    }

    // Call this on crit - hiss!
    function playHiss() {
      playMeow('hiss');
    }

    // ========== SPRITE ANIMATION SYSTEM (per-unit sheets) ==========
    // Each unit has its own sprite sheet: 6 columns √ó 7 rows, 64√ó64 per cell
    // Animation config loaded from unit_animations_data.js (global UNIT_ANIM_CONFIG)
    let unitAnimConfig = (typeof UNIT_ANIM_CONFIG !== 'undefined') ? UNIT_ANIM_CONFIG : null;
    const SPRITE_CELL = 64;    // cell width/height

    // Per-unit sprite sheet storage: { unitKey: Image }
    let spriteSheets = {};

    // Track current animation state per unit instance
    // { instanceId: { animName, frame, lastFrameTime, stateStartTime } }
    let unitSpriteStates = {};

    // Load all per-unit sprite sheet PNGs (config already in global UNIT_ANIM_CONFIG)
    function loadAnimConfigAndSheets() {
      if (!unitAnimConfig) {
        console.warn('UNIT_ANIM_CONFIG not found, sprite sheets disabled');
        return;
      }
      console.log(`Animation config ready: ${Object.keys(unitAnimConfig.units).length} units`);
      // Load each unit's sprite sheet PNG
      Object.entries(unitAnimConfig.units).forEach(([unitKey, unitDef]) => {
        const img = new Image();
        img.src = unitDef.sheet; // e.g. "sheets/alley_tabby_thug_sheet.png"
        img.onload = () => {
          spriteSheets[unitKey] = img;
        };
        img.onerror = () => {
          // console.warn(`Failed to load sheet: ${unitDef.sheet}`);
        };
      });
    }

    // Get the unit key from a unit data object
    function getUnitKey(unit) {
      if (unit.id) return unit.id;
      return unit.name.toLowerCase().replace(/\s+/g, '_');
    }

    // Get current animation frame for a unit (advances time-based)
    function getUnitSpriteFrame(instanceId, unitKey, animName) {
      if (!unitAnimConfig) return { frame: 0, row: 0 };
      const unitDef = unitAnimConfig.units[unitKey];
      if (!unitDef) return { frame: 0, row: 0 };
      const anim = unitDef.animations[animName] || unitDef.animations.idle;
      if (!anim) return { frame: 0, row: 0 };

      const now = Date.now();
      const fps = anim.fps || 8;
      const frameDuration = 1000 / fps;

      // Initialize state if not exists
      if (!unitSpriteStates[instanceId]) {
        unitSpriteStates[instanceId] = {
          animName: animName,
          frame: 0,
          lastFrameTime: now,
          stateStartTime: now
        };
      }

      const state = unitSpriteStates[instanceId];

      // If animation changed, reset
      if (state.animName !== animName) {
        state.animName = animName;
        state.frame = 0;
        state.lastFrameTime = now;
        state.stateStartTime = now;
      }

      // Advance frame
      if (now - state.lastFrameTime >= frameDuration) {
        state.lastFrameTime = now;
        state.frame++;
        if (state.frame >= anim.frames) {
          if (anim.loop) {
            state.frame = 0;
          } else {
            // Non-looping finished ‚Äî return to idle (unless death)
            if (animName !== 'death') {
              state.animName = 'idle';
              const idleAnim = unitDef.animations.idle;
              state.frame = 0;
              state.stateStartTime = now;
            } else {
              state.frame = anim.frames - 1; // hold last
            }
          }
        }
      }

      const finalAnim = unitDef.animations[state.animName] || anim;
      return { frame: Math.min(state.frame, finalAnim.frames - 1), row: finalAnim.row };
    }

    // Set animation state for a unit
    function setUnitAnimation(instanceId, newAnimName) {
      if (!unitSpriteStates[instanceId]) {
        unitSpriteStates[instanceId] = { animName: 'idle', frame: 0, lastFrameTime: Date.now(), stateStartTime: Date.now() };
      }
      const state = unitSpriteStates[instanceId];
      if (state.animName !== newAnimName) {
        state.animName = newAnimName;
        state.frame = 0;
        state.stateStartTime = Date.now();
        state.lastFrameTime = Date.now();
      }
    }

    // Draw a unit using its per-unit sprite sheet
    function drawUnitSprite(ctx, cx, cy, unit, stars = 1, combatUnit = null) {
      const unitKey = getUnitKey(unit);
      const sheet = spriteSheets[unitKey];

      // Need both the sheet and the animation config
      if (!sheet || !sheet.complete || !unitAnimConfig || !unitAnimConfig.units[unitKey]) {
        return false; // fall back to static image
      }

      const instanceId = combatUnit ? combatUnit.id : (unitKey + '_board');
      const isPlayer = combatUnit ? combatUnit.isPlayer : true;

      // Determine which animation to play
      let animName = 'idle';
      if (combatUnit) {
        if (combatUnit.hp <= 0) animName = 'death';
        else if (unitSpriteStates[instanceId]) animName = unitSpriteStates[instanceId].animName;
      }

      const { frame, row } = getUnitSpriteFrame(instanceId, unitKey, animName);

      // Source rect from sheet
      const sx = frame * SPRITE_CELL;
      const sy = row * SPRITE_CELL;

      // Dest size ‚Äî fill the hex
      const destSize = hexSize * 1.4;

      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(cx, cy + destSize * 0.4, destSize * 0.3, destSize * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();

      // Team base circle
      const teamColor = isPlayer ? '#4488ff' : '#ff4444';
      const teamGlow = isPlayer ? 'rgba(68, 136, 255, 0.6)' : 'rgba(255, 68, 68, 0.6)';
      ctx.beginPath();
      ctx.arc(cx, cy + destSize * 0.1, destSize * 0.45, 0, Math.PI * 2);
      ctx.fillStyle = teamGlow;
      ctx.fill();
      ctx.strokeStyle = teamColor;
      ctx.lineWidth = 3;
      ctx.stroke();

      // Star glow
      const glowColors = { 1: unit.color, 2: '#4af', 3: '#f4a' };
      ctx.shadowColor = glowColors[stars] || unit.color;
      ctx.shadowBlur = stars === 1 ? 10 : stars === 2 ? 20 : 30;

      // Draw the sprite frame
      ctx.drawImage(
        sheet,
        sx, sy, SPRITE_CELL, SPRITE_CELL,
        cx - destSize / 2, cy - destSize / 2, destSize, destSize
      );
      ctx.shadowBlur = 0;

      // Team arrow
      ctx.fillStyle = teamColor;
      ctx.beginPath();
      if (isPlayer) {
        ctx.moveTo(cx, cy - destSize * 0.55);
        ctx.lineTo(cx - 6, cy - destSize * 0.45);
        ctx.lineTo(cx + 6, cy - destSize * 0.45);
      } else {
        ctx.moveTo(cx, cy - destSize * 0.45);
        ctx.lineTo(cx - 6, cy - destSize * 0.55);
        ctx.lineTo(cx + 6, cy - destSize * 0.55);
      }
      ctx.closePath();
      ctx.fill();

      // Stars
      ctx.font = '12px Arial';
      ctx.fillStyle = glowColors[stars] || unit.color;
      ctx.textAlign = 'center';
      ctx.fillText('\u2605'.repeat(stars), cx, cy + destSize * 0.5);

      return true;
    }

    // ========== STAR LEVEL SYSTEM ==========
    // STAR_MULTIPLIERS and getSellValue loaded from shared.js

    // Check if we can merge 3 units of same type/star level
    function checkForMerge(unitId, starLevel) {
      // Count matching units on board and bench
      let matches = [];

      // Check board
      Object.entries(playerBoard).forEach(([key, unit]) => {
        if (unit.id === unitId && unit.stars === starLevel) {
          matches.push({ location: 'board', key });
        }
      });

      // Check bench
      bench.forEach((unit, index) => {
        if (unit && unit.id === unitId && unit.stars === starLevel) {
          matches.push({ location: 'bench', index });
        }
      });

      return matches.length >= 3 ? matches : null;
    }

    // Perform merge: remove 3 units, create upgraded unit
    function performMerge(matches, unitId, currentStars) {
      if (currentStars >= 3) return false; // Can't upgrade beyond 3 stars

      const newStars = currentStars + 1;

      // Remove the 3 matching units, keep track of first board position
      let firstBoardKey = null;
      let firstBenchIndex = null;

      matches.slice(0, 3).forEach(match => {
        if (match.location === 'board') {
          if (!firstBoardKey) firstBoardKey = match.key;
          else delete playerBoard[match.key];
        } else {
          if (!firstBenchIndex && firstBenchIndex !== 0 && !firstBoardKey) firstBenchIndex = match.index;
          else bench[match.index] = null;
        }
      });

      // Place upgraded unit in first position found
      if (firstBoardKey) {
        playerBoard[firstBoardKey] = { id: unitId, stars: newStars };
      } else if (firstBenchIndex !== null) {
        bench[firstBenchIndex] = { id: unitId, stars: newStars };
      }

      // Show merge effect
      addMergeEffect(unitId, newStars);

      // Check for another merge at the new star level
      setTimeout(() => {
        const nextMerge = checkForMerge(unitId, newStars);
        if (nextMerge) {
          performMerge(nextMerge, unitId, newStars);
        }
        renderBench();
        renderBoard();
        renderSynergies();
        updateUI();
      }, 300);

      return true;
    }

    function addMergeEffect(unitId, stars) {
      const unit = unitsData[unitId];
      roundBanner = {
        text: `‚≠ê ${stars}-STAR ${unit.name.toUpperCase()}! ‚≠ê`,
        subtext: stars === 2 ? '√ó1.8 stats!' : '√ó3.0 stats!',
        color: stars === 2 ? '#4af' : '#f4a',
        startTime: Date.now(),
        duration: 1500
      };
    }

    // Try to add a unit (from shop) - returns true if successful
    function tryAddUnit(unitId) {
      // First check if adding this would trigger a merge
      const existingMatches = checkForMerge(unitId, 1);

      if (existingMatches && existingMatches.length >= 2) {
        // We have 2 already, this will make 3 - find a spot temporarily
        const emptyBenchSlot = bench.findIndex(s => s === null);
        if (emptyBenchSlot !== -1) {
          bench[emptyBenchSlot] = { id: unitId, stars: 1 };
          // Now check and perform merge
          const matches = checkForMerge(unitId, 1);
          if (matches) {
            performMerge(matches, unitId, 1);
          }
          return true;
        }
        return false; // No space
      }

      // No merge possible, just add to bench
      const emptySlot = bench.findIndex(s => s === null);
      if (emptySlot !== -1) {
        bench[emptySlot] = { id: unitId, stars: 1 };
        // Still check for merge in case we now have 3
        const matches = checkForMerge(unitId, 1);
        if (matches) {
          performMerge(matches, unitId, 1);
        }
        return true;
      }

      return false; // Bench full
    }

    // Visual effects for combat
    let visualEffects = []; // {type, x, y, text, color, startTime, duration}
    let particles = []; // Global array for particle effects

    function addDamageNumber(hexKey, damage, isCrit = false) {
      const hex = boardHexes.find(h => getHexKey(h) === hexKey);
      if (!hex) return;
      const p = hexToPixel(hex);
      visualEffects.push({
        type: 'damage',
        x: p.x + (Math.random() - 0.5) * hexSize * 0.4,
        y: p.y - hexSize * 0.4,
        text: `-${Math.round(damage)}`,
        color: isCrit ? '#ff0' : '#f44',
        startTime: Date.now(),
        duration: 800
      });
    }

    function addHealNumber(hexKey, amount) {
      const hex = boardHexes.find(h => getHexKey(h) === hexKey);
      if (!hex) return;
      const p = hexToPixel(hex);
      visualEffects.push({
        type: 'heal',
        x: p.x + (Math.random() - 0.5) * hexSize * 0.4,
        y: p.y - hexSize * 0.4,
        text: `+${Math.round(amount)}`,
        color: '#4f4',
        startTime: Date.now(),
        duration: 800
      });
    }

    function addAttackLine(fromKey, toKey, color = '#fff') {
      const fromHex = boardHexes.find(h => getHexKey(h) === fromKey);
      const toHex = boardHexes.find(h => getHexKey(h) === toKey);
      if (!fromHex || !toHex) return;
      const from = hexToPixel(fromHex);
      const to = hexToPixel(toHex);
      visualEffects.push({
        type: 'attackLine',
        x: from.x, y: from.y,
        x2: to.x, y2: to.y,
        color,
        startTime: Date.now(),
        duration: 150
      });
    }

    function addStatusIcon(hexKey, icon) {
      const hex = boardHexes.find(h => getHexKey(h) === hexKey);
      if (!hex) return;
      const p = hexToPixel(hex);
      visualEffects.push({
        type: 'status',
        x: p.x,
        y: p.y - hexSize * 0.65,
        text: icon,
        color: '#fff',
        startTime: Date.now(),
        duration: 500
      });
    }

    // Particle effects
    function addAttackParticles(x, y, color) {
      for (let i = 0; i < 8; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10 - 2,
          life: 1,
          color: color + Math.floor(Math.random()*128).toString(16).padStart(2,'0')  // Shade var
        });
      }
    }

    function addDeathExplosion(hexKey) {
      const p = hexToPixel(boardHexes.find(h => getHexKey(h) === hexKey));
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: p.x, y: p.y,
          vx: (Math.random() - 0.5) * 15,
          vy: (Math.random() - 0.5) * 15,
          life: 1,
          size: Math.random() * 4 + 2,
          color: '#ff4400'
        });
      }
    }

    function addAbilityParticles(x, y, color) {
      // Add particles for ability effects
      for (let i = 0; i < 12; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 12,
          vy: (Math.random() - 0.5) * 12 - 2,
          life: 1,
          color: color + Math.floor(Math.random()*128).toString(16).padStart(2,'0')
        });
      }
    }

    function addHealParticles(hexKey, amount) {
      const p = hexToPixel(boardHexes.find(h => getHexKey(h) === hexKey));
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: p.x, y: p.y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8 - 2,
          life: 1,
          color: '#0f0' + Math.floor(Math.random()*128).toString(16).padStart(2,'0')
        });
      }
    }

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const hexSize = 42; // Smaller for compact 1080p fit

    // Calculate proper centering for hex grid
    const totalWidth = 7 * hexSize * Math.sqrt(3); // Width of 7 columns
    const totalHeight = 8 * (3/2) * hexSize; // Height of 8 rows

    // Adjust origin to center the grid
    const origin = {
      x: (canvas.width - totalWidth) / 2 + hexSize * Math.sqrt(3) / 2,
      y: 90
    };

    const boardHexes = [];
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 7; col++) {
        boardHexes.push({ col, row });
      }
    }

    // === SURREAL DAL√ç-INSPIRED DREAMSCAPE ===
    let backgroundTime = 0;

    function drawBackground() {
      backgroundTime += 0.008;

      // === DREAMY SKY - Dal√≠ desert palette ===
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, '#1a1a35');      // Deep dream void
      skyGradient.addColorStop(0.2, '#2d2850');    // Purple haze
      skyGradient.addColorStop(0.4, '#4a3d6a');    // Twilight lavender
      skyGradient.addColorStop(0.55, '#8b6b5a');   // Dal√≠ desert tan
      skyGradient.addColorStop(0.7, '#c4956a');    // Warm sand
      skyGradient.addColorStop(0.85, '#7a5a50');   // Earth shadow
      skyGradient.addColorStop(1, '#3a2a35');      // Ground fade

      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // === WARPED HORIZON LINE (impossible perspective) ===
      ctx.strokeStyle = 'rgba(200, 150, 100, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let x = 0; x <= canvas.width; x += 5) {
        const wave = Math.sin(x * 0.008 + backgroundTime) * 30
                   + Math.sin(x * 0.015 - backgroundTime * 0.5) * 15;
        const y = canvas.height * 0.45 + wave;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // === MELTING CLOCK (signature Dal√≠ element) ===
      const drawMeltingClock = (cx, cy, size, melt, rotation) => {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotation);

        // Clock face (warped ellipse)
        ctx.beginPath();
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
          const warp = 1 + Math.sin(angle * 2 + backgroundTime) * melt * 0.3;
          const droop = angle > Math.PI * 0.3 && angle < Math.PI * 1.7
                       ? Math.sin((angle - Math.PI * 0.3) / 1.4 * Math.PI) * melt * size * 0.5 : 0;
          const rx = Math.cos(angle) * size * warp;
          const ry = Math.sin(angle) * size * 0.6 * warp + droop;
          if (angle === 0) ctx.moveTo(rx, ry);
          else ctx.lineTo(rx, ry);
        }
        ctx.closePath();

        const clockGrad = ctx.createRadialGradient(0, 0, 0, 0, size * 0.3, size);
        clockGrad.addColorStop(0, 'rgba(255, 250, 230, 0.9)');
        clockGrad.addColorStop(0.7, 'rgba(220, 200, 170, 0.8)');
        clockGrad.addColorStop(1, 'rgba(180, 150, 120, 0.6)');
        ctx.fillStyle = clockGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(100, 80, 60, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Clock hands (also melting)
        const hourAngle = backgroundTime * 0.1;
        const minAngle = backgroundTime * 0.5;

        ctx.strokeStyle = 'rgba(60, 40, 30, 0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const hx = Math.sin(hourAngle) * size * 0.4;
        const hy = -Math.cos(hourAngle) * size * 0.3 + Math.sin(hourAngle + 1) * melt * 10;
        ctx.quadraticCurveTo(hx * 0.5, hy * 0.5 + melt * 5, hx, hy);
        ctx.stroke();

        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const mx = Math.sin(minAngle) * size * 0.6;
        const my = -Math.cos(minAngle) * size * 0.4 + Math.sin(minAngle + 2) * melt * 15;
        ctx.quadraticCurveTo(mx * 0.5, my * 0.5 + melt * 8, mx, my);
        ctx.stroke();

        ctx.restore();
      };

      // Place melting clocks
      drawMeltingClock(80, canvas.height * 0.35, 45, 0.8, -0.3);
      drawMeltingClock(canvas.width - 100, canvas.height * 0.4, 35, 0.6, 0.2);
      drawMeltingClock(canvas.width * 0.15, canvas.height * 0.55, 25, 1.0, -0.5);

      // === FLOATING FISH (surreal cat dreams) ===
      const drawFloatingFish = (x, y, size, phase) => {
        const bobY = y + Math.sin(backgroundTime * 1.5 + phase) * 15;
        const wobble = Math.sin(backgroundTime * 2 + phase) * 0.1;

        ctx.save();
        ctx.translate(x, bobY);
        ctx.rotate(wobble);
        ctx.globalAlpha = 0.6;

        // Fish body
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.quadraticCurveTo(size * 0.3, -size * 0.4, -size * 0.5, 0);
        ctx.quadraticCurveTo(size * 0.3, size * 0.4, size, 0);
        ctx.fillStyle = `hsl(${200 + phase * 20}, 60%, 70%)`;
        ctx.fill();

        // Tail
        ctx.beginPath();
        ctx.moveTo(-size * 0.5, 0);
        ctx.lineTo(-size, -size * 0.3);
        ctx.lineTo(-size, size * 0.3);
        ctx.closePath();
        ctx.fill();

        // Eye
        ctx.beginPath();
        ctx.arc(size * 0.5, -size * 0.1, size * 0.12, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fill();

        ctx.restore();
      };

      // Floating fish scattered around
      drawFloatingFish(150, canvas.height * 0.25, 20, 0);
      drawFloatingFish(canvas.width - 180, canvas.height * 0.3, 25, 2);
      drawFloatingFish(canvas.width * 0.5 - 200, canvas.height * 0.2, 15, 4);
      drawFloatingFish(canvas.width * 0.7, canvas.height * 0.15, 18, 1);

      // === IMPOSSIBLE COLUMNS (perspective tricks) ===
      const drawImpossibleColumn = (x, baseY, height, width) => {
        const twist = Math.sin(backgroundTime * 0.5) * 0.1;

        // Column with impossible twist
        ctx.beginPath();
        ctx.moveTo(x - width/2, baseY);
        ctx.lineTo(x - width/2 + twist * 30, baseY - height * 0.5);
        ctx.lineTo(x + width/2 + twist * 30, baseY - height * 0.5);
        ctx.lineTo(x + width/2, baseY);
        ctx.closePath();

        const colGrad = ctx.createLinearGradient(x - width, baseY - height, x + width, baseY);
        colGrad.addColorStop(0, 'rgba(180, 160, 140, 0.4)');
        colGrad.addColorStop(0.5, 'rgba(220, 200, 180, 0.5)');
        colGrad.addColorStop(1, 'rgba(160, 140, 120, 0.4)');
        ctx.fillStyle = colGrad;
        ctx.fill();

        // Upper part (twisted other way)
        ctx.beginPath();
        ctx.moveTo(x - width/2 + twist * 30, baseY - height * 0.5);
        ctx.lineTo(x - width/2 - twist * 20, baseY - height);
        ctx.lineTo(x + width/2 - twist * 20, baseY - height);
        ctx.lineTo(x + width/2 + twist * 30, baseY - height * 0.5);
        ctx.closePath();
        ctx.fillStyle = 'rgba(200, 180, 160, 0.35)';
        ctx.fill();

        // Capital (top decoration)
        ctx.beginPath();
        ctx.ellipse(x, baseY - height, width * 0.8, width * 0.3, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(230, 210, 190, 0.5)';
        ctx.fill();
      };

      drawImpossibleColumn(60, canvas.height * 0.75, 180, 25);
      drawImpossibleColumn(canvas.width - 70, canvas.height * 0.7, 150, 20);

      // === ELONGATED SHADOWS (Dal√≠ elephants style, but cat-ified) ===
      const drawElongatedCatShadow = (x, baseY, legHeight) => {
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#2a1a20';

        // Super long spindly legs
        for (let i = 0; i < 4; i++) {
          const legX = x + (i - 1.5) * 15;
          const sway = Math.sin(backgroundTime + i) * 5;
          ctx.beginPath();
          ctx.moveTo(legX, baseY);
          ctx.quadraticCurveTo(legX + sway, baseY - legHeight * 0.5, legX + sway * 0.5, baseY - legHeight);
          ctx.lineTo(legX + 3 + sway * 0.5, baseY - legHeight);
          ctx.quadraticCurveTo(legX + 3 + sway, baseY - legHeight * 0.5, legX + 3, baseY);
          ctx.fill();
        }

        // Tiny cat body at top
        const bodyY = baseY - legHeight;
        ctx.beginPath();
        ctx.ellipse(x, bodyY, 20, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // Cat head
        ctx.beginPath();
        ctx.arc(x + 15, bodyY - 5, 8, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.beginPath();
        ctx.moveTo(x + 10, bodyY - 10);
        ctx.lineTo(x + 13, bodyY - 20);
        ctx.lineTo(x + 18, bodyY - 12);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + 18, bodyY - 12);
        ctx.lineTo(x + 22, bodyY - 20);
        ctx.lineTo(x + 24, bodyY - 8);
        ctx.fill();

        ctx.globalAlpha = 1;
      };

      drawElongatedCatShadow(200, canvas.height * 0.85, 200);
      drawElongatedCatShadow(canvas.width - 220, canvas.height * 0.82, 170);

      // === FLOATING GEOMETRIC SHAPES ===
      const drawFloatingShape = (x, y, size, sides, phase) => {
        const floatY = y + Math.sin(backgroundTime + phase) * 20;
        const rot = backgroundTime * 0.3 + phase;

        ctx.save();
        ctx.translate(x, floatY);
        ctx.rotate(rot);
        ctx.globalAlpha = 0.25;

        ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
          const angle = (i / sides) * Math.PI * 2;
          const px = Math.cos(angle) * size;
          const py = Math.sin(angle) * size;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();

        ctx.fillStyle = `hsl(${(phase * 60 + backgroundTime * 20) % 360}, 40%, 60%)`;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      };

      drawFloatingShape(canvas.width * 0.2, canvas.height * 0.15, 30, 3, 0);
      drawFloatingShape(canvas.width * 0.8, canvas.height * 0.2, 25, 5, 2);
      drawFloatingShape(canvas.width * 0.1, canvas.height * 0.45, 20, 4, 4);
      drawFloatingShape(canvas.width * 0.9, canvas.height * 0.5, 22, 6, 1);

      // === WARPED CHECKERBOARD FLOOR (receding into infinity) ===
      ctx.globalAlpha = 0.15;
      const horizonY = canvas.height * 0.55;
      const floorBottom = canvas.height;

      for (let row = 0; row < 12; row++) {
        const rowProgress = row / 12;
        const y = horizonY + (floorBottom - horizonY) * Math.pow(rowProgress, 0.7);
        const nextY = horizonY + (floorBottom - horizonY) * Math.pow((row + 1) / 12, 0.7);
        const perspectiveScale = 0.1 + rowProgress * 0.9;
        const tileWidth = 80 * perspectiveScale;
        const xOffset = canvas.width / 2 + Math.sin(backgroundTime + row * 0.3) * 20 * (1 - rowProgress);

        for (let col = -10; col < 10; col++) {
          const x = xOffset + col * tileWidth;
          const warp = Math.sin(col * 0.5 + row * 0.3 + backgroundTime) * 5 * perspectiveScale;

          if ((row + col) % 2 === 0) {
            ctx.fillStyle = 'rgba(60, 40, 50, 0.5)';
          } else {
            ctx.fillStyle = 'rgba(100, 80, 70, 0.4)';
          }

          ctx.beginPath();
          ctx.moveTo(x + warp, y);
          ctx.lineTo(x + tileWidth + warp, y);
          ctx.lineTo(x + tileWidth - warp * 0.5, nextY);
          ctx.lineTo(x - warp * 0.5, nextY);
          ctx.closePath();
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;

      // === DISTANT SURREAL ARCH ===
      ctx.globalAlpha = 0.3;
      const archX = canvas.width * 0.5;
      const archY = canvas.height * 0.35;
      const archWidth = 120;
      const archHeight = 100;

      // Arch opening
      ctx.beginPath();
      ctx.moveTo(archX - archWidth/2, archY + archHeight);
      ctx.lineTo(archX - archWidth/2, archY);
      ctx.quadraticCurveTo(archX, archY - archHeight * 0.5, archX + archWidth/2, archY);
      ctx.lineTo(archX + archWidth/2, archY + archHeight);
      ctx.lineTo(archX + archWidth/2 - 15, archY + archHeight);
      ctx.lineTo(archX + archWidth/2 - 15, archY + 10);
      ctx.quadraticCurveTo(archX, archY - archHeight * 0.3, archX - archWidth/2 + 15, archY + 10);
      ctx.lineTo(archX - archWidth/2 + 15, archY + archHeight);
      ctx.closePath();

      const archGrad = ctx.createLinearGradient(archX - archWidth, archY, archX + archWidth, archY + archHeight);
      archGrad.addColorStop(0, 'rgba(200, 180, 160, 0.8)');
      archGrad.addColorStop(1, 'rgba(150, 130, 110, 0.6)');
      ctx.fillStyle = archGrad;
      ctx.fill();

      // Sky through arch (different color)
      ctx.beginPath();
      ctx.moveTo(archX - archWidth/2 + 15, archY + archHeight);
      ctx.lineTo(archX - archWidth/2 + 15, archY + 10);
      ctx.quadraticCurveTo(archX, archY - archHeight * 0.3, archX + archWidth/2 - 15, archY + 10);
      ctx.lineTo(archX + archWidth/2 - 15, archY + archHeight);
      ctx.closePath();
      ctx.fillStyle = 'rgba(255, 200, 150, 0.4)';
      ctx.fill();

      ctx.globalAlpha = 1;

      // === ETHEREAL GLOW ===
      const glowX = canvas.width * 0.3;
      const glowY = canvas.height * 0.4;
      const glowGrad = ctx.createRadialGradient(glowX, glowY, 0, glowX, glowY, 250);
      glowGrad.addColorStop(0, 'rgba(255, 220, 180, 0.2)');
      glowGrad.addColorStop(0.5, 'rgba(255, 180, 120, 0.1)');
      glowGrad.addColorStop(1, 'rgba(200, 150, 100, 0)');
      ctx.fillStyle = glowGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // === SUBTLE VIGNETTE ===
      const vignetteGrad = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, canvas.height * 0.3,
        canvas.width/2, canvas.height/2, canvas.height
      );
      vignetteGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignetteGrad.addColorStop(1, 'rgba(20, 10, 30, 0.4)');
      ctx.fillStyle = vignetteGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Helper function to shade colors
    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.max(0, Math.min(255, (num >> 16) + amt));
      const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + amt));
      const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
      return `rgb(${R},${G},${B})`;
    }

    const playerRows = [4, 5, 6, 7];
    const enemyRows = [0, 1, 2, 3];

    function getHexKey(hex) {
      return `${hex.col},${hex.row}`;
    }

    function hexToPixel(hex) {
      const x = hexSize * Math.sqrt(3) * (hex.col + 0.5 * (hex.row & 1));
      const y = hexSize * (3/2) * hex.row;
      return { x: origin.x + x - 3 * hexSize * Math.sqrt(3) / 2, y: origin.y + y };
    }

    function pixelToHex(px, py) {
      const x = (px - origin.x + 3 * hexSize * Math.sqrt(3) / 2) / (hexSize * Math.sqrt(3));
      const y = (py - origin.y) / (hexSize * 3/2);
      const row = Math.round(y);
      const col = Math.round(x - 0.5 * (row & 1));
      return { col, row };
    }

    function getNearestHex(raw) {
      const col = Math.round(raw.col);
      const row = Math.round(raw.row);
      return boardHexes.find(h => h.col === col && h.row === row) || null;
    }

    function drawHexWithShadow(cx, cy, fill, stroke = '#555', isTeamBorder = false) {
      // Draw shadow first
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 3) * i - Math.PI / 2;
        const x = cx + hexSize * Math.cos(ang) + 2;
        const y = cy + hexSize * Math.sin(ang) + 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fill();

      // Draw hex with 3D effect
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 3) * i - Math.PI / 2;
        const x = cx + hexSize * Math.cos(ang);
        const y = cy + hexSize * Math.sin(ang);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();

      // Add gradient for 3D effect
      const hexGradient = ctx.createRadialGradient(
        cx, cy, 0,
        cx, cy, hexSize
      );
      if (fill === '#1e2a38' || fill === '#2e1a1a') {
        // Dark hexes get a subtle gradient
        hexGradient.addColorStop(0, '#2a3a4a');
        hexGradient.addColorStop(1, fill);
      } else {
        // Lighter hexes get a more pronounced 3D effect
        hexGradient.addColorStop(0, '#ffffff');
        hexGradient.addColorStop(0.7, fill);
        hexGradient.addColorStop(1, '#333333');
      }

      ctx.fillStyle = hexGradient;
      ctx.fill();
      ctx.strokeStyle = stroke;
      // Thicker border for team colors (units), thinner for empty hexes
      ctx.lineWidth = isTeamBorder ? 3 : 2;
      ctx.lineJoin = 'round'; // Smooth corners for consistent border
      ctx.stroke();
    }

    function drawUnitWithShadow(cx, cy, unit, stars = 1, combatUnitRef = null) {
      // Try to draw using sprite system first
      if (drawUnitSprite(ctx, cx, cy, unit, stars, combatUnitRef)) {
        return; // Successfully drew sprite
      }

      // === FALLBACK: Original emoji/image rendering ===

      // Draw shadow
      ctx.beginPath();
      ctx.arc(cx + 3, cy + 3, hexSize * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fill();

      // Star-based glow colors
      const glowColors = {
        1: unit.color,
        2: '#4af',
        3: '#f4a'
      };

      // Draw unit with 3D effect using PNG assets
      // Create a mapping from unit identifiers to image file names
      const unitImageMap = {
        'alley_tabby_thug': 'alley_tabby_thug.png',
        'alley_ginger_rogue': 'alley_ginger_rogue.png',
        'alley_tuxedo_con': 'alley_tuxedo_con.png',
        'alley_street_yowler': 'alley_street_yowler.png',
        'alley_dumpster_king': 'alley_dumpster_king.png',
        'alley_feral_boss': 'alley_feral_boss.png',
        'persian_princess': 'persian_princess.png',
        'persian_pampered': 'persian_pampered.png',
        'persian_groomer': 'persian_groomer.png',
        'persian_snob': 'persian_snob.png',
        'persian_himalayan': 'persian_himalayan.png',
        'persian_emperor': 'persian_emperor.png',
        'siamese_screamer': 'siamese_screamer.png',
        'siamese_chatterbox': 'siamese_chatterbox.png',
        'siamese_soprano': 'siamese_soprano.png',
        'siamese_gossip': 'siamese_gossip.png',
        'siamese_opera': 'siamese_opera.png',
        'siamese_conductor': 'siamese_conductor.png',
        'mainecoon_titan': 'mainecoon_titan.png',
        'mainecoon_cub': 'mainecoon_cub.png',
        'mainecoon_guardian': 'mainecoon_guardian.png',
        'mainecoon_brawler': 'mainecoon_brawler.png',
        'mainecoon_elder': 'mainecoon_elder.png',
        'mainecoon_alpha': 'mainecoon_alpha.png',
        'bengal_stalker': 'bengal_stalker.png',
        'bengal_kitten': 'bengal_kitten.png',
        'bengal_hunter': 'bengal_hunter.png',
        'bengal_assassin': 'bengal_assassin.png',
        'bengal_pack_leader': 'bengal_pack_leader.png',
        'bengal_apex': 'bengal_apex.png',
        'sphynx_menace': 'sphynx_menace.png',
        'sphynx_creeper': 'sphynx_creeper.png',
        'sphynx_warmer': 'sphynx_warmer.png',
        'sphynx_cultist': 'sphynx_cultist.png',
        'sphynx_oracle': 'sphynx_oracle.png',
        'sphynx_overlord': 'sphynx_overlord.png',
        'scottish_gambler': 'scottish_gambler.png',
        'scottish_lucky': 'scottish_lucky.png',
        'scottish_dealer': 'scottish_dealer.png',
        'scottish_bettor': 'scottish_bettor.png',
        'scottish_fortune': 'scottish_fortune.png',
        'scottish_jackpot': 'scottish_jackpot.png',
        'ragdoll_faker': 'ragdoll_faker.png',
        'ragdoll_lazy': 'ragdoll_lazy.png',
        'ragdoll_flopper': 'ragdoll_flopper.png',
        'ragdoll_dreamer': 'ragdoll_dreamer.png',
        'ragdoll_therapist': 'ragdoll_therapist.png',
        'ragdoll_zen': 'ragdoll_zen.png'
      };

      // Get unit key for animation lookup
      const unitKey = unit.name.toLowerCase().replace(/\s+/g, '_');

      // IDLE SWAY (subtle bob for all units)
      const swayOffset = Math.sin(animationFrame * 0.1 + parseInt(unitKey)) * 2;
      const swayX = cx + swayOffset;
      const swayY = cy + Math.abs(Math.cos(animationFrame * 0.08)) * 1;

      // ATTACK PULSE / ABILITY GLOW
      let pulseScale = 1;
      let glowColor = unit.color;
      if (unitAnimations[unitKey]) {
        const anim = unitAnimations[unitKey];
        const progress = (Date.now() - anim.startTime) / ANIM_DURATION;
        if (progress < 1) {
          pulseScale = 1 + Math.sin(progress * Math.PI) * 0.3;  // Scale pop
          glowColor = `hsl(${parseInt(unit.color.slice(1,7),16) % 360}, 100%, 60%)`;  // Brighten
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 20 * (1 - progress);
        } else {
          delete unitAnimations[unitKey];  // End anim
        }
      }

      // Draw unit image if available
      if (unitImageMap[unitKey] && unitImages[unitKey]) {
        const img = unitImages[unitKey];
        // Draw image with proper scaling and animation
        ctx.save();
        ctx.translate(swayX, swayY);
        ctx.scale(pulseScale, pulseScale);
        ctx.drawImage(img, cx - hexSize * 0.35, cy - hexSize * 0.35, hexSize * 0.7, hexSize * 0.7);
        ctx.restore();
      } else {
        // Fallback to emoji if image not found
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(unit.icon, cx, cy);
      }

      // Add glow effect based on star level
      ctx.shadowColor = glowColors[stars] || unit.color;
      ctx.shadowBlur = stars === 1 ? 15 : stars === 2 ? 25 : 35;

      if (unitImageMap[unitKey] && unitImages[unitKey]) {
        // Redraw image with glow effect and animation
        ctx.save();
        ctx.translate(swayX, swayY);
        ctx.scale(pulseScale, pulseScale);
        const scale = hexSize * 0.7 / 64;
        ctx.drawImage(unitImages[unitKey], cx - hexSize * 0.35, cy - hexSize * 0.35, hexSize * 0.7, hexSize * 0.7);
        ctx.restore();
      } else {
        // Fallback to emoji with glow
        ctx.fillText(unit.icon, cx, cy);
      }
      ctx.shadowBlur = 0;

      // Draw unit border for 3D effect (color based on stars)
      const borderColors = {
        1: 'rgba(255, 255, 255, 0.7)',
        2: 'rgba(68, 170, 255, 0.9)',
        3: 'rgba(255, 68, 170, 0.9)'
      };
      ctx.strokeStyle = borderColors[stars];
      ctx.lineWidth = stars === 1 ? 2 : stars === 2 ? 3 : 4;
      ctx.beginPath();
      ctx.arc(cx, cy, hexSize * 0.4, 0, Math.PI * 2);
      ctx.stroke();

      // Draw star indicators below unit
      ctx.font = '10px Arial';
      ctx.fillStyle = stars === 1 ? '#ffd700' : stars === 2 ? '#4af' : '#f4a';
      ctx.fillText('‚≠ê'.repeat(stars), cx, cy + 28);

      // Draw faction label
      ctx.font = '10px Arial';
      ctx.fillStyle = '#aaa';
      ctx.fillText(unit.faction, cx, cy + 40);
    }

    function drawHex(cx, cy, fill, stroke = '#555') {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 3) * i - Math.PI / 2;
        const x = cx + hexSize * Math.cos(ang);
        const y = cy + hexSize * Math.sin(ang);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      ctx.stroke();
    }

    // hexDistance loaded from shared.js

    function renderBoard() {
      // Increment animation frame
      animationFrame++;

      // Update and draw particles
      particles = particles.filter(part => {
        part.x += part.vx;
        part.y += part.vy;
        part.vy += 0.2;  // Gravity
        part.life -= 0.03;
        return part.life > 0;
      });

      // Draw 3D background
      drawBackground();

      // Collect hex data for two-pass rendering
      const hexRenderData = [];

      // PASS 1: Draw all hex fills and basic borders first
      boardHexes.forEach(hex => {
        const p = hexToPixel(hex);
        const key = getHexKey(hex);
        const isPlayer = playerRows.includes(hex.row);

        // Get unit data (new format: {id, stars} or old format: string)
        let unitData = playerBoard[key] || enemyBoard[key];
        let unitId = null;
        let stars = 1;

        if (unitData) {
          if (typeof unitData === 'object') {
            unitId = unitData.id;
            stars = unitData.stars || 1;
          } else {
            unitId = unitData; // Old format compatibility
          }
        }

        let fill = isPlayer ? '#1e2a38' : '#2e1a1a';
        let teamStroke = null;

        // Check if this hex has a unit (from either board)
        const isPlayerUnit = playerBoard[key] !== undefined;
        const isEnemyUnit = enemyBoard[key] !== undefined;

        if (unitId) {
          fill = unitsData[unitId].color;
          // Set border color based on team: blue for player, red for enemy
          if (isPlayerUnit) {
            teamStroke = '#4a9eff'; // Blue for player
            if (stars === 2) teamStroke = '#66b3ff';
            if (stars === 3) teamStroke = '#99ccff';
          } else if (isEnemyUnit) {
            teamStroke = '#ff4a4a'; // Red for enemy
            if (stars === 2) teamStroke = '#ff6666';
            if (stars === 3) teamStroke = '#ff9999';
          }
        }

        const isDragging = draggedUnit && (draggedUnit.fromBoard || draggedUnit.fromBench) && draggedUnit.oldKey === key;
        if (isDragging) {
          fill = isPlayer ? '#1e2a38' : '#2e1a1a';
          teamStroke = null;
        }

        // Draw hex fill only (no team border yet)
        drawHexWithShadow(p.x, p.y, fill, '#555', false);

        // Store data for second pass if this hex has a unit
        if (teamStroke && !isDragging) {
          hexRenderData.push({ p, teamStroke, unitId, stars, key });
        }
      });

      // PASS 2: Draw team borders on top of all hexes (so they don't get covered)
      hexRenderData.forEach(({ p, teamStroke }) => {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const ang = (Math.PI / 3) * i - Math.PI / 2;
          const x = p.x + hexSize * Math.cos(ang);
          const y = p.y + hexSize * Math.sin(ang);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.strokeStyle = teamStroke;
        ctx.lineWidth = 3;
        ctx.lineJoin = 'round';
        ctx.stroke();
      });

      // Draw particles
      particles.forEach(part => {
        ctx.save();
        ctx.globalAlpha = part.life;
        ctx.fillStyle = part.color;
        ctx.beginPath();
        ctx.arc(part.x, part.y, part.size * part.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // PASS 3: Draw units on top
      hexRenderData.forEach(({ p, unitId, stars, key }) => {
        const u = unitsData[unitId];
        // Find combat unit reference if in combat (for sprite animation state)
        let combatUnitRef = null;
        if (combatState === 'combat') {
          combatUnitRef = combatUnits.find(cu => cu.hexKey === key && cu.hp > 0);
        }
        // Draw unit with 3D shadow effect
        drawUnitWithShadow(p.x, p.y, u, stars, combatUnitRef);
      });

      if (highlightHex) {
        const p = hexToPixel(highlightHex);
        ctx.globalAlpha = 0.4;
        drawHex(p.x, p.y, '#33ff66', '#33ff66');
        ctx.globalAlpha = 1;
      }

      // Combat visuals (health/mana bars)
      if (combatState === 'combat' || combatState === 'resolution') {
        combatUnits.forEach(unit => {
          if (unit.hp <= 0) return;
          const hex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
          if (!hex) return;
          const p = hexToPixel(hex);

          // Status effect indicators with shadows
          if (hasStatus && hasStatus(unit, STATUS?.STUN)) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(p.x + 2, p.y + 2, hexSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, hexSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
          }
          if (hasStatus && hasStatus(unit, STATUS?.POISON)) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(p.x + 2, p.y + 2, hexSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, hexSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
          if (hasStatus && hasStatus(unit, STATUS?.SHIELD)) {
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x + 2, p.y + 2, hexSize * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x, p.y, hexSize * 0.7, 0, Math.PI * 2);
            ctx.stroke();
          }

          // HP bar with 3D effect (scaled to hex size)
          const barWidth = hexSize * 0.85;
          const barHalfWidth = barWidth / 2;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(p.x - barHalfWidth - 2, p.y - hexSize * 0.82, barWidth + 4, 6);
          ctx.fillStyle = '#333';
          ctx.fillRect(p.x - barHalfWidth, p.y - hexSize * 0.78, barWidth, 4);
          const hpPct = Math.max(0, unit.hp / unit.maxHp);
          ctx.fillStyle = hpPct > 0.5 ? 'rgba(0, 255, 0, 0.8)' : hpPct > 0.25 ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
          ctx.fillRect(p.x - barHalfWidth, p.y - hexSize * 0.78, barWidth * hpPct, 4);

          // Mana bar with 3D effect
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(p.x - barHalfWidth - 2, p.y - hexSize * 0.68, barWidth + 4, 5);
          ctx.fillStyle = '#003';
          ctx.fillRect(p.x - barHalfWidth, p.y - hexSize * 0.64, barWidth, 3);
          const manaPct = unit.mana / unit.maxMana;
          ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';
          ctx.fillRect(p.x - barHalfWidth, p.y - hexSize * 0.64, barWidth * manaPct, 3);
        });

        // Draw visual effects
        const now = Date.now();
        visualEffects = visualEffects.filter(fx => now - fx.startTime < fx.duration);

        visualEffects.forEach(fx => {
          const progress = (now - fx.startTime) / fx.duration;
          const alpha = 1 - progress;

          if (fx.type === 'damage' || fx.type === 'heal') {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = fx.color;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';

            // Add glow effect to damage numbers
            if (fx.type === 'damage') {
              ctx.shadowColor = fx.color;
              ctx.shadowBlur = 10;
            } else if (fx.type === 'heal') {
              ctx.shadowColor = '#0f0';
              ctx.shadowBlur = 15;
            }
            ctx.fillText(fx.text, fx.x, fx.y - progress * 30);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'attackLine') {
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = fx.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(fx.x, fx.y);
            ctx.lineTo(fx.x2, fx.y2);
            ctx.stroke();

            // Add glow to attack lines
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 5;
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'status') {
            ctx.globalAlpha = alpha;
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';

            // Add glow effect to status icons
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 12;
            ctx.fillText(fx.text, fx.x, fx.y - progress * 15);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'attackPulse') {
            // Attack pulse animation
            ctx.globalAlpha = alpha * 0.7;

            // Create a multi-layered pulse effect
            const layers = 3;
            for (let i = 0; i < layers; i++) {
              const layerProgress = Math.min(1, progress + (i * 0.2));
              const layerRadius = fx.radius * (1 - layerProgress);

              if (layerProgress < 1) {
                ctx.strokeStyle = fx.color;
                ctx.lineWidth = 2 + (i * 0.5);
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, layerRadius, 0, Math.PI * 2);
                ctx.stroke();
              }
            }

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 10;
            ctx.strokeStyle = fx.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, fx.radius * (1 - progress), 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
          } else if (fx.type === 'deathEffect') {
            // Death explosion animation
            ctx.globalAlpha = alpha;

            // Create a multi-layered explosion effect
            const layers = 3;
            for (let i = 0; i < layers; i++) {
              const layerProgress = Math.min(1, progress + (i * 0.2));
              const layerRadius = fx.radius * layerProgress;

              if (layerProgress < 1) {
                ctx.fillStyle = `rgba(${parseInt(fx.color.slice(1, 3), 16)}, ${parseInt(fx.color.slice(3, 5), 16)}, ${parseInt(fx.color.slice(5, 7), 16)}, ${0.8 - (i * 0.2)})`;
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, layerRadius, 0, Math.PI * 2);
                ctx.fill();
              }
            }

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 20;
            ctx.fillStyle = fx.color;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, fx.radius * progress * 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
          } else if (fx.type === 'abilityEffect') {
            // Ability casting circle animation
            ctx.globalAlpha = alpha * 0.5;

            // Create a multi-layered circle effect
            const layers = 4;
            for (let i = 0; i < layers; i++) {
              const layerProgress = Math.min(1, progress + (i * 0.15));
              const layerRadius = fx.radius * (1 - layerProgress);

              if (layerProgress < 1) {
                ctx.strokeStyle = fx.color;
                ctx.lineWidth = 1 + (i * 0.5);
                ctx.beginPath();
                ctx.arc(fx.x, fx.y, layerRadius, 0, Math.PI * 2);
                ctx.stroke();
              }
            }

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 15;
            ctx.strokeStyle = fx.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, fx.radius * (1 - progress), 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
          } else if (fx.type === 'hitEffect') {
            // Hit effect animation
            ctx.globalAlpha = alpha * 0.8;
            ctx.fillStyle = fx.color;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, 15 * (1 - progress), 0, Math.PI * 2);
            ctx.fill();

            // Add glow effect
            ctx.shadowColor = fx.color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(fx.x, fx.y, 15 * (1 - progress), 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
          } else if (fx.type === 'unitScale') {
            // Unit scaling animation
            const scale = 1 + (0.5 * progress);
            ctx.globalAlpha = alpha;
            // This would be handled by drawing the unit with scaling
            ctx.globalAlpha = 1;
          }
        });
      }

      // Draw round banner
      if (roundBanner) {
        const now = Date.now();
        const elapsed = now - roundBanner.startTime;
        if (elapsed < roundBanner.duration) {
          const progress = elapsed / roundBanner.duration;
          // Fade in for first 20%, hold, fade out for last 20%
          let alpha = 1;
          if (progress < 0.2) alpha = progress / 0.2;
          else if (progress > 0.8) alpha = (1 - progress) / 0.2;

          ctx.globalAlpha = alpha;

          // Dark banner background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);

          // Add glow effect to banner
          ctx.shadowColor = roundBanner.color || '#fff';
          ctx.shadowBlur = 12;

          // Banner text
          ctx.fillStyle = roundBanner.color || '#fff';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(roundBanner.text, canvas.width / 2, canvas.height / 2);

          ctx.shadowBlur = 0;

          // Subtext if present
          if (roundBanner.subtext) {
            ctx.font = '18px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText(roundBanner.subtext, canvas.width / 2, canvas.height / 2 + 28);
          }

          ctx.globalAlpha = 1;
        } else {
          roundBanner = null;
        }
      }
    }

    function renderShop() {
      const shopEl = document.getElementById('shop');
      shopEl.innerHTML = '';
      shopUnits.forEach(id => {
        const u = unitsData[id];
        const synergy = factionSynergies[u.faction];
        const div = document.createElement('div');
        div.className = 'unit';
        div.draggable = true;
        div.style.borderColor = synergy?.color || '#777';
        div.innerHTML = `
          <div class="unit-icon">${u.icon}</div>
          <div class="unit-name">${u.name}</div>
          <div class="unit-cost">${u.cost}g</div>
          <div class="unit-faction" style="color: ${synergy?.color || '#aaa'}">${synergy?.icon || ''} ${u.faction}</div>
        `;
        div.addEventListener('dragstart', e => {
          draggedUnit = { fromShop: true, id, cost: u.cost };
          e.dataTransfer.setData('text/plain', id);
          hideTooltip();
        });
        div.addEventListener('mouseenter', e => {
          showTooltip(id, e.clientX, e.clientY);
        });
        div.addEventListener('mousemove', e => {
          if (tooltipVisible) {
            showTooltip(id, e.clientX, e.clientY);
          }
        });
        div.addEventListener('mouseleave', () => {
          hideTooltip();
        });
        shopEl.appendChild(div);
      });
    }

    // Get max units allowed based on player level (level 1 = 3 units, level 2 = 4, etc.)
    function getMaxUnits() {
      return playerLevel + 2;
    }

    // Get current unit count on board
    function getUnitCount() {
      return Object.keys(playerBoard).length;
    }

    // Check if we can place another unit
    function canPlaceUnit() {
      return getUnitCount() < getMaxUnits();
    }

    // ========== BENCH RENDERING ==========
    function renderBench() {
      const slots = document.querySelectorAll('.bench-slot');
      slots.forEach((slot, index) => {
        const unit = bench[index];
        slot.innerHTML = '';
        slot.classList.remove('occupied');

        if (unit) {
          const data = unitsData[unit.id];
          slot.classList.add('occupied');
          slot.style.borderColor = data.color;

          const starText = '‚≠ê'.repeat(unit.stars);
          slot.innerHTML = `
            <span class="bench-unit">${data.icon}</span>
            <span class="bench-unit-stars">${starText}</span>
            <span class="bench-unit-cost">${data.cost}</span>
          `;
        } else {
          slot.style.borderColor = '#444';
        }
      });
    }

    // Setup bench interactions
    function setupBenchEvents() {
      const slots = document.querySelectorAll('.bench-slot');
      const sellZone = document.getElementById('sell-zone');

      slots.forEach((slot, index) => {
        // Drag start from bench
        slot.addEventListener('mousedown', e => {
          const unit = bench[index];
          if (unit && combatState === 'idle') {
            draggedUnit = {
              fromBench: true,
              id: unit.id,
              stars: unit.stars,
              slotIndex: index,
              cost: unitsData[unit.id].cost
            };
            sellZone.classList.add('active');
            slot.style.opacity = '0.5';
          }
        });

        // Hover for tooltip
        slot.addEventListener('mouseenter', e => {
          const unit = bench[index];
          if (unit && !draggedUnit) {
            showTooltip(unit.id, e.clientX, e.clientY);
          }
        });

        slot.addEventListener('mousemove', e => {
          const unit = bench[index];
          if (unit && tooltipVisible && !draggedUnit) {
            showTooltip(unit.id, e.clientX, e.clientY);
          }
        });

        slot.addEventListener('mouseleave', () => {
          hideTooltip();
        });

        // Drop onto bench slot
        slot.addEventListener('dragover', e => {
          e.preventDefault();
          slot.classList.add('drag-over');
        });

        slot.addEventListener('dragleave', () => {
          slot.classList.remove('drag-over');
        });

        slot.addEventListener('drop', e => {
          e.preventDefault();
          slot.classList.remove('drag-over');

          if (draggedUnit?.fromShop && bench[index] === null) {
            if (NetworkManager.isOnline) {
              // Online: send buy to server
              const shopIdx = shopUnits.indexOf(draggedUnit.id);
              if (shopIdx > -1) {
                NetworkManager.send({ type: 'buy', shopIndex: shopIdx });
              }
            } else {
              // Offline: local buy
              if (gold >= draggedUnit.cost) {
                if (tryAddUnit(draggedUnit.id)) {
                  gold -= draggedUnit.cost;
                  const shopIndex = shopUnits.indexOf(draggedUnit.id);
                  if (shopIndex > -1) shopUnits[shopIndex] = rollShopUnit();
                  renderShop();
                  renderBench();
                  updateUI();
                }
              }
            }
          }
          draggedUnit = null;
        });
      });

      // Sell zone events
      sellZone.addEventListener('dragover', e => {
        e.preventDefault();
        sellZone.classList.add('drag-over');
      });

      sellZone.addEventListener('dragleave', () => {
        sellZone.classList.remove('drag-over');
      });

      sellZone.addEventListener('drop', e => {
        e.preventDefault();
        sellZone.classList.remove('drag-over');
        sellZone.classList.remove('active');

        if (draggedUnit) {
          if (NetworkManager.isOnline) {
            if (draggedUnit.fromBench) {
              NetworkManager.send({ type: 'sell_bench', benchIndex: draggedUnit.slotIndex });
            } else if (draggedUnit.fromBoard) {
              NetworkManager.send({ type: 'sell_board', hexKey: draggedUnit.oldKey });
            }
          } else {
            const sellValue = getSellValue(draggedUnit.cost, draggedUnit.stars || 1);
            gold += sellValue;

            if (draggedUnit.fromBench) {
              bench[draggedUnit.slotIndex] = null;
            } else if (draggedUnit.fromBoard) {
              delete playerBoard[draggedUnit.oldKey];
            }

            renderBench();
            renderBoard();
            renderSynergies();
            updateUI();
          }
        }
        draggedUnit = null;
      });

      // Global mouseup to handle bench drag end
      document.addEventListener('mouseup', e => {
        if (draggedUnit?.fromBench) {
          const slot = document.querySelector(`.bench-slot[data-slot="${draggedUnit.slotIndex}"]`);
          if (slot) slot.style.opacity = '1';

          // Check if dropped on board
          const rect = canvas.getBoundingClientRect();
          if (e.clientX >= rect.left && e.clientX <= rect.right &&
              e.clientY >= rect.top && e.clientY <= rect.bottom) {
            const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
            const hex = getNearestHex(raw);

            if (hex && playerRows.includes(hex.row)) {
              const key = getHexKey(hex);

              if (NetworkManager.isOnline) {
                NetworkManager.send({ type: 'place', benchIndex: draggedUnit.slotIndex, hexKey: key });
              } else {
                const boardUnit = playerBoard[key];

                if (!boardUnit) {
                  // Move from bench to empty board slot (if within cap)
                  if (canPlaceUnit()) {
                    playerBoard[key] = { id: draggedUnit.id, stars: draggedUnit.stars };
                    bench[draggedUnit.slotIndex] = null;

                    // Check for merge on board
                    const matches = checkForMerge(draggedUnit.id, draggedUnit.stars);
                    if (matches) {
                      performMerge(matches, draggedUnit.id, draggedUnit.stars);
                    }
                  }
                } else {
                  // Swap bench unit with board unit
                  playerBoard[key] = { id: draggedUnit.id, stars: draggedUnit.stars };
                  bench[draggedUnit.slotIndex] = { id: boardUnit.id, stars: boardUnit.stars };

                  // Check for merges after swap
                  const boardMatches = checkForMerge(draggedUnit.id, draggedUnit.stars);
                  if (boardMatches) {
                    performMerge(boardMatches, draggedUnit.id, draggedUnit.stars);
                  }
                  const benchMatches = checkForMerge(boardUnit.id, boardUnit.stars);
                  if (benchMatches) {
                    performMerge(benchMatches, boardUnit.id, boardUnit.stars);
                  }
                }
              }
            }
          }

          // Check if dropped on another bench slot
          const benchSlots = document.querySelectorAll('.bench-slot');
          benchSlots.forEach((targetSlot, targetIndex) => {
            const slotRect = targetSlot.getBoundingClientRect();
            if (e.clientX >= slotRect.left && e.clientX <= slotRect.right &&
                e.clientY >= slotRect.top && e.clientY <= slotRect.bottom) {
              if (targetIndex !== draggedUnit.slotIndex) {
                if (NetworkManager.isOnline) {
                  NetworkManager.send({ type: 'bench_swap', fromIndex: draggedUnit.slotIndex, toIndex: targetIndex });
                } else {
                  // Swap or move
                  const targetUnit = bench[targetIndex];
                  bench[targetIndex] = bench[draggedUnit.slotIndex];
                  bench[draggedUnit.slotIndex] = targetUnit;
                }
              }
            }
          });

          sellZone.classList.remove('active');
          renderBench();
          renderBoard();
          renderSynergies();
          updateUI();
          draggedUnit = null;
        }
      });
    }

    function updateUI() {
      document.getElementById('round').textContent = currentRound;
      document.getElementById('gold').textContent = gold;
      document.getElementById('health').textContent = health;
      document.getElementById('level').textContent = playerLevel;
      const unitCapEl = document.getElementById('unitcap');
      unitCapEl.textContent = `${getUnitCount()}/${getMaxUnits()}`;
      // Color code: green if room, yellow if close, red if at cap
      const ratio = getUnitCount() / getMaxUnits();
      unitCapEl.style.color = ratio >= 1 ? '#f44' : ratio >= 0.8 ? '#ff0' : '#4f4';
      document.getElementById('reroll').disabled = gold < 2;
      const lvlCost = 4;  // Fixed 4 gold per level (TFT style)
      document.getElementById('levelup').textContent = `LEVEL UP (${lvlCost}g)`;
      document.getElementById('levelup').disabled = gold < lvlCost || playerLevel >= 9;
      document.getElementById('fight').disabled = combatState !== 'idle';

      // Sync human player state to GameState in multiplayer mode
      if (typeof GameState !== 'undefined' && GameState.mode === 'multiplayer') {
        const human = GameState.getHumanPlayer();
        if (human) {
          human.board = { ...playerBoard };
          human.bench = [...bench];
          human.gold = gold;
          human.level = playerLevel;
          human.health = health;
        }
      }
    }

    // Mouse/Drag events
    canvas.addEventListener('mousedown', e => {
      if (draggedUnit || combatState !== 'idle') return;
      const rect = canvas.getBoundingClientRect();
      const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
      const hex = getNearestHex(raw);
      if (hex && playerRows.includes(hex.row)) {
        const key = getHexKey(hex);
        const unit = playerBoard[key];
        if (unit) {
          draggedUnit = {
            fromBoard: true,
            id: unit.id,
            stars: unit.stars,
            oldKey: key,
            cost: unitsData[unit.id].cost
          };
          document.getElementById('sell-zone').classList.add('active');
          renderBoard();
        }
      }
    });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
      const hex = getNearestHex(raw);
      if (draggedUnit) {
        const targetKey = hex ? getHexKey(hex) : null;
        const isPlayerArea = hex && playerRows.includes(hex.row);

        let valid = false;
        if (isPlayerArea) {
          const targetUnit = playerBoard[getHexKey(hex)];
          const isSameSpot = getHexKey(hex) === draggedUnit.oldKey;

          if (draggedUnit.fromShop) {
            // Shop: can only drop on empty slots if within cap
            valid = !targetUnit && canPlaceUnit();
          } else if (draggedUnit.fromBoard) {
            // Board: can drop on empty or swap with another unit
            valid = !targetUnit || isSameSpot || (targetUnit && !isSameSpot);
          } else if (draggedUnit.fromBench) {
            // Bench: can drop on empty (if cap allows) or swap with board unit
            valid = (!targetUnit && canPlaceUnit()) || (targetUnit && true);
          }
        }

        highlightHex = valid ? hex : null;
        canvas.style.cursor = valid ? 'grab' : 'no-drop';
        hideTooltip(); // Hide tooltip while dragging
      } else {
        highlightHex = null;
        canvas.style.cursor = 'default';

        // Show tooltip for units on board
        if (hex && combatState === 'idle') {
          const key = getHexKey(hex);
          const unitData = playerBoard[key] || enemyBoard[key];
          // Handle both object format {id, stars} and legacy string format
          const unitId = unitData ? (typeof unitData === 'object' ? unitData.id : unitData) : null;
          if (unitId && unitId !== hoveredBoardUnit) {
            hoveredBoardUnit = unitId;
            showTooltip(unitId, e.clientX, e.clientY);
          } else if (unitId && tooltipVisible) {
            // Update position while hovering same unit
            showTooltip(unitId, e.clientX, e.clientY);
          } else if (!unitId) {
            hoveredBoardUnit = null;
            hideTooltip();
          }
        } else if (!hex) {
          hoveredBoardUnit = null;
          hideTooltip();
        }
      }
      renderBoard();
    });

    canvas.addEventListener('mouseup', e => {
      if (!draggedUnit || !draggedUnit.fromBoard) return;

      const sellZone = document.getElementById('sell-zone');
      const sellRect = sellZone.getBoundingClientRect();

      if (NetworkManager.isOnline) {
        // === ONLINE MODE: send actions to server ===
        // Check if dropped on sell zone
        if (sellZone.classList.contains('active') &&
            e.clientX >= sellRect.left && e.clientX <= sellRect.right &&
            e.clientY >= sellRect.top && e.clientY <= sellRect.bottom) {
          NetworkManager.send({ type: 'sell_board', hexKey: draggedUnit.oldKey });
          sellZone.classList.remove('active');
        } else {
          // Check if dropped on bench
          let droppedOnBench = false;
          const benchSlots = document.querySelectorAll('.bench-slot');
          benchSlots.forEach((slot, index) => {
            const slotRect = slot.getBoundingClientRect();
            if (e.clientX >= slotRect.left && e.clientX <= slotRect.right &&
                e.clientY >= slotRect.top && e.clientY <= slotRect.bottom) {
              droppedOnBench = true;
              NetworkManager.send({ type: 'board_to_bench', hexKey: draggedUnit.oldKey, benchIndex: index });
            }
          });

          if (!droppedOnBench) {
            const rect = canvas.getBoundingClientRect();
            const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
            const hex = getNearestHex(raw);
            if (hex && playerRows.includes(hex.row)) {
              const newKey = getHexKey(hex);
              if (newKey !== draggedUnit.oldKey) {
                NetworkManager.send({ type: 'move', fromHex: draggedUnit.oldKey, toHex: newKey });
              }
            }
          }
          sellZone.classList.remove('active');
        }
      } else {
        // === OFFLINE MODE: original local logic ===
        // Check if dropped on sell zone
        if (sellZone.classList.contains('active') &&
            e.clientX >= sellRect.left && e.clientX <= sellRect.right &&
            e.clientY >= sellRect.top && e.clientY <= sellRect.bottom) {
          const sellValue = getSellValue(draggedUnit.cost, draggedUnit.stars);
          gold += sellValue;
          delete playerBoard[draggedUnit.oldKey];
          sellZone.classList.remove('active');
        } else {
          // Check if dropped on bench
          let droppedOnBench = false;
          const benchSlots = document.querySelectorAll('.bench-slot');
          benchSlots.forEach((slot, index) => {
            const slotRect = slot.getBoundingClientRect();
            if (e.clientX >= slotRect.left && e.clientX <= slotRect.right &&
                e.clientY >= slotRect.top && e.clientY <= slotRect.bottom) {
              droppedOnBench = true;
              const benchUnit = bench[index];

              if (benchUnit === null) {
                bench[index] = { id: draggedUnit.id, stars: draggedUnit.stars };
                delete playerBoard[draggedUnit.oldKey];
              } else {
                bench[index] = { id: draggedUnit.id, stars: draggedUnit.stars };
                playerBoard[draggedUnit.oldKey] = { id: benchUnit.id, stars: benchUnit.stars };

                const matches = checkForMerge(benchUnit.id, benchUnit.stars);
                if (matches) {
                  performMerge(matches, benchUnit.id, benchUnit.stars);
                }
              }
            }
          });

          if (!droppedOnBench) {
            const rect = canvas.getBoundingClientRect();
            const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
            const hex = getNearestHex(raw);
            if (hex && playerRows.includes(hex.row)) {
              const newKey = getHexKey(hex);
              if (newKey !== draggedUnit.oldKey) {
                const targetUnit = playerBoard[newKey];

                if (!targetUnit) {
                  delete playerBoard[draggedUnit.oldKey];
                  playerBoard[newKey] = { id: draggedUnit.id, stars: draggedUnit.stars };
                } else {
                  playerBoard[newKey] = { id: draggedUnit.id, stars: draggedUnit.stars };
                  playerBoard[draggedUnit.oldKey] = { id: targetUnit.id, stars: targetUnit.stars };
                }

                const matches = checkForMerge(draggedUnit.id, draggedUnit.stars);
                if (matches) {
                  performMerge(matches, draggedUnit.id, draggedUnit.stars);
                }
              }
            }
          }
          sellZone.classList.remove('active');
        }
      }

      draggedUnit = null;
      highlightHex = null;
      canvas.style.cursor = 'default';
      renderBench();
      renderBoard();
      renderSynergies();
      updateUI();
    });

    canvas.addEventListener('mouseleave', () => {
      hoveredBoardUnit = null;
      hideTooltip();
    });

    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      if (!draggedUnit?.fromShop) return;

      if (NetworkManager.isOnline) {
        // Online: just send buy to server (server handles placement)
        const shopIdx = shopUnits.indexOf(draggedUnit.id);
        if (shopIdx > -1) {
          NetworkManager.send({ type: 'buy', shopIndex: shopIdx });
        }
      } else if (gold >= draggedUnit.cost) {
        const rect = canvas.getBoundingClientRect();
        const raw = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
        const hex = getNearestHex(raw);

        // Dropping directly on board (if space)
        if (hex && playerRows.includes(hex.row) && canPlaceUnit()) {
          const key = getHexKey(hex);
          if (!playerBoard[key]) {
            // First add to bench (for merge logic)
            if (tryAddUnit(draggedUnit.id)) {
              gold -= draggedUnit.cost;
              // Now move from bench to board
              const benchIdx = bench.findIndex(b => b && b.id === draggedUnit.id);
              if (benchIdx !== -1) {
                playerBoard[key] = bench[benchIdx];
                bench[benchIdx] = null;
                // Check for merge on board
                const matches = checkForMerge(draggedUnit.id, playerBoard[key].stars);
                if (matches) {
                  performMerge(matches, draggedUnit.id, playerBoard[key].stars);
                }
              }
              // Remove from shop
              const shopIndex = shopUnits.indexOf(draggedUnit.id);
              if (shopIndex > -1) shopUnits[shopIndex] = rollShopUnit();
              renderShop();
              renderBench();
              updateUI();
              renderSynergies();
            }
          }
        } else {
          // Dropping elsewhere - buy to bench
          if (tryAddUnit(draggedUnit.id)) {
            gold -= draggedUnit.cost;
            const shopIndex = shopUnits.indexOf(draggedUnit.id);
            if (shopIndex > -1) shopUnits[shopIndex] = rollShopUnit();
            renderShop();
            renderBench();
            updateUI();
          }
        }
      }
      draggedUnit = null;
      highlightHex = null;
      renderBoard();
    });

    // FIXED: Proper handlers
    document.getElementById('reroll').onclick = () => {
      if (NetworkManager.isOnline) {
        NetworkManager.send({ type: 'reroll' });
        return;
      }
      if (gold >= 2) {
        gold -= 2;
        shopUnits = Array(5).fill().map(() => rollShopUnit());
        renderShop();
        updateUI();
        // Sync to multiplayer state
        if (GameState.mode === 'multiplayer') {
          const human = GameState.getHumanPlayer();
          human.gold = gold;
          human.shop = [...shopUnits];
        }
      }
    };

    document.getElementById('levelup').onclick = () => {
      if (NetworkManager.isOnline) {
        NetworkManager.send({ type: 'level_up' });
        return;
      }
      const cost = 4;  // Fixed cost of 4 gold per level (TFT style)
      if (gold >= cost && playerLevel < 9) {
        gold -= cost;
        playerLevel++;
        renderSynergies(); // Update synergies (shows unit cap hint)
        updateUI();
        // Sync to multiplayer state
        if (GameState.mode === 'multiplayer') {
          const human = GameState.getHumanPlayer();
          human.gold = gold;
          human.level = playerLevel;
        }
      }
    };

    // ========== COMBAT SYSTEM ==========
    let combatState = 'idle'; // 'idle' | 'combat'
    let combatUnits = [];
    let combatLog = [];
    let lastCombatTime = 0;
    let combatStartTime = 0;
    const COMBAT_TICK_MS = 50;
    // MANA_TO_CAST loaded from shared.js

    // Status effect types
    const STATUS = {
      STUN: 'stun',
      SLOW: 'slow',
      POISON: 'poison',
      SILENCE: 'silence',
      SHIELD: 'shield'
    };

    // createCombatUnit loaded from shared.js

    // Get neighbors of a hex (odd-r offset)
    function getHexNeighbors(hexKey) {
      const [col, row] = hexKey.split(',').map(Number);
      const isOddRow = row & 1;
      const directions = isOddRow
        ? [[1,0], [1,-1], [0,-1], [-1,0], [0,1], [1,1]]
        : [[1,0], [0,-1], [-1,-1], [-1,0], [-1,1], [0,1]];
      return directions
        .map(([dc, dr]) => ({ col: col + dc, row: row + dr }))
        .filter(h => h.col >= 0 && h.col < 7 && h.row >= 0 && h.row < 8)
        .map(h => getHexKey(h));
    }

    // Find path toward target (improved pathfinding)
    function findMoveToward(unit, target, units) {
      const neighbors = getHexNeighbors(unit.hexKey);
      const occupied = new Set(units.filter(u => u.hp > 0 && u !== unit).map(u => u.hexKey));
      const currentDist = hexDistance(unit.hexKey, target.hexKey);

      let bestHex = null;
      let bestDist = currentDist;
      let lateralOptions = []; // Hexes at same distance (for getting around obstacles)

      for (const hex of neighbors) {
        if (occupied.has(hex)) continue;
        const dist = hexDistance(hex, target.hexKey);
        if (dist < bestDist) {
          // Found a closer hex - prefer this
          bestDist = dist;
          bestHex = hex;
          lateralOptions = []; // Clear lateral since we found something better
        } else if (dist === currentDist && !bestHex) {
          // Same distance - track as lateral option for obstacle avoidance
          lateralOptions.push(hex);
        }
      }

      // If no closer hex found, try lateral movement to get around obstacles
      if (!bestHex && lateralOptions.length > 0) {
        // Pick the lateral hex that has the most open neighbors (better pathing potential)
        let bestLateral = null;
        let bestOpenNeighbors = -1;
        for (const lateralHex of lateralOptions) {
          const lateralNeighbors = getHexNeighbors(lateralHex);
          const openCount = lateralNeighbors.filter(n => !occupied.has(n)).length;
          // Also prefer hexes that are in the general direction of the target
          const [lc, lr] = lateralHex.split(',').map(Number);
          const [tc, tr] = target.hexKey.split(',').map(Number);
          const [uc, ur] = unit.hexKey.split(',').map(Number);
          // Check if this lateral move is in the right general direction
          const towardTarget = (Math.sign(tc - uc) === Math.sign(lc - uc) || Math.sign(tc - uc) === 0) &&
                               (Math.sign(tr - ur) === Math.sign(lr - ur) || Math.sign(tr - ur) === 0);
          const directionBonus = towardTarget ? 3 : 0;
          if (openCount + directionBonus > bestOpenNeighbors) {
            bestOpenNeighbors = openCount + directionBonus;
            bestLateral = lateralHex;
          }
        }
        bestHex = bestLateral;
      }

      return bestHex;
    }

    function findNearestEnemy(unit, units) {
      let nearest = null;
      let minDist = Infinity;
      for (const other of units) {
        if (other.isPlayer === unit.isPlayer || other.hp <= 0) continue;
        const dist = hexDistance(unit.hexKey, other.hexKey);
        if (dist < minDist) {
          minDist = dist;
          nearest = other;
        }
      }
      return { target: nearest, distance: minDist };
    }

    function hasStatus(unit, type) {
      return unit.statusEffects.some(s => s.type === type);
    }

    function getStatusValue(unit, type) {
      const effect = unit.statusEffects.find(s => s.type === type);
      return effect ? effect.value : 0;
    }

    function applyStatus(unit, type, duration, value = 0) {
      // Remove existing of same type
      unit.statusEffects = unit.statusEffects.filter(s => s.type !== type);
      unit.statusEffects.push({ type, duration, value, startTime: Date.now() });

      const name = unitsData[unit.id].name;
      if (type === STATUS.STUN) combatLog.push(`${name} is STUNNED for ${(duration/1000).toFixed(1)}s!`);
      else if (type === STATUS.SLOW) combatLog.push(`${name} is SLOWED ${value}%!`);
      else if (type === STATUS.POISON) combatLog.push(`${name} is POISONED for ${value} dmg/sec!`);
      else if (type === STATUS.SHIELD) combatLog.push(`${name} gains ${value} SHIELD!`);
    }

    function updateStatusEffects(unit, deltaTime) {
      const now = Date.now();
      // Process poison damage
      const poison = unit.statusEffects.find(s => s.type === STATUS.POISON);
      if (poison) {
        const tickDamage = poison.value * (deltaTime / 1000);
        unit.hp -= tickDamage;
      }

      // Update speed based on slow
      const slow = unit.statusEffects.find(s => s.type === STATUS.SLOW);
      if (slow) {
        unit.speed = unit.baseSpeed * (1 - slow.value / 100);
        unit.actionCooldown = 1000 / unit.speed;
        unit.moveCooldown = 600 / unit.speed;
      } else {
        unit.speed = unit.baseSpeed;
        unit.actionCooldown = 1000 / unit.speed;
        unit.moveCooldown = 600 / unit.speed;
      }

      // Remove expired effects
      unit.statusEffects = unit.statusEffects.filter(s => now - s.startTime < s.duration);
    }

    function calculateDamage(attacker, defender, baseDamage) {
      // Armor reduces damage: damage * 100 / (100 + armor)
      const armorReduction = 100 / (100 + defender.armor);
      let damage = baseDamage * armorReduction;

      // Apply flat damage reduction (Tank class bonus)
      if (defender.damageReduction && defender.damageReduction > 0) {
        damage = damage * (1 - defender.damageReduction / 100);
      }

      // Shield absorbs damage
      const shield = defender.statusEffects.find(s => s.type === STATUS.SHIELD);
      if (shield) {
        if (shield.value >= damage) {
          shield.value -= damage;
          return 0;
        } else {
          damage -= shield.value;
          defender.statusEffects = defender.statusEffects.filter(s => s.type !== STATUS.SHIELD);
        }
      }

      // Persian synergy: Damage reflect
      if (defender.isPlayer) {
        const persianSynergy = activeCombatSynergies['Persian'];
        if (persianSynergy?.damage_reflect && defender.faction === 'Persian') {
          const reflectDamage = damage * persianSynergy.damage_reflect / 100;
          attacker.hp -= reflectDamage;
          if (reflectDamage > 5) {
            addDamageNumber(attacker.hexKey, reflectDamage);
          }
        }
      }

      return damage;
    }

    function executeAbility(unit, target, trigger) {
      const abl = unit.ability;
      if (!abl || !abl.effect) return;
      if (abl.trigger !== trigger) return;

      // Add ability particles at unit location
      const unitHex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
      if (unitHex) {
        const unitPos = hexToPixel(unitHex);
        addAbilityParticles(unitPos.x, unitPos.y, unit.color);
      }

      const effect = abl.effect;
      const attackerName = unitsData[unit.id].name;
      const targetName = target ? unitsData[target.id].name : '';

      // Gold effects
      if (effect.gold_per_attack) {
        gold += effect.gold_per_attack;
        combatLog.push(`${attackerName}'s ${abl.name}: +${effect.gold_per_attack}g!`);
      }
      if (effect.gold_steal && target) {
        if (!effect.once_per_target || !unit.attackedTargets.has(target.hexKey)) {
          gold += effect.gold_steal;
          combatLog.push(`${attackerName} steals ${effect.gold_steal}g!`);
          if (effect.once_per_target) unit.attackedTargets.add(target.hexKey);
        }
      }
      if (effect.gold_drop_chance && Math.random() * 100 < effect.gold_drop_chance) {
        gold += effect.gold_drop;
        combatLog.push(`${attackerName}'s ${abl.name}: +${effect.gold_drop}g drop!`);
      }

      // Damage effects
      if (effect.damage_mult && target) {
        const bonusDmg = unit.attack * (effect.damage_mult - 1);
        const finalDmg = calculateDamage(unit, target, bonusDmg);
        target.hp -= finalDmg;
        combatLog.push(`${abl.name} deals ${Math.round(finalDmg)} bonus damage!`);
      }

      // Self heal
      if (effect.self_heal) {
        const heal = unit.maxHp * effect.self_heal / 100;
        unit.hp = Math.min(unit.maxHp, unit.hp + heal);
        addHealNumber(unit.hexKey, heal);
        combatLog.push(`${attackerName} heals for ${Math.round(heal)}!`);
      }
      if (effect.self_heal_on_damage && target) {
        const heal = unit.attack * effect.self_heal_on_damage / 100;
        unit.hp = Math.min(unit.maxHp, unit.hp + heal);
        addHealNumber(unit.hexKey, heal);
      }

      // Status effects
      if (effect.attack_speed_slow && target) {
        applyStatus(target, STATUS.SLOW, (effect.duration || 3) * 1000, effect.attack_speed_slow);
      }
      if (effect.poison && target) {
        applyStatus(target, STATUS.POISON, effect.poison.duration * 1000, effect.poison.damage);
      }
      if (effect.bleed && target) {
        applyStatus(target, STATUS.POISON, effect.bleed.duration * 1000, effect.bleed.damage / effect.bleed.duration);
      }
      if (effect.stun && target) {
        applyStatus(target, STATUS.STUN, effect.stun * 1000);
      }
      if (effect.root && target) {
        applyStatus(target, STATUS.STUN, effect.root.duration * 1000);
      }
      if (effect.silence && target) {
        applyStatus(target, STATUS.SILENCE, effect.silence * 1000);
      }

      // AOE effects
      if (effect.aoe_stun) {
        const radius = effect.aoe_stun.radius || 2;
        const duration = (effect.aoe_stun.duration || effect.aoe_stun) * 1000;
        combatUnits.filter(u => u.isPlayer !== unit.isPlayer && u.hp > 0)
          .filter(u => hexDistance(unit.hexKey, u.hexKey) <= radius)
          .forEach(u => applyStatus(u, STATUS.STUN, duration));
      }
      if (effect.aoe_slow) {
        const radius = effect.aoe_slow.radius || 2;
        const percent = effect.aoe_slow.percent || effect.aoe_slow;
        combatUnits.filter(u => u.isPlayer !== unit.isPlayer && u.hp > 0)
          .filter(u => hexDistance(unit.hexKey, u.hexKey) <= radius)
          .forEach(u => applyStatus(u, STATUS.SLOW, 3000, percent));
      }

      // Ally buffs
      if (effect.ally_shield) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.hp > 0)
          .forEach(u => applyStatus(u, STATUS.SHIELD, (effect.duration || 5) * 1000, effect.ally_shield));
      }
      if (effect.ally_damage_amp) {
        // Simplified: just boost attack temporarily
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.hp > 0)
          .forEach(u => { u.attack = u.baseAttack * (1 + effect.ally_damage_amp / 100); });
      }

      // Crit chance
      if (effect.crit_chance && target && Math.random() * 100 < effect.crit_chance) {
        const critMult = effect.crit_mult || 2;
        const critDmg = unit.attack * (critMult - 1);
        const finalCrit = calculateDamage(unit, target, critDmg);
        target.hp -= finalCrit;
        addDamageNumber(target.hexKey, finalCrit, true); // true = crit (yellow)
        addStatusIcon(unit.hexKey, 'üí•');
        combatLog.push(`CRIT! ${Math.round(finalCrit)} bonus damage!`);
      }

      // Execute low HP
      if (effect.execute_threshold && target) {
        const threshold = target.maxHp * effect.execute_threshold / 100;
        if (target.hp > 0 && target.hp < threshold) {
          target.hp = 0;
          combatLog.push(`${attackerName} EXECUTES ${targetName}!`);
        }
      }

      // Damage reduction (passive armor)
      if (effect.damage_reduction) {
        unit.armor += effect.damage_reduction;
      }
      if (effect.armor) {
        unit.armor += effect.armor;
      }
    }

    function executePassives(unit) {
      const abl = unit.ability;
      if (!abl || abl.trigger !== 'passive' || !abl.effect) return;

      const effect = abl.effect;

      // Ally-wide passives
      if (effect.ally_attack_speed) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.faction === unit.faction && u.hp > 0)
          .forEach(u => {
            u.speed = u.baseSpeed * (1 + effect.ally_attack_speed / 100);
            u.actionCooldown = 1000 / u.speed;
          });
      }
      if (effect.ally_hp_amp) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.faction === unit.faction && u.hp > 0)
          .forEach(u => {
            const bonus = u.maxHp * effect.ally_hp_amp / 100;
            u.maxHp += bonus;
            u.hp += bonus;
          });
      }
      if (effect.ally_armor) {
        combatUnits.filter(u => u.isPlayer === unit.isPlayer && u.faction === unit.faction && u.hp > 0)
          .forEach(u => { u.armor += effect.ally_armor; });
      }
      if (effect.ally_crit) {
        // Store for later use in attacks
        unit.bonusCrit = effect.ally_crit;
      }
      if (effect.damage_reduction) {
        unit.armor += effect.damage_reduction;
      }
      if (effect.armor) {
        unit.armor += effect.armor;
      }
    }

    function processCombatTick(deltaTime) {
      const now = Date.now();

      // Timeout safety (60s max)
      if (now - combatStartTime > 60000) {
        const playerHp = combatUnits.filter(u => u.isPlayer && u.hp > 0).reduce((s, u) => s + u.hp, 0);
        const enemyHp = combatUnits.filter(u => !u.isPlayer && u.hp > 0).reduce((s, u) => s + u.hp, 0);
        endCombat(playerHp >= enemyHp);
        return;
      }

      let playerAlive = false, enemyAlive = false;

      // Sort by speed for turn order
      const sortedUnits = [...combatUnits].sort((a, b) => b.speed - a.speed);

      for (const unit of sortedUnits) {
        if (unit.hp <= 0) {
          // Check for Ragdoll revive synergy
          if (unit.isPlayer && !unit.hasRevived) {
            const ragdollSynergy = activeCombatSynergies['Ragdoll'];
            if (ragdollSynergy?.revive_pct && unit.faction === 'Ragdoll') {
              unit.hp = unit.maxHp * ragdollSynergy.revive_pct / 100;
              unit.hasRevived = true;
              addStatusIcon(unit.hexKey, 'üé≠');
              addHealNumber(unit.hexKey, unit.hp);
              combatLog.push(`${unitsData[unit.id].name} goes LIMP and REVIVES with ${Math.round(unit.hp)} HP!`);
            }
          }
          if (unit.hp <= 0) continue;
        }
        if (unit.isPlayer) playerAlive = true;
        else enemyAlive = true;

        // Update status effects
        updateStatusEffects(unit, deltaTime);
        if (unit.hp <= 0) {
          combatLog.push(`${unitsData[unit.id].name} dies from poison!`);
          continue;
        }

        // Apply synergy healing over time
        if (unit.isPlayer) {
          // Maine Coon synergy: lifesteal is handled on attack (see lifesteal code below)

          // Sphynx synergy: disease spread is passive on poison application
        }

        // Stunned units can't act
        if (hasStatus(unit, STATUS.STUN)) continue;

        // Passive mana regen
        unit.mana = Math.min(unit.maxMana, unit.mana + deltaTime * 0.02);

        const { target, distance } = findNearestEnemy(unit, combatUnits);
        if (!target) continue;

        // In range: try to attack
        if (distance <= unit.range) {
          if (now - unit.lastActionTime >= unit.actionCooldown) {
            // Check for on-cast ability with full mana
            if (unit.mana >= MANA_TO_CAST && unit.ability?.trigger === 'on-cast' && !hasStatus(unit, STATUS.SILENCE)) {
              addStatusIcon(unit.hexKey, '‚ú®');
              combatLog.push(`${unitsData[unit.id].name} casts ${unit.ability.name}!`);
              executeAbility(unit, target, 'on-cast');
              unit.mana = 0;
            }

            // Calculate base damage with damage amp
            let baseDamage = unit.attack;
            if (unit.damageAmp) {
              baseDamage = baseDamage * (1 + unit.damageAmp / 100);
            }

            // Check for bonus damage vs diseased targets (Sphynx synergy)
            if (unit.damageVsPoisoned && hasStatus(target, STATUS.POISON)) {
              baseDamage = baseDamage * (1 + unit.damageVsPoisoned / 100);
              addStatusIcon(unit.hexKey, 'ü¶†');
            }

            // Check for critical hit (synergy bonus)
            let isCrit = false;
            if (unit.critChance && Math.random() * 100 < unit.critChance) {
              isCrit = true;
              baseDamage = baseDamage * (unit.critDamage / 100);
              addStatusIcon(unit.hexKey, 'üí•');
              playHiss(); // HISS on crit!

              // Mana on hit (Siamese synergy)
              const siameseSynergy = activeCombatSynergies['Siamese'];
              if (siameseSynergy?.mana_on_hit && unit.faction === 'Siamese') {
                unit.mana = Math.min(unit.maxMana, unit.mana + siameseSynergy.mana_on_hit);
              }
            }

            const damage = calculateDamage(unit, target, baseDamage);
            target.hp -= damage;
            unit.lastActionTime = now;
            unit.mana = Math.min(unit.maxMana, unit.mana + 10); // Mana on attack

            // Meow on every 5th attack!
            maybePlayAttackMeow();

            // Apply lifesteal (Maine Coon synergy)
            if (unit.lifesteal && damage > 0) {
              const healAmount = damage * unit.lifesteal / 100;
              unit.hp = Math.min(unit.maxHp, unit.hp + healAmount);
              if (healAmount > 5) {
                addHealNumber(unit.hexKey, healAmount);
              }
            }

            // Apply disease on hit (Sphynx synergy)
            if (unit.poisonOnHit && !hasStatus(target, STATUS.POISON)) {
              applyStatus(target, STATUS.POISON, 4000, unit.poisonOnHit);
              addStatusIcon(target.hexKey, 'ü¶†');
            }

            // Visual feedback
            addCombatHitEffect(unit, target, damage, isCrit);

            // Add attack animation
            unitAnimations[unit.hexKey] = { type: 'attack', startTime: Date.now() };

            // Trigger sprite animations
            setUnitAnimation(unit.id, 'attack');
            setUnitAnimation(target.id, 'hurt');
            const attackerHex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
            if (attackerHex) {
              const pos = hexToPixel(attackerHex);
              addAttackParticles(pos.x, pos.y, unit.color);
            }

            combatLog.push(`${unitsData[unit.id].name} hits ${unitsData[target.id].name} for ${Math.round(damage)}${isCrit ? ' CRIT!' : ''} (${Math.round(Math.max(0, target.hp))} HP)`);

            // Check for execute (Bengal synergy)
            if (unit.executeThreshold && target.hp > 0) {
              const threshold = target.maxHp * unit.executeThreshold / 100;
              if (target.hp < threshold) {
                target.hp = 0;
                addStatusIcon(target.hexKey, 'üêÜ');
                combatLog.push(`${unitsData[unit.id].name} POUNCES and EXECUTES ${unitsData[target.id].name}!`);
              }
            }

            // On-attack abilities
            if (!hasStatus(unit, STATUS.SILENCE)) {
              executeAbility(unit, target, 'on-attack');
            }

            if (target.hp <= 0) {
              combatLog.push(`${unitsData[target.id].name} defeated!`);

              // Add death animation
              unitAnimations[target.hexKey] = { type: 'death', startTime: Date.now(), deathTime: Date.now() };
              setUnitAnimation(target.id, 'death');
              addDeathExplosion(target.hexKey);

              // Sad death meow üòø
              playDeathMeow();
            }
          }
        } else {
          // Out of range: move toward enemy
          if (now - unit.lastMoveTime >= unit.moveCooldown) {
            const newHex = findMoveToward(unit, target, combatUnits);
            if (newHex) {
              // Update board state for rendering
              if (unit.isPlayer) {
                delete playerBoard[unit.hexKey];
                playerBoard[newHex] = unit.id;
              } else {
                delete enemyBoard[unit.hexKey];
                enemyBoard[newHex] = unit.id;
              }
              unit.hexKey = newHex;
              unit.lastMoveTime = now;
              setUnitAnimation(unit.id, 'walk');
            }
          }
        }
      }

      // Check win/lose
      playerAlive = combatUnits.some(u => u.isPlayer && u.hp > 0);
      enemyAlive = combatUnits.some(u => !u.isPlayer && u.hp > 0);

      if (!playerAlive || !enemyAlive) {
        endCombat(playerAlive);
      }
    }

    // Get combined synergy bonuses for a faction
    function getSynergyBonuses() {
      const { activeSynergies } = calculateSynergies();
      const bonuses = {};

      Object.entries(activeSynergies).forEach(([faction, data]) => {
        if (data.activeBonus) {
          bonuses[faction] = data.activeBonus;
        }
      });

      return bonuses;
    }

    // Track active synergies for combat effects
    let activeCombatSynergies = {};

    function startCombat() {
      if (Object.keys(playerBoard).length === 0) {
        alert('Place some units first!');
        return;
      }
      if (combatState !== 'idle') return;

      // Save pre-combat positions for reset after combat
      preCombatBoard = { ...playerBoard };

      combatState = 'combat';
      combatUnits = [];
      combatLog = [];
      visualEffects = []; // Clear visual effects
      combatStartTime = Date.now();
      lastCombatTime = combatStartTime;

      // Calculate synergy bonuses for this combat
      const synergyBonuses = getSynergyBonuses();
      activeCombatSynergies = synergyBonuses;

      // Log active synergies
      const activeSynergyNames = Object.entries(synergyBonuses)
        .map(([faction, bonus]) => `${factionSynergies[faction].name}: ${bonus.description}`)
        .filter(Boolean);
      if (activeSynergyNames.length > 0) {
        combatLog.push(`=== ACTIVE SYNERGIES ===`);
        activeSynergyNames.forEach(s => combatLog.push(`‚Ä¢ ${s}`));
      }

      // Show round banner
      roundBanner = {
        text: `ROUND ${currentRound}`,
        subtext: 'FIGHT!',
        color: '#ffd700',
        startTime: Date.now(),
        duration: 1500
      };

      // Create player combat units with synergy bonuses and star levels
      Object.entries(playerBoard).forEach(([key, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;
        const unit = createCombatUnit(unitId, key, true, synergyBonuses, stars);
        if (unit) {
          unit.stars = stars; // Store for display
          combatUnits.push(unit);
        }
      });

      // Spawn enemies in rows 0-3 (enemy half of board)
      enemyBoard = {};
      const enemyCount = Math.min(3 + currentRound, 12); // Scale with round, not level
      const enemyHexes = boardHexes.filter(h => h.row <= 3);

      // Shuffle enemy hexes for variety
      const shuffledHexes = [...enemyHexes].sort(() => Math.random() - 0.5);

      // Scale enemy star levels with round
      const getEnemyStars = () => {
        if (currentRound >= 15) return Math.random() < 0.3 ? 3 : 2;
        if (currentRound >= 8) return Math.random() < 0.5 ? 2 : 1;
        if (currentRound >= 4) return Math.random() < 0.3 ? 2 : 1;
        return 1;
      };

      // Prefer higher cost units in later rounds
      const getEnemyUnitId = () => {
        const maxTier = Math.min(5, 1 + Math.floor(currentRound / 3));
        const availableTiers = [];
        for (let t = 1; t <= maxTier; t++) {
          if (unitsByTier[t] && unitsByTier[t].length > 0) {
            // Weight higher tiers more in later rounds
            const weight = t <= maxTier - 1 ? 1 : 2;
            for (let w = 0; w < weight; w++) {
              availableTiers.push(...unitsByTier[t]);
            }
          }
        }
        return availableTiers[Math.floor(Math.random() * availableTiers.length)];
      };

      for (let i = 0; i < enemyCount && i < shuffledHexes.length; i++) {
        const hex = shuffledHexes[i];
        const key = getHexKey(hex);
        const unitId = getEnemyUnitId();
        const stars = getEnemyStars();
        enemyBoard[key] = { id: unitId, stars: stars };
      }

      Object.entries(enemyBoard).forEach(([key, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;
        const unit = createCombatUnit(unitId, key, false, null, stars);
        if (unit) {
          unit.stars = stars;
          combatUnits.push(unit);
        }
      });

      // Execute passive abilities at combat start
      combatUnits.forEach(u => executePassives(u));

      // Add initial combat animations
      combatUnits.forEach(u => {
        if (u.isPlayer) {
          // Add a subtle glow effect to player units at start
          const hex = boardHexes.find(h => getHexKey(h) === u.hexKey);
          if (hex) {
            const p = hexToPixel(hex);
            addAbilityEffect(p.x, p.y, u.color, 30);
          }
        }
      });

      // Add initial combat animations
      combatUnits.forEach(u => {
        if (u.isPlayer) {
          // Add a subtle glow effect to player units at start
          const hex = boardHexes.find(h => getHexKey(h) === u.hexKey);
          if (hex) {
            const p = hexToPixel(hex);
            addAbilityEffect(p.x, p.y, u.color, 30);
          }
        }
      });

      combatLog.push(`=== COMBAT START ===`);
      combatLog.push(`Your army: ${combatUnits.filter(u => u.isPlayer).length} units`);
      combatLog.push(`Enemy army: ${combatUnits.filter(u => !u.isPlayer).length} units`);

      document.getElementById('combatLog').style.display = 'block';
      updateCombatLog();
      renderBoard();
      requestAnimationFrame(combatLoop);
    }

    function combatLoop() {
      if (combatState !== 'combat') return;

      const now = Date.now();
      const delta = now - lastCombatTime;

      if (delta >= COMBAT_TICK_MS) {
        processCombatTick(delta);
        lastCombatTime = now;
        renderBoard();
        updateCombatLog();
      }

      if (combatState === 'combat') {
        requestAnimationFrame(combatLoop);
      }
    }

    // Add attack animation to units when they attack
    function addUnitAttackAnimation(attacker, target) {
      const attackerHex = boardHexes.find(h => getHexKey(h) === attacker.hexKey);
      const targetHex = boardHexes.find(h => getHexKey(h) === target.hexKey);

      if (attackerHex && targetHex) {
        const attackerPos = hexToPixel(attackerHex);
        const targetPos = hexToPixel(targetHex);

        // Add attack pulse effect
        addAttackPulse(attackerPos.x, attackerPos.y, attacker.color, 40);

        // Add attack line effect
        visualEffects.push({
          type: 'attackLine',
          x: attackerPos.x,
          y: attackerPos.y,
          x2: targetPos.x,
          y2: targetPos.y,
          color: attacker.color,
          startTime: Date.now(),
          duration: 300
        });
      }
    }

    function updateCombatLog() {
      const logEl = document.getElementById('combatLog');
      logEl.innerHTML = combatLog.slice(-20).map(line => `<div>${line}</div>`).join('');
      logEl.scrollTop = logEl.scrollHeight;
    }

    function endCombat(playerWon) {
      // In multiplayer mode, use the multiplayer end combat handler
      if (typeof GameState !== 'undefined' && GameState.mode === 'multiplayer') {
        endMultiplayerCombat(playerWon);
        return;
      }

      combatState = 'idle';

      const survivors = combatUnits.filter(u => u.isPlayer && u.hp > 0).length;
      const totalPlayerUnits = Object.keys(preCombatBoard).length;
      const enemiesKilled = combatUnits.filter(u => !u.isPlayer && u.hp <= 0).length;

      // Calculate Alley synergy gold bonus
      let synergyGoldBonus = 0;
      const alleySynergy = activeCombatSynergies['Alley'];
      if (alleySynergy?.gold_per_round) {
        synergyGoldBonus = alleySynergy.gold_per_round;
      }

      // Show result banner
      if (playerWon) {
        const baseGold = 5 + Math.floor(enemiesKilled / 2);
        const totalGold = baseGold + synergyGoldBonus;
        gold += totalGold;
        combatLog.push(`=== VICTORY! ===`);
        combatLog.push(`+${baseGold} gold (${survivors} survivors)`);
        if (synergyGoldBonus > 0) {
          combatLog.push(`+${synergyGoldBonus} gold (Alley synergy)`);
        }

        roundBanner = {
          text: 'VICTORY!',
          subtext: synergyGoldBonus > 0 ? `+${totalGold} gold (+${synergyGoldBonus} Alley)` : `+${baseGold} gold`,
          color: '#4f4',
          startTime: Date.now(),
          duration: 2000
        };
      } else {
        const damage = 5 + combatUnits.filter(u => !u.isPlayer && u.hp > 0).length * 2;
        health -= damage;
        // Still give Alley synergy gold on loss
        if (synergyGoldBonus > 0) {
          gold += synergyGoldBonus;
          combatLog.push(`+${synergyGoldBonus} gold (Alley synergy)`);
        }
        combatLog.push(`=== DEFEAT! ===`);
        combatLog.push(`-${damage} health`);

        roundBanner = {
          text: 'DEFEAT',
          subtext: `-${damage} health`,
          color: '#f44',
          startTime: Date.now(),
          duration: 2000
        };
      }

      // Restore player board to pre-combat positions (units reset)
      playerBoard = { ...preCombatBoard };

      // Increment round
      currentRound++;

      updateUI();
      enemyBoard = {};

      setTimeout(() => {
        document.getElementById('combatLog').style.display = 'none';

        // Auto-refresh shop each round
        shopUnits = Array(5).fill().map(() => rollShopUnit());
        renderShop();

        // Show "Preparing Round X" banner
        roundBanner = {
          text: `ROUND ${currentRound}`,
          subtext: 'Prepare your units!',
          color: '#fff',
          startTime: Date.now(),
          duration: 1500
        };

        renderBoard();
        renderBench();
        renderSynergies(); // Update synergies panel after combat

        if (health <= 0) {
          setTimeout(() => {
            alert('GAME OVER! You have been eliminated.');
            health = 100;
            gold = 50;
            playerLevel = 1;
            currentRound = 1;
            playerBoard = {};
            bench = Array(9).fill(null);
            preCombatBoard = {};
            shopUnits = Array(5).fill().map(() => rollShopUnit());
            renderShop();
            renderBench();
            updateUI();
            renderBoard();
          }, 500);
        }
      }, 2000);
    }

    document.getElementById('fight').onclick = startCombat;

    // Animation loop - always render for background animation
    function animationLoop() {
      if (combatState === 'idle') {
        renderBoard();
      }
      requestAnimationFrame(animationLoop);
    }

    function addUnitAbilityAnimation(unit) {
      const hex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
      if (hex) {
        const p = hexToPixel(hex);
        addAbilityEffect(p.x, p.y, unit.color, 60);
      }
    }

    // Function to trigger various combat animations
    function triggerCombatAnimation(unit, animationType) {
      switch(animationType) {
        case 'attack':
          // Attack animation is handled in addUnitAttackAnimation
          break;
        case 'death':
          addUnitDeathAnimation(unit);
          break;
        case 'ability':
          addUnitAbilityAnimation(unit);
          break;
        case 'hit':
          // Add a hit flash effect
          const hex = boardHexes.find(h => getHexKey(h) === unit.hexKey);
          if (hex) {
            const p = hexToPixel(hex);
            addAttackPulse(p.x, p.y, unit.color, 20);
          }
          break;
      }
    }

    function init() {
      shopUnits = Array(5).fill().map(() => rollShopUnit());
      renderShop();
      renderBoard();
      renderBench();
      setupBenchEvents();
      updateUI();
      renderSynergies(); // Initialize synergies panel

      // Show initial round banner
      roundBanner = {
        text: `ROUND ${currentRound}`,
        subtext: 'Place your units and FIGHT!',
        color: '#ffd700',
        startTime: Date.now(),
        duration: 2000
      };

      // Start animation loop
      requestAnimationFrame(animationLoop);
    }

    // Load unit images
    function loadUnitImages() {
      const unitImageMap = {
        'alley_tabby_thug': 'alley_tabby_thug.png',
        'alley_ginger_rogue': 'alley_ginger_rogue.png',
        'alley_tuxedo_con': 'alley_tuxedo_con.png',
        'alley_street_yowler': 'alley_street_yowler.png',
        'alley_dumpster_king': 'alley_dumpster_king.png',
        'alley_feral_boss': 'alley_feral_boss.png',
        'persian_princess': 'persian_princess.png',
        'persian_pampered': 'persian_pampered.png',
        'persian_groomer': 'persian_groomer.png',
        'persian_snob': 'persian_snob.png',
        'persian_himalayan': 'persian_himalayan.png',
        'persian_emperor': 'persian_emperor.png',
        'siamese_screamer': 'siamese_screamer.png',
        'siamese_chatterbox': 'siamese_chatterbox.png',
        'siamese_soprano': 'siamese_soprano.png',
        'siamese_gossip': 'siamese_gossip.png',
        'siamese_opera': 'siamese_opera.png',
        'siamese_conductor': 'siamese_conductor.png',
        'mainecoon_titan': 'mainecoon_titan.png',
        'mainecoon_cub': 'mainecoon_cub.png',
        'mainecoon_guardian': 'mainecoon_guardian.png',
        'mainecoon_brawler': 'mainecoon_brawler.png',
        'mainecoon_elder': 'mainecoon_elder.png',
        'mainecoon_alpha': 'mainecoon_alpha.png',
        'bengal_stalker': 'bengal_stalker.png',
        'bengal_kitten': 'bengal_kitten.png',
        'bengal_hunter': 'bengal_hunter.png',
        'bengal_assassin': 'bengal_assassin.png',
        'bengal_pack_leader': 'bengal_pack_leader.png',
        'bengal_apex': 'bengal_apex.png',
        'sphynx_menace': 'sphynx_menace.png',
        'sphynx_creeper': 'sphynx_creeper.png',
        'sphynx_warmer': 'sphynx_warmer.png',
        'sphynx_cultist': 'sphynx_cultist.png',
        'sphynx_oracle': 'sphynx_oracle.png',
        'sphynx_overlord': 'sphynx_overlord.png',
        'scottish_gambler': 'scottish_gambler.png',
        'scottish_lucky': 'scottish_lucky.png',
        'scottish_dealer': 'scottish_dealer.png',
        'scottish_bettor': 'scottish_bettor.png',
        'scottish_fortune': 'scottish_fortune.png',
        'scottish_jackpot': 'scottish_jackpot.png',
        'ragdoll_faker': 'ragdoll_faker.png',
        'ragdoll_lazy': 'ragdoll_lazy.png',
        'ragdoll_flopper': 'ragdoll_flopper.png',
        'ragdoll_dreamer': 'ragdoll_dreamer.png',
        'ragdoll_therapist': 'ragdoll_therapist.png',
        'ragdoll_zen': 'ragdoll_zen.png'
      };

      // Load all images
      Object.keys(unitImageMap).forEach(unitId => {
        const img = new Image();
        img.src = 'assets/images/units/' + unitId + '.png';
        img.onload = function() {
          unitImages[unitId] = img;
        };
        img.onerror = function() {
//          console.warn(`Failed to load image for unit: ${unitId}`);
        };
      });
    }

    // ========== MULTIPLAYER UI FUNCTIONS ==========

    // Render the scoreboard
    function renderScoreboard() {
      if (GameState.mode !== 'multiplayer') return;

      const list = document.getElementById('scoreboard-list');
      if (!list) return;

      // Sort players by health (alive first), then by placement
      const sortedPlayers = [...GameState.players].sort((a, b) => {
        if (a.isAlive && !b.isAlive) return -1;
        if (!a.isAlive && b.isAlive) return 1;
        return b.health - a.health;
      });

      list.innerHTML = sortedPlayers.map(player => {
        const isHuman = player.id === GameState.humanPlayerIndex;
        const isFighting = GameState.phase === 'combat' &&
          MultiplayerCombat.activeBattles.some(b =>
            (b.playerA === player.id || b.playerB === player.id));

        let classes = 'scoreboard-player';
        if (!player.isAlive) classes += ' eliminated';
        if (isHuman) classes += ' current';
        if (isFighting) classes += ' fighting';

        const healthClass = player.health > 50 ? 'healthy' : '';
        const streakText = player.streak > 0 ? `W${player.streak}` :
                          player.streak < 0 ? `L${Math.abs(player.streak)}` : '-';
        const streakClass = player.streak > 0 ? 'win' : player.streak < 0 ? 'loss' : '';

        return `
          <div class="${classes}">
            <div class="player-color" style="background: ${player.color}"></div>
            <div class="player-name">${player.name}${isHuman ? ' (You)' : ''}</div>
            <div class="player-health ${healthClass}">‚ù§Ô∏è${player.health}</div>
            <div class="player-gold">üí∞${player.gold}</div>
            <div class="player-streak ${streakClass}">${streakText}</div>
          </div>
        `;
      }).join('');
    }

    // Show matchup result
    function showMatchupResult(result) {
      const display = document.getElementById('matchup-display');
      const playerAEl = document.getElementById('matchup-player-a');
      const playerBEl = document.getElementById('matchup-player-b');
      const resultEl = document.getElementById('matchup-result');
      const damageEl = document.getElementById('matchup-damage');

      const playerA = GameState.players[result.playerA];
      const playerB = GameState.players[result.playerB];
      const humanId = GameState.humanPlayerIndex;

      playerAEl.textContent = playerA.name;
      playerAEl.style.background = playerA.color;
      playerAEl.style.color = '#fff';

      playerBEl.textContent = playerB.name;
      playerBEl.style.background = playerB.color;
      playerBEl.style.color = '#fff';

      // Determine result from human perspective
      const humanWon = result.winner === humanId;
      const humanLost = result.loser === humanId;
      const humanInvolved = humanWon || humanLost;

      if (humanInvolved) {
        if (humanWon) {
          resultEl.textContent = 'üèÜ VICTORY!';
          resultEl.className = 'matchup-result win';
          damageEl.textContent = '';
        } else {
          resultEl.textContent = 'üíÄ DEFEAT';
          resultEl.className = 'matchup-result loss';
          damageEl.textContent = `-${result.damage} HP`;
        }
      } else {
        const winner = result.winner !== null ? GameState.players[result.winner] : null;
        resultEl.textContent = winner ? `${winner.name} wins!` : 'Draw!';
        resultEl.className = 'matchup-result';
        damageEl.textContent = '';
      }

      display.classList.add('active');

      // Auto-hide after delay
      setTimeout(() => {
        display.classList.remove('active');
      }, 2500);
    }

    // Run multiplayer combat phase
    function runMultiplayerCombat() {
      if (GameState.mode !== 'multiplayer') return;
      if (combatState !== 'idle') return;

      GameState.phase = 'combat';

      // Have all bots take their turns first
      GameState.players.forEach(player => {
        if (player.isBot && player.isAlive) {
          BotAI.takeTurn(player);
        }
      });

      // Sync human player state to legacy variables
      const human = GameState.getHumanPlayer();
      playerBoard = human.board;
      bench = human.bench;
      gold = human.gold;
      health = human.health;
      playerLevel = human.level;

      // Find who the human is fighting this round
      const matchups = GameState.getMatchupsForRound();
      const humanMatchup = matchups.find(m =>
        m.playerA === GameState.humanPlayerIndex || m.playerB === GameState.humanPlayerIndex
      );

      if (!humanMatchup || Object.keys(playerBoard).length === 0) {
        // No matchup or no units - skip combat animation
        skipMultiplayerCombat();
        return;
      }

      // Determine opponent
      const opponentId = humanMatchup.playerA === GameState.humanPlayerIndex
        ? humanMatchup.playerB
        : humanMatchup.playerA;
      const opponent = GameState.players[opponentId];

      // Start animated combat against opponent's ghost army
      startAnimatedMultiplayerCombat(opponent, matchups);
    }

    function skipMultiplayerCombat() {
      // Run instant simulation for all matchups
      const results = MultiplayerCombat.runAllMatchups();
      MultiplayerCombat.applyResults();

      // Advance to next round
      renderScoreboard();
      const humanAfter = GameState.getHumanPlayer();
      gold = humanAfter.gold;
      health = humanAfter.health;
      updateUI();

      startNextMultiplayerRound();
    }

    function startAnimatedMultiplayerCombat(opponent, matchups) {
      // Save pre-combat positions for reset
      preCombatBoard = { ...playerBoard };

      combatState = 'combat';
      combatUnits = [];
      combatLog = [];
      visualEffects = [];
      combatStartTime = Date.now();
      lastCombatTime = combatStartTime;

      // Calculate synergy bonuses for player
      const synergyBonuses = getSynergyBonuses();
      activeCombatSynergies = synergyBonuses;

      // Show round banner with opponent name
      roundBanner = {
        text: `ROUND ${GameState.round}`,
        subtext: `vs ${opponent.name}`,
        color: opponent.color,
        startTime: Date.now(),
        duration: 1500
      };

      // Create player combat units
      Object.entries(playerBoard).forEach(([key, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;
        const unit = createCombatUnit(unitId, key, true, synergyBonuses, stars);
        if (unit) {
          unit.stars = stars;
          combatUnits.push(unit);
        }
      });

      // Create opponent's ghost army (mirrored to enemy rows)
      enemyBoard = {};
      const opponentSynergies = MultiplayerCombat.getSynergyBonusesForPlayer(opponent);

      Object.entries(opponent.board).forEach(([hexKey, unitData]) => {
        const unitId = typeof unitData === 'object' ? unitData.id : unitData;
        const stars = typeof unitData === 'object' ? unitData.stars : 1;

        // Mirror hex position: row 4->3, 5->2, 6->1, 7->0
        const [col, row] = hexKey.split(',').map(Number);
        const mirrorRow = 7 - row;
        const mirrorKey = `${col},${mirrorRow}`;

        enemyBoard[mirrorKey] = { id: unitId, stars: stars };

        const unit = createCombatUnit(unitId, mirrorKey, false, opponentSynergies, stars);
        if (unit) {
          unit.stars = stars;
          unit.ownerName = opponent.name;
          unit.ownerColor = opponent.color;
          combatUnits.push(unit);
        }
      });

      // Execute passive abilities
      combatUnits.forEach(u => executePassives(u));

      // Store matchups for later resolution
      currentMultiplayerMatchups = matchups;
      currentOpponent = opponent;

      // Log combat start
      combatLog.push(`=== COMBAT START ===`);
      combatLog.push(`You vs ${opponent.name}`);
      combatLog.push(`Your army: ${combatUnits.filter(u => u.isPlayer).length} units`);
      combatLog.push(`Enemy army: ${combatUnits.filter(u => !u.isPlayer).length} units`);

      document.getElementById('combatLog').style.display = 'block';
      updateCombatLog();
      renderBoard();

      // Start the combat loop!
      requestAnimationFrame(combatLoop);
    }

    let currentMultiplayerMatchups = null;
    let currentOpponent = null;

    // Modified combat end for multiplayer
    function endMultiplayerCombat(playerWon) {
      combatState = 'idle';

      // Run the full simulation for ALL matchups (including human's)
      const results = MultiplayerCombat.runAllMatchups();

      // Find human's result
      const humanBattle = MultiplayerCombat.getPlayerBattle(GameState.humanPlayerIndex);

      // Show result popup
      if (humanBattle) {
        showMatchupResult(humanBattle);
      }

      // Apply all results
      MultiplayerCombat.applyResults();

      // Update UI
      renderScoreboard();
      const humanAfter = GameState.getHumanPlayer();
      gold = humanAfter.gold;
      health = humanAfter.health;
      updateUI();

      // Reset board positions
      playerBoard = { ...preCombatBoard };
      enemyBoard = {};
      renderBoard();

      // Show combat log briefly
      document.getElementById('combatLog').style.display = 'block';
      const allLogs = results.flatMap(r => r.combatLog);
      combatLog = allLogs;
      updateCombatLog();

      // Check for game over after delay
      setTimeout(() => {
        document.getElementById('combatLog').style.display = 'none';
        startNextMultiplayerRound();
      }, 3000);
    }

    function startNextMultiplayerRound() {
      const humanAfter = GameState.getHumanPlayer();

      if (GameState.isGameOver()) {
        const winner = GameState.getWinner();
        const humanWon = winner && winner.id === GameState.humanPlayerIndex;

        roundBanner = {
          text: humanWon ? 'üèÜ VICTORY!' : 'üíÄ GAME OVER',
          subtext: humanWon ? 'You are the champion!' : `${winner?.name || 'Nobody'} wins!`,
          color: humanWon ? '#ffd700' : '#f44',
          startTime: Date.now(),
          duration: 5000
        };
        renderBoard();

        setTimeout(() => {
          if (confirm(humanWon ? 'Congratulations! Play again?' : 'Game Over! Play again?')) {
            location.reload();
          }
        }, 3000);
        return;
      }

      // Check if human is eliminated
      if (!humanAfter.isAlive) {
        const placement = humanAfter.placement || (8 - GameState.eliminationOrder.length);
        roundBanner = {
          text: 'üíÄ ELIMINATED',
          subtext: `You placed #${placement}`,
          color: '#f44',
          startTime: Date.now(),
          duration: 3000
        };
        renderBoard();

        setTimeout(() => {
          if (confirm(`You placed #${placement}! Watch the rest or restart?`)) {
            location.reload();
          }
        }, 2000);
        return;
      }

      // Advance to next round
      GameState.nextRound();
      currentRound = GameState.round;

      // Sync human's new shop
      const humanNext = GameState.getHumanPlayer();
      shopUnits = humanNext.shop;
      gold = humanNext.gold;

      roundBanner = {
        text: `ROUND ${GameState.round}`,
        subtext: `${GameState.getAliveCount()} players remaining`,
        color: '#fff',
        startTime: Date.now(),
        duration: 2000
      };

      renderShop();
      renderBoard();
      renderBench();
      renderScoreboard();
      updateUI();
    }

    // Sync human player actions to GameState
    function syncHumanToGameState() {
      if (GameState.mode !== 'multiplayer') return;

      const human = GameState.getHumanPlayer();
      human.board = { ...playerBoard };
      human.bench = [...bench];
      human.gold = gold;
      human.level = playerLevel;
      human.shop = [...shopUnits];
    }

    // Start single player mode
    function startSinglePlayer() {
      document.getElementById('mode-select').style.display = 'none';
      GameState.mode = 'single';
      init();
    }

    // Start multiplayer mode
    function startMultiplayer() {
      document.getElementById('mode-select').style.display = 'none';
      GameState.mode = 'multiplayer';

      // Initialize 8 players
      const human = GameState.init(1);

      // Sync human's initial state to legacy variables
      gold = human.gold;
      health = human.health;
      playerLevel = human.level;
      playerBoard = human.board;
      bench = human.bench;
      shopUnits = human.shop;
      currentRound = GameState.round;

      // Show scoreboard
      document.getElementById('scoreboard').classList.add('active');

      // Initialize game
      renderShop();
      renderBoard();
      renderBench();
      setupBenchEvents();
      updateUI();
      renderSynergies();
      renderScoreboard();

      // Change fight button to work with multiplayer
      document.getElementById('fight').onclick = function() {
        if (combatState !== 'idle') return;
        syncHumanToGameState();
        runMultiplayerCombat();
      };

      // Show initial banner
      roundBanner = {
        text: 'ROUND 1',
        subtext: '8 players - Round Robin!',
        color: '#ffd700',
        startTime: Date.now(),
        duration: 2500
      };

      requestAnimationFrame(animationLoop);
    }

    // ========== ONLINE MULTIPLAYER START ==========
    function startOnline() {
      document.getElementById('mode-select').style.display = 'none';
      const lobbyScreen = document.getElementById('lobby-screen');
      lobbyScreen.style.display = 'flex';
    }

    // Auto-detect WebSocket URL based on page location
    (function() {
      const input = document.getElementById('server-url');
      if (!input.value) {
        const loc = window.location;
        if (loc.hostname === '' || loc.hostname === 'localhost' || loc.protocol === 'file:') {
          input.value = 'ws://localhost:3000';
        } else {
          const wsProto = loc.protocol === 'https:' ? 'wss:' : 'ws:';
          input.value = wsProto + '//' + loc.host;
        }
      }
    })();

    // Lobby button handlers
    document.getElementById('btn-join-lobby').onclick = () => {
      const serverUrl = document.getElementById('server-url').value;
      const name = document.getElementById('player-name').value || 'Player';
      const lobbyCode = document.getElementById('lobby-code').value.toUpperCase() || null;
      NetworkManager.setStatus('Connecting...');
      NetworkManager.connect(serverUrl, name, lobbyCode, false);
    };

    document.getElementById('btn-practice').onclick = () => {
      const serverUrl = document.getElementById('server-url').value;
      const name = document.getElementById('player-name').value || 'Player';
      NetworkManager.setStatus('Starting practice game...');
      NetworkManager.connect(serverUrl, name, null, true);
    };

    document.getElementById('btn-start-game').onclick = () => {
      NetworkManager.send({ type: 'ready' });
      NetworkManager.setStatus('Starting game...');
    };

    document.getElementById('btn-lobby-back').onclick = () => {
      document.getElementById('lobby-screen').style.display = 'none';
      document.getElementById('mode-select').style.display = '';
      if (NetworkManager.ws) {
        NetworkManager.ws.close();
        NetworkManager.ws = null;
      }
    };

    // Hook up mode selection buttons
    document.getElementById('btn-single').onclick = startSinglePlayer;
    document.getElementById('btn-multiplayer').onclick = startMultiplayer;
    document.getElementById('btn-online').onclick = startOnline;

    // Check for reconnect data
    try {
      const saved = JSON.parse(sessionStorage.getItem('fffa_auth'));
      if (saved && saved.lobbyId && saved.authToken) {
        // Could auto-reconnect here ‚Äî for now just clear
      }
    } catch (e) {}

    // Initialize images (but don't start game until mode selected)
    loadUnitImages();

    // Load per-unit sprite sheets from unit_animations.json
    loadAnimConfigAndSheets();
  </script>
</body>
</html>